                                       1

                                       8

                                [SemiAlgebraic]

bound_info1 := proc(x, ineq, eps)
local i1, i2, j1, j2;
    if nops(ineq) = 2 then
        i1 := simplify(op(ineq[1])[1]);
        i2 := simplify(op(ineq[1])[2]);
        j1 := simplify(op(ineq[2])[1]);
        j2 := simplify(op(ineq[2])[2]);
        if evalb(i1 = x) then
            if evalb(j1 = x) then
                return [min(i2, j2) + eps, max(i2, j2) - eps]
            else return [min(i2, j1) + eps, max(i2, j1) - eps]
            end if
        else
            if evalb(j1 = x) then
                return [min(i1, j2) + eps, max(i1, j2) - eps]
            else return [min(i1, j1) + eps, max(i1, j1) - eps]
            end if
        end if
    else
        i1 := simplify(op(ineq[1])[1]);
        j1 := simplify(op(ineq[1])[2]);
        if type(ineq[1], `=`) then
            if evalb(i1 = x) then return [j1, j1]
            else return [i1, i1]
            end if
        end if;
        if type(ineq[1], `<=`) then
            if evalb(i1 = x) then return [-infinity, j1 - eps]
            else return [i1 + eps, infinity]
            end if
        end if
    end if
end proc

gen_nat_gens := proc(basis, x)
local S, intervals, size, i, out;
    S := SolveTools:-SemiAlgebraic(map(f -> 0 <= f, basis), [x]);
    intervals := map(ineq -> bound_info1(x, ineq, 0), S);
    size := nops(intervals);
    out := [];
    if size = 0 then return out end if;
    out := [x - intervals[1][1]];
    for i to size - 1 do
        out := [op(out), (x - intervals[i][2])*(x - intervals[i + 1][1])]
    end do;
    out := [op(out), -x + intervals[size][2]];
    return out
end proc

                                   [Generate]

genRandomPoint := proc(lowerbound, upperbound, _denominator)
    return RandomTools:-Generate(rational(range = lowerbound .. upperbound,
        denominator = _denominator))
end proc

intervalsGenerator := proc(
x, num_isolated_points, lowerbound, upperbound, _denominator)
local i, _lowerbound, _uppperbound, a, b;
    _lowerbound := lowerbound;
    _uppperbound := upperbound;
    return [seq(
        if evalb(modp(rand(), 2) = 0) then
            a := genRandomPoint(_lowerbound, _uppperbound, _denominator);
            b := genRandomPoint(_lowerbound, _uppperbound, _denominator);
            _lowerbound := max(a, b);
            if 1/_denominator <= abs(_lowerbound - _uppperbound) then
                _uppperbound := _uppperbound + _lowerbound
            end if;
            if evalb(a = b) then [a] else [min(a, b), max(a, b)] end if
        else
            a := genRandomPoint(_lowerbound, _uppperbound, _denominator);
            _lowerbound := a;
            if 1/_denominator <= abs(_lowerbound - _uppperbound) then
                _uppperbound := _uppperbound + _lowerbound
            end if;
            [a]
        end if, i = 1 .. num_isolated_points)]
end proc

getIsolatedPoints := proc(intervals)
local isolated_points, i;
    isolated_points := [];
    for i to nops(intervals) do
        isolated_points := [op(isolated_points), op(intervals[i])]
    end do;
    return isolated_points
end proc

uniformBasisGenerator := proc(x, intervals, k)
local i, g1, g2;
    g1 := 1;
    g2 := -1;
    for i to nops(intervals) do
        if nops(intervals[i]) = 1 then
            g2 := g2*(x - intervals[i][1])^(k + 1)
        else
            g1 := g1*(x - intervals[i][1])^k*(x - intervals[i][2])^k;
            g2 := g2*(x - intervals[i][1])^k*(x - intervals[i][2])^k
        end if
    end do;
    if evalb(g1 = 1) then return [x^2, g2] end if;
    return [g1, g2]
end proc

linearBasisGenerator :=

    proc(x, intervals) return uniformBasisGenerator(x, intervals, 1) end proc

                                   [Generate]

genRandomPoint := proc(lowerbound, upperbound, _denominator)
    return RandomTools:-Generate(rational(range = lowerbound .. upperbound,
        denominator = _denominator))
end proc

intervalsGenerator := proc(
x, num_isolated_points, lowerbound, upperbound, _denominator)
local i, _lowerbound, _uppperbound, a, b;
    _lowerbound := lowerbound;
    _uppperbound := upperbound;
    return [seq(
        if evalb(modp(rand(), 2) = 0) then
            a := genRandomPoint(_lowerbound, _uppperbound, _denominator);
            b := genRandomPoint(_lowerbound, _uppperbound, _denominator);
            _lowerbound := max(a, b);
            if 1/_denominator <= abs(_lowerbound - _uppperbound) then
                _uppperbound := _uppperbound + _lowerbound
            end if;
            if evalb(a = b) then [a] else [min(a, b), max(a, b)] end if
        else
            a := genRandomPoint(_lowerbound, _uppperbound, _denominator);
            _lowerbound := a;
            if 1/_denominator <= abs(_lowerbound - _uppperbound) then
                _uppperbound := _uppperbound + _lowerbound
            end if;
            [a]
        end if, i = 1 .. num_isolated_points)]
end proc

getIsolatedPoints := proc(intervals)
local isolated_points, i;
    isolated_points := [];
    for i to nops(intervals) do
        isolated_points := [op(isolated_points), op(intervals[i])]
    end do;
    return isolated_points
end proc

basisNoBoundedPoly := proc(x, intervals, k)
local i, max_point, count_num_roots, g1, g2;
    count_num_roots := 0;
    g1 := 1;
    g2 := -1;
    for i to nops(intervals) do
        if nops(intervals[i]) = 1 then
            max_point := intervals[i][1];
            count_num_roots := count_num_roots + 1;
            g1 := g1*(x - intervals[i][1])^k;
            g2 := g2*(x - intervals[i][1])^k
        else
            max_point := intervals[i][2];
            count_num_roots := count_num_roots + 2;
            g1 := g1*(x - intervals[i][1])^k*(x - intervals[i][2])^k;
            g2 := g2*(x - intervals[i][1])^k*(x - intervals[i][2])^k
        end if
    end do;
    if evalb(count_num_roots mod 2 = 0) then
        g1 := g1*(x - max_point - 1)^k; g2 := g2*(x - max_point - 1)^k
    end if;
    return [g1, g2]
end proc

linearBasisNoBoundedPoly :=

    proc(x, intervals) return basisNoBoundedPoly(x, intervals, 1) end proc

                                   [Generate]

genRandomPoint := proc(lowerbound, upperbound, _denominator)
    return RandomTools:-Generate(rational(range = lowerbound .. upperbound,
        denominator = _denominator))
end proc

intervalsGenerator := proc(
x, num_isolated_points, lowerbound, upperbound, _denominator)
local i, _lowerbound, _uppperbound, a, b;
    _lowerbound := lowerbound;
    _uppperbound := upperbound;
    return [seq(
        if evalb(modp(rand(), 2) = 0) then
            a := genRandomPoint(_lowerbound, _uppperbound, _denominator);
            b := genRandomPoint(_lowerbound, _uppperbound, _denominator);
            _lowerbound := max(a, b);
            if 1/_denominator <= abs(_lowerbound - _uppperbound) then
                _uppperbound := _uppperbound + _lowerbound
            end if;
            if evalb(a = b) then [a] else [min(a, b), max(a, b)] end if
        else
            a := genRandomPoint(_lowerbound, _uppperbound, _denominator);
            _lowerbound := a;
            if 1/_denominator <= abs(_lowerbound - _uppperbound) then
                _uppperbound := _uppperbound + _lowerbound
            end if;
            [a]
        end if, i = 1 .. num_isolated_points)]
end proc

getIsolatedPoints := proc(intervals)
local isolated_points, i;
    isolated_points := [];
    for i to nops(intervals) do
        isolated_points := [op(isolated_points), op(intervals[i])]
    end do;
    return isolated_points
end proc

strictlyLeftPolynomial := proc(x, isolated_points, _denominator)
local lowerbound, upperbound, rational_point;
    lowerbound := isolated_points[1];
    upperbound := isolated_points[nops(isolated_points)];
    rational_point := genRandomPoint(lowerbound, upperbound, _denominator);
    return x - lowerbound + rational_point
end proc

strictlyRightPolynomial := proc(x, isolated_points, _denominator)
local lowerbound, upperbound, rational_point;
    lowerbound := isolated_points[1];
    upperbound := isolated_points[nops(isolated_points)];
    rational_point := genRandomPoint(lowerbound, upperbound, _denominator);
    return -x + rational_point + upperbound
end proc

inbetweenPolynomial := proc(x, isolated_points, _denominator)
local num_isolated_points, choice, a, b;
    num_isolated_points := nops(isolated_points);
    choice := 1 + (rand() mod (num_isolated_points - 1));
    a := genRandomPoint(isolated_points[choice],
        isolated_points[choice + 1], _denominator);
    b := genRandomPoint(isolated_points[choice],
        isolated_points[choice + 1], _denominator);
    while evalb(a = b) do
        a := genRandomPoint(isolated_points[choice],
            isolated_points[choice + 1], _denominator);
        b := genRandomPoint(isolated_points[choice],
            isolated_points[choice + 1], _denominator)
    end do;
    return (x - a)*(x - b)
end proc

getArchimedeanPolynomial := proc(x, isolated_points, offset)
local max_point;
    max_point := max(abs(isolated_points[1]),
        abs(isolated_points[nops(isolated_points)])) + offset;
    return expand(-(x - max_point)*(x + max_point))
end proc

                                [SemiAlgebraic]

                    [SemiAlgebraicSetTools, PolynomialRing]

                              [Maximize, Minimize]

                                     [Text]

                           [Open, Close, WriteString]

_pwd := "/Users/typesarespaces/Documents/GithubProjects/phd-thesis/Documents\
    /Seminars/BeihangUniversity-Fall2021/Weifeng-Notes/Weifeng-Certificates/\
    tests"

  "/Users/typesarespaces/Documents/GithubProjects/phd-thesis/Documents/Seminars/BeihangUniversity-Fall2021/Weifeng-Notes/Weifeng-Certificates/tests"

                            "/Users/typesarespaces"

univsos1 := proc(f)
local s, X;
    X := op(indets(f));
    s := SOSDecomp(expand(f), X, 0);
    return HornerToList1(s)
end proc

Warning, (in SOSDecomp) `s` is implicitly declared local
|univsos/univsos1.mm:54|
SOSDecomp := proc(f, X, prec::integer := 64)
local g, h, S, SEVEN, SODD, newF, s;
    if degree(f) = 0 and f < 0 then
        lprint(f);
        error "There is no decomposition into sum of squares for this po\
            lynomial"
    end if;
    if degree(f) = 0 and 0 <= f then return [[0, [0, 0, f]]] end if;
    if f = 0 then return [[0, [0, 0, 0]]] end if;
    if lcoeff(f, X) < 0 then
        lprint(f);
        error "There is no decomposition into sum of squares for this po\
            lynomial"
    end if;
    if irem(degree(f), 2) = 1 then
        lprint(f);
        error "There is no decomposition into sum of squares for this po\
            lynomial"
    else
        if degree(f, X) = 2 then return [[0, SOSDecompDegree2(f, X)]]
        end if;
        g := gcd(f, diff(f, X), 'newF');
        if degree(g) = 1 then
            newF := quo(newF, g, X);
            if degree(newF) = 2 then
                return [[g, [0, 0, 0]], [0, SOSDecompDegree2(newF, X)]]
            else return [[g, [0, 0, 0]], op(SOSDecompSQF(newF, X, prec))]
            end if
        end if;
        S := sqrfree(f);
        SEVEN := map(
            _e -> if type(_e[2], even) then _e[1]^(1/2*_e[2]) end if, S[2])
            ;
        SEVEN := [op(SEVEN), op(map(
            _e -> if type(_e[2], odd) then _e[1]^(1/2*_e[2] - 1/2) end if,
            S[2]))];
        SEVEN := remove(member, SEVEN, [1]);
        SODD := map(_e -> if type(_e[2], odd) then _e[1] end if, S[2]);
        if nops(SEVEN) = 0 then return SOSDecompSQF(f, X, prec)
        else
            g := mul(s, s in SEVEN);
            h := S[1]*mul(s, s in SODD);
            return [[g, [0, 0, 0]], op(SOSDecomp(h, X, prec))]
        end if
    end if
end proc

SOSDecompSQF := proc(f, X, prec::integer := 64)
local g, h, content_h, SOS_h, SOS_g;
    g := ConstructGPolynomial(f, X, 10);
    h := expand(f - g[1]*g[2]^2);
    if h <> 0 then
        SOS_g := g;
        SOS_h := SOSDecomp(h, X, prec);
        return [[1, SOS_g], op(SOS_h)]
    else SOS_g := g; return [[0, SOS_g]]
    end if
end proc

SOSDecompDegree2 := proc(f, X)
local a, b, c, mycouple;
    if f = 0 then return [f, 0, 0] end if;
    if degree(f) = 0 and 0 < f then return [0, 0, f] end if;
    if degree(f) = 1 or degree(f) = 0 and f < 0 or coeff(f, X, 2) < 0 or
    0 < coeff(f, X, 1)^2 - 4*coeff(f, X, 2)*coeff(f, X, 0) then
        lprint(f);
        error "There is no decomposition into sum of squares for this po\
            lynomial"
    end if;
    c, b, a := seq(coeff(f, X, i), i = 0 .. 2);
    return [a, X + 1/2*b/a, c - 1/4*b^2/a]
end proc

ConstructGPolynomial := proc(f, X, myprec := 10)
local i, inv_roots1, smallest, sf, sdf, g, t, df, values, mymin, minimizer,
a, b, c, newt, _interval, count, mybound, boo;
    df := numer(diff(f, X));
    inv_roots1 := map(s -> rhs(s),
        RootFinding[Isolate](df, X, digits = myprec, output = interval));
    values := map(_s -> subs(X = _s, f), map(_r -> _r[1], inv_roots1));
    mymin := min(op(values));
    for i to nops(inv_roots1) do
        if subs(X = inv_roots1[i][1], f) = mymin then
            minimizer := inv_roots1[i]; _interval := inv_roots1[i]
        end if
    end do;
    if myprec = 0 then t := round(minimizer[1])
    else
        if minimizer[1] < 0 then t := ceil(minimizer[1])
        else t := floor(minimizer[1])
        end if
    end if;
    sf := subs(X = t, f);
    if sf = 0 then
        lprint(f);
        error "There is no decomposition into sum of squares for this po\
            lynomial"
    end if;
    sdf := subs(X = t, diff(f, X));
    a := 1/4*sdf^2/sf;
    c := sf - sdf*t + 1/4*t^2*sdf^2/sf;
    b := sdf - 1/2*sdf^2*t/sf;
    boo := CheckTvalue(t, a, b, c, f, X);
    if boo then return [1/sf, 1/2*sdf*(X - t) + sf, 0] end if;
    if 0 < minimizer[1] - t then mybound := floor(log[2](minimizer[1] - t))
    else mybound := myprec
    end if;
    count := mybound;
    t := t + 2^mybound;
    sf := subs(X = t, f);
    sdf := subs(X = t, diff(f, X));
    while boo = false and 0 <= sf and t < minimizer[2] and sdf <= 0 do
        a := 1/4*sdf^2/sf;
        c := sf - sdf*t + 1/4*t^2*sdf^2/sf;
        b := sdf - 1/2*sdf^2*t/sf;
        boo := CheckTvalue(t, a, b, c, f, X);
        if boo = true then return [1/sf, 1/2*sdf*(X - t) + sf, 0] end if;
        newt := t + 2^count;
        sf := subs(X = newt, f);
        sdf := subs(X = newt, diff(f, X));
        while minimizer[2] <= newt or sf <= 0 do
            count := count - 1; newt := t + 2^count
        end do;
        t := newt
    end do;
    return ConstructGPolynomialRec(f, X, 2*myprec)
end proc

getcoeffs := proc(f, X)
local c, nc, dc, lcmf;
    c := PolynomialTools:-CoefficientVector(f, X);
    nc, dc := MTM[numden](c);
    lcmf := ilcm(op(convert(dc, list)));
    return Vector(lcmf*c)
end proc

ConstructGPolynomialRec := proc(f, X, myprec, useNewton::boolean := false,
aNewton::rational := 0, bNewton::rational := 0)
local mid, fcoeffs, newaNewton, newbNewton, dfa, dfb, i, inv_roots1,
smallest, sf, sdf, g, t, df, values, mymin, minimizer, a, b, c, _interval;
    df := convert(diff(f, X), horner);
    if useNewton then
        mid := 1/2*aNewton + 1/2*bNewton;
        fcoeffs := getcoeffs(diff(f, X), X);
        newaNewton, newbNewton :=
            MyUnivariateNewton(fcoeffs, aNewton, bNewton, mid);
        if 0 < newaNewton then t := newbNewton else t := newaNewton end if
    else
        inv_roots1 := fgbrs:-rs_isolate_uni(primpart(diff(f, X)), X,
            precision = myprec, verbose = 0);
        values := map(_s -> subs(X = _s, f), map(_r -> _r[1], inv_roots1));
        mymin := min(op(values));
        for i to nops(inv_roots1) do
            if subs(X = inv_roots1[i][1], f) = mymin then
                minimizer := inv_roots1[i]; _interval := inv_roots1[i]
            end if
        end do;
        newaNewton := minimizer[1];
        newbNewton := minimizer[2];
        t := minimizer[1]
    end if;
    sf := subs(X = t, f);
    if sf = 0 then
        error "There is no decomposition into sum of squares for this po\
            lynomial"
    end if;
    sdf := subs(X = t, df);
    a := 1/4*sdf^2/sf;
    c := sf - sdf*t + t^2*a;
    b := sdf - 2*t*a;
    if CheckTvalue(t, a, b, c, f, X) then
        return [1/sf, 1/2*sdf*(X - t) + sf, 0]
    end if;
    return ConstructGPolynomialRec(f, X, 2*myprec, false, newaNewton,
        newbNewton)
end proc

NaiveBolzano := proc(f, X)
local df, inv_roots1, values, mymin, i, minimizer, _interval, t1, t2;
    df := convert(diff(f, X), horner);
    inv_roots1 := fgbrs:-rs_isolate_uni(primpart(diff(f, X)), X,
        precision = 2, verbose = 0);
    values := map(_s -> subs(X = _s, f), map(_r -> _r[1], inv_roots1));
    mymin := min(op(values));
    for i to nops(inv_roots1) do
        if subs(X = inv_roots1[i][1], f) = mymin then
            minimizer := inv_roots1[i]; _interval := inv_roots1[i]
        end if
    end do;
    t1 := minimizer[1];
    t2 := minimizer[2];
    return BolzanoRec(f, df, X, t1, t2)
end proc

BolzanoRec := proc(f, df, X, t1, t2)
local t, sf, sdf, a, c, b;
    t := 1/2*t1 + 1/2*t2;
    sf := subs(X = t, f);
    if sf = 0 then
        error "There is no decomposition into sum of squares for this po\
            lynomial"
    end if;
    sdf := subs(X = t, df);
    a := 1/4*sdf^2/sf;
    c := sf - sdf*t + t^2*a;
    b := sdf - 2*a*t;
    if sdf = 0 then return [1/sf, 1/2*sdf*(X - t) + sf, 0] end if;
    if 0 < sdf then
        if CheckTvalue(t, a, b, c, f, X) then
            return [1/sf, 1/2*sdf*(X - t) + sf, 0]
        end if;
        return BolzanoRec(f, df, X, t1, t)
    end if;
    if CheckTvalue(t, a, b, c, f, X) then
        return [1/sf, 1/2*sdf*(X - t) + sf, 0]
    end if;
    return BolzanoRec(f, df, X, t, t2)
end proc

ConFrac := proc(t, f, df, X, sf, sdf, myprec)
local newt, newsf, newsdf, a, b, c;
    newt := confrac2rat(convert(t, confrac, myprec));
    lprint(newt);
    newsf := subs(X = t, f);
    newsdf := subs(X = t, df);
    a := 1/4*newsdf^2/newsf;
    c := newsf - newsdf*newt + newt^2*a;
    b := newsdf - 2*a*newt;
    if CheckTvalue(newt, a, b, c, f, X) then
        return [1/newsf, 1/2*newsdf*(X - newt) + newsf, 0]
    else return [1/sf, 1/2*sdf*(X - t) + sf, 0]
    end if
end proc

SmallerApprox := proc(t, f, df, X, sf, sdf)
local newt, newsf, newsdf, a, b, c, myprec;
    myprec := floor(1/8*BitRat(t));
    if 0 < t then newt := BinaryApproximationDown(t, myprec)
    else newt := BinaryApproximationUp(t, myprec)
    end if;
    newsf := subs(X = t, f);
    newsdf := subs(X = t, df);
    a := 1/4*newsdf^2/newsf;
    c := newsf - newsdf*newt + newt^2*a;
    b := newsdf - 2*a*newt;
    if CheckTvalue(newt, a, b, c, f, X) then
        lprint("After rounding ", newt);
        return [1/newsf, 1/2*newsdf*(X - newt) + newsf, 0]
    else return [1/sf, 1/2*sdf*(X - t) + sf, 0]
    end if
end proc

Warning, (in CheckTvalue) `s` is implicitly declared local
|univsos/univsos1.mm:370|
CheckTvalue := proc(t, a, b, c, f, X)
local F, S, SODD, newg, g, newF, s;
    if a = 0 and b <> 0 or a = 0 and b = 0 and c < 0 then return false
    end if;
    if a <> 0 and 0 < b^2 - 4*a*c then return false end if;
    F := f - a*X^2 - b*X - c;
    g := gcd(F, diff(F, X), 'newF');
    if degree(g) = 1 then
        newF := quo(newF, g, X);
        if 0 < nops(fgbrs:-rs_isolate_uni(numer(newF), X, precision = 1))
        then return false
        else return true
        end if
    else
        S := sqrfree(F);
        SODD := map(_e -> if type(_e[2], odd) then _e[1] end if, S[2]);
        SODD := mul(s, s in SODD);
        if 0 < nops(fgbrs:-rs_isolate_uni(SODD, X, precision = 1)) then
            return false
        else return true
        end if
    end if
end proc

Warning, (in oldCheckTvalue) `s` is implicitly declared local
|univsos/univsos1.mm:402|
oldCheckTvalue := proc(t, g, f, X)
local a, b, c, F, S, SODD, newg, s;
    a, b, c := coeff(g, X, 2), coeff(g, X, 1), coeff(g, X, 0);
    if a = 0 and b <> 0 or a = 0 and b = 0 and c < 0 then return false
    end if;
    if a <> 0 and 0 < b^2 - 4*c*a then return false end if;
    F := normal(f - g);
    S := sqrfree(F);
    SODD := map(_e -> if type(_e[2], odd) then _e[1] end if, S[2]);
    SODD := mul(s, s in SODD);
    if 0 < nops(fgbrs:-rs_isolate_uni(primpart(SODD), X, precision = 1))
    then return false
    else return true
    end if
end proc

MyNewtonIterator := proc(_interval, pol)
local a, b, c, X, newa;
    a := _interval[1];
    b := _interval[2];
    X := op(1, indets(pol));
    newa := a - subs({X = a}, pol)/subs({X = a}, diff(pol, X));
    return [newa, b]
end proc

BolzanoIterator := proc(_interval, pol)
local a, b, c, X, sc;
    a := _interval[1];
    b := _interval[2];
    c := 1/2*a + 1/2*b;
    X := op(1, indets(pol));
    sc := eval(pol, X = c);
    if sc = 0 then return [a, c] end if;
    if sign(sc) = sign(eval(pol, X = a)) then return [c, b]
    else return [a, c]
    end if
end proc

Warning, (in UnivariateSumOfSquaresDecItv) `i` is implicitly declared local
|univsos/univsos1.mm:468|
Warning, (in UnivariateSumOfSquaresDecItv) `c` is implicitly declared local
|univsos/univsos1.mm:476|
Warning, (in UnivariateSumOfSquaresDecItv) `si` is implicitly declared local
|univsos/univsos1.mm:479|
Warning, (in UnivariateSumOfSquaresDecItv) `r` is implicitly declared local
|univsos/univsos1.mm:484|
Warning, (in UnivariateSumOfSquaresDecItv) `j` is implicitly declared local
|univsos/univsos1.mm:484|
Warning, (in UnivariateSumOfSquaresDecItv) `t` is implicitly declared local
|univsos/univsos1.mm:485|
UnivariateSumOfSquaresDecItv := proc(f, a, b)
local psatz, bitsos, n, cf, q, sosq, clist, soslist, rlist, tlist, nc, l,
sosf1, sosf2, sosdecomp, ti, tcmp, sos, i, c, si, r, j, t;
    psatz := false;
    n := degree(f);
    if n = 0 and f < 0 then
        error "There is no decomposition into sum of squares for this po\
            lynomial"
    end if;
    if b < a then
        error cat("The interval [", convert(a, string), ", ",
            convert(b, string), "] is not valid")
    end if;
    q := add(coeff(f, x, i)*(y^2 + 1)^(n - i)*(a + b*y^2)^i, i = 0 .. n);
    ti := time();
    sosq := SOSDecomp(q, y, 2);
    tcmp := time() - ti;
    lprint(tcmp);
    if psatz = true then
        sos := HornerToList(sosq);
        clist := [seq(c[1]/(b - a)^n, c in sos)];
        soslist := [seq(c[2], c in sos)];
        rlist := [seq(
            add(coeff(si, y, 2*i)*y^i, i = 0 .. ceil(degree(1/2*si))),
            si in soslist)];
        tlist := [seq(
            add(coeff(si, y, 2*i + 1)*y^i, i = 0 .. ceil(degree(1/2*si))),
            si in soslist)];
        nc := floor(1/2*n);
        l := nops(clist);
        sosf1 := [seq(add(coeff(r, y, j)*(x - a)^j*(b - x)^(nc - j),
            j = 0 .. degree(r)), r in rlist)];
        if n mod 2 = 0 then
            sosf2 := [seq(add(
                coeff(t, y, j)*(x - a)^j*(b - x)^(nc - 1 - j),
                j = 0 .. degree(t)), t in tlist)]
        else
            sosf2 := [seq(add(coeff(t, y, j)*(x - a)^j*(b - x)^(nc - j),
                j = 0 .. degree(t)), t in tlist)]
        end if;
        return clist, sosf1, sosf2
    end if;
    return q, sosq
end proc

HornerToList := proc(sos)
local hd, tl, p, c, q, d;
    if nops(sos) = 0 then return [] end if;
    if nops(sos) = 1 then
        p, c, q, d := sos[1][1], op(sos[1][2]);
        if c = 0 and d = 0 then return [[1, p]] end if;
        if c = 0 then return [[1, p], [d, 1]] end if;
        if d = 0 then return [[1, p], [c, q]] end if;
        return [[1, p], [c, q], [d, 1]]
    end if;
    hd, tl := HdTailList(sos);
    p, c, q, d := hd[1], op(hd[2]);
    if c = 0 and d = 0 then return [op(MulPolList2(p, HornerToList(tl)))]
    end if;
    if c = 0 then return [op(MulPolList2(p, HornerToList(tl))), [d, 1]]
    end if;
    if d = 0 then return [op(MulPolList2(p, HornerToList(tl))), [c, q]]
    end if;
    return [op(MulPolList2(p, HornerToList(tl))), [c, q], [d, 1]]
end proc

Warning, (in HdTailList) `i` is implicitly declared local
|univsos/univsos1.mm:507|
HdTailList :=

    proc(l) local i; return l[1], [seq(l[i], i = 2 .. nops(l))] end proc

       MulPolList2 := proc(p, l) map(el -> [el[1], p*el[2]], l) end proc

              MulPolList := proc(p, l) map(el -> p*el, l) end proc

HornerToList1 := proc(l)
local l1;
    l1 := HornerToList(l);
    return foldr((a, b) -> [op(a), op(b)], [], op(l1))
end proc

SOSCHECK := proc(f, sos)
local res;
    res := expand(f - foldr(
        (_e, a) -> _e[1]^2*a + _e[2][1]*_e[2][2]^2 + _e[2][3], 1, op(sos)))
        ;
    if res = 0 then return res
    else
        lprint(f);
        lprint(sos);
        error "Invalid sum of squares decomposition"
    end if
end proc

SOSCHECK2 := proc(f, sos)
local s, i, res;
    s := 0;
    for i to 1/2*nops(sos) do s := s + sos[2*i - 1]*sos[2*i]^2 end do;
    res := expand(f - s);
    if res = 0 then return res
    else
        lprint(f);
        lprint(sos);
        error "Invalid sum of squares decomposition"
    end if
end proc

          soscheck1 := proc(f, sos) return SOSCHECK2(f, sos) end proc

Warning, (in univsos2) `se` is implicitly declared local
|univsos/univsos2.mm:23|
Warning, (in univsos2) `so` is implicitly declared local
|univsos/univsos2.mm:24|
univsos2 := proc(p, id::integer := 2, iter::boolean := false)
local x, S, s, c, SEVEN, SODD, q, n, m, t, e, r, k, ok, l, a, p_can, p_cnj,
s1, s2, u, v, i, j, sqs, cfs, sos, rfloat, gp, gproots, se, so;
    x := op(indets(p));
    S := sqrfree(p);
    c := lcoeff(p);
    if c < 0 then
        lprint(p);
        lprint(c);
        error "There is no decomposition into sum of squares for this po\
            lynomial"
    end if;
    SEVEN :=
        map(_e -> if type(_e[2], even) then _e[1]^(1/2*_e[2]) end if, S[2])
        ;
    SEVEN := [op(SEVEN), op(map(
        _e -> if type(_e[2], odd) then _e[1]^(1/2*_e[2] - 1/2) end if, S[2]))
        ];
    SEVEN := remove(member, SEVEN, [1]);
    SODD := map(_e -> if type(_e[2], odd) then _e[1] end if, S[2]);
    s := mul(se, se in SEVEN);
    q := S[1]*mul(so, so in SODD);
    n := degree(q, x);
    m := floor(1/2*n);
    if 2*m <> n then
        lprint(p);
        error "There is no decomposition into sum of squares for this po\
            lynomial"
    end if;
    if n = 0 then lprint(q, " * (", s, ")^2") end if;
    t := q;
    if id = 2 then t := sum(x^(2*i), i = 0 .. m)
    else if id = 1 then t := sum(x^j, j = 0 .. n) end if
    end if;
    e := max(1, c);
    printf("Perturbation loop\n");
    while q - e*t <> 0 and 0 < nops(realroot(q - e*t)) do e := 1/2*e end do
    ;
    printf("  epsilon = ");
    lprint(e);
    e := 1/2*e;
    r := q - e*t;
    k := 1;
    ok := false;
    printf("Root isolation loop\n");
    while not ok do
        k := 2*k;
        l := lcoeff(r, x);
        printf("  precision of root isolation = %d\n", k);
        gproots := true;
        gp := true;
        if gp then s1, s2 := gpsquares(r, x, k, iter)
        else
            a := polroots(r, x, gproots, iter);
            p_can := mul(x - a[2*i - 1], i = 1 .. 1/2*degree(r));
            p_cnj := mul(x - a[2*i], i = 1 .. 1/2*degree(r));
            s1 := convert(evalc(Re(1/2*p_can + 1/2*p_cnj)), rational, k);
            s2 := convert(evalc(Re(-1/2*I*(p_can - p_cnj))), rational, k)
        end if;
        u := r - l*(s1^2 + s2^2);
        v := expand(e*t + u);
        ok := true;
        for i from 0 to m do
            ok := ok and
                1/4*abs(coeff(v, x, 2*i + 1)) + abs(coeff(v, x, 2*i - 1))
                 <= coeff(v, x, 2*i)
        end do
    end do;
    sqs := [s1, s2];
    cfs := [l, l];
    for i from 0 to m do
        sqs := [op(sqs), x^i];
        cfs := [op(cfs), coeff(v, x, 2*i) - 1/4*abs(coeff(v, x, 2*i + 1))
             - abs(coeff(v, x, 2*i - 1))]
    end do;
    for i from 0 to m - 1 do
        sqs := [op(sqs), x^i*(x + 1/2*sign(coeff(v, x, 2*i + 1)))];
        cfs := [op(cfs), abs(coeff(v, x, 2*i + 1))]
    end do;
    sos := [];
    for i to 2*m + 3 do sos := [op(sos), cfs[i], s*sqs[i]] end do;
    return sos
end proc

Warning, (in UnivariateSumOfSquaresDecItv2) `i` is implicitly declared local
|univsos/univsos2.mm:129|
Warning, (in UnivariateSumOfSquaresDecItv2) `c` is implicitly declared local
|univsos/univsos2.mm:137|
Warning, (in UnivariateSumOfSquaresDecItv2) `si` is implicitly declared local
|univsos/univsos2.mm:140|
Warning, (in UnivariateSumOfSquaresDecItv2) `r` is implicitly declared local
|univsos/univsos2.mm:145|
Warning, (in UnivariateSumOfSquaresDecItv2) `j` is implicitly declared local
|univsos/univsos2.mm:145|
Warning, (in UnivariateSumOfSquaresDecItv2) `t` is implicitly declared local
|univsos/univsos2.mm:146|
UnivariateSumOfSquaresDecItv2 := proc(f, a, b)
local psatz, bitsos, n, cf, q, sosq, clist, soslist, rlist, tlist, nc, l,
sosf1, sosf2, sosdecomp, ti, tcmp, sos, i, c, si, r, j, t;
    psatz := false;
    n := degree(f);
    if n = 0 and f < 0 then
        error "There is no decomposition into sum of squares for this po\
            lynomial"
    end if;
    if b < a then
        error cat("The interval [", convert(a, string), ", ",
            convert(b, string), "] is not valid")
    end if;
    q := add(coeff(f, x, i)*(y^2 + 1)^(n - i)*(a + b*y^2)^i, i = 0 .. n);
    ti := time[real]();
    sosq := univsos2(expand(q), y, 2);
    tcmp := time[real]() - ti;
    printf("%fms\n", 1000*tcmp);
    if psatz = true then
        sos := HornerToList(sosq);
        clist := [seq(c[1]/(b - a)^n, c in sos)];
        soslist := [seq(c[2], c in sos)];
        rlist := [seq(
            add(coeff(si, y, 2*i)*y^i, i = 0 .. ceil(degree(1/2*si))),
            si in soslist)];
        tlist := [seq(
            add(coeff(si, y, 2*i + 1)*y^i, i = 0 .. ceil(degree(1/2*si))),
            si in soslist)];
        nc := floor(1/2*n);
        l := nops(clist);
        sosf1 := [seq(add(coeff(r, y, j)*(x - a)^j*(b - x)^(nc - j),
            j = 0 .. degree(r)), r in rlist)];
        if n mod 2 = 0 then
            sosf2 := [seq(add(
                coeff(t, y, j)*(x - a)^j*(b - x)^(nc - 1 - j),
                j = 0 .. degree(t)), t in tlist)]
        else
            sosf2 := [seq(add(coeff(t, y, j)*(x - a)^j*(b - x)^(nc - j),
                j = 0 .. degree(t)), t in tlist)]
        end if;
        return clist, sosf1, sosf2
    end if;
    return q, sosq
end proc

gpsquares := proc(r, x, k, iter)
local fd, ok, prec, cmd, status;
    fd := fopen("univsos/in.gp", WRITE, TEXT);
    writeline(fd, "r =", StringTools:-SubstituteAll(
        StringTools:-SubstituteAll(convert(r, string), "\n", ""), "\\", ""))
        ;
    writeline(fd, "x =", convert(x, string));
    writeline(fd, "k =", convert(k, string));
    fclose(fd);
    ok := true;
    if iter then
        prec := 1000000000;
        while ok do
            if FileTools:-Exists("univsos/out.mm") then
                FileTools:-Remove("univsos/out.mm")
            end if;
            cmd := sprintf("gp -q -s %d univsos/gpsquares.gp", prec);
            ssystem(cmd);
            try read "univsos/out.mm"
            catch:
                prec := 10*prec;
                printf("   Issue with PARI/GP root isolation: trying wit\
                    h stack precision = %d\n", prec)
            finally ok := false
            end try
        end do
    else
        if FileTools:-Exists("univsos/out.mm") then
            FileTools:-Remove("univsos/out.mm")
        end if;
        ssystem("gp -q univsos/gpsquares.gp");
        read "univsos/out.mm"
    end if;
    return s1gp, s2gp
end proc

polroots := proc(r, x, gproots)
local fd, a, rfloat;
    rfloat := r;
    if gproots then
        fd := fopen("univsos/in.gp", WRITE, TEXT);
        writeline(fd, "r =", convert(rfloat, string));
        fclose(fd);
        if FileTools:-Exists("univsos/out.mm") then
            FileTools:-Remove("univsos/out.mm")
        end if;
        ssystem("gp -q  univsos/mypolroots.gp");
        ssystem("sed -i 's/0\\.E/0\\.0E/g' univsos/out.mm");
        ssystem("sed -i 's/ E/E/g' univsos/out.mm");
        read "univsos/out.mm";
        return agp
    else
        a := [fsolve([r = 0], x, complex, fulldigits)];
        return map(sol -> rhs(sol[1]), a)
    end if
end proc

SOSCHECK2 := proc(f, sos)
local s, i, res;
    s := 0;
    for i to 1/2*nops(sos) do s := s + sos[2*i - 1]*sos[2*i]^2 end do;
    res := expand(f - s);
    if res = 0 then return res
    else
        lprint(f);
        lprint(sos);
        error "Invalid sum of squares decomposition"
    end if
end proc

          soscheck2 := proc(f, sos) return SOSCHECK2(f, sos) end proc

Warning, (in univsos3) `se` is implicitly declared local
|univsos/univsos3.mm:21|
Warning, (in univsos3) `so` is implicitly declared local
|univsos/univsos3.mm:22|
univsos3 := proc(p, prec::integer := 10)
local S, s, c, SEVEN, SODD, q, n, m, t, e, r, ok, l, a, p_can, p_cnj, s1,
s2, u, v, i, j, sqs, cfs, sos, rfloat, gp, eigs, eigs2, soslist, soslist2,
sumsos, cnd, maxq, k, obj_plus_r0, id, x, se, so;
    x := op(indets(p));
    id := 2;
    S := sqrfree(p);
    c := lcoeff(p);
    if c < 0 then
        lprint(p);
        error "There is no decomposition into sum of squares for this po\
            lynomial"
    end if;
    SEVEN :=
        map(_e -> if type(_e[2], even) then _e[1]^(1/2*_e[2]) end if, S[2])
        ;
    SEVEN := [op(SEVEN), op(map(
        _e -> if type(_e[2], odd) then _e[1]^(1/2*_e[2] - 1/2) end if, S[2]))
        ];
    SEVEN := remove(member, SEVEN, [1]);
    SODD := map(_e -> if type(_e[2], odd) then _e[1] end if, S[2]);
    s := mul(se, se in SEVEN);
    q := S[1]*mul(so, so in SODD);
    maxq := 1;
    q := q/maxq;
    n := degree(q, x);
    m := floor(1/2*n);
    if 2*m <> n then
        lprint(p);
        error "There is no decomposition into sum of squares for this po\
            lynomial"
    end if;
    if n = 0 then lprint(q, " * (", s, ")^2") end if;
    t := q;
    if id = 2 then t := sum(x^(2*i), i = 0 .. m)
    else if id = 1 then t := sum(x^j, j = 0 .. n) end if
    end if;
    e := min(1, c);
    while
    degree(q - e*t, x) <= 0 or q - e*t <> 0 and 0 < nops(realroot(q - e*t))
    do e := 1/2*e
    end do;
    e := 1/2*e;
    r := q - e*t;
    ok := false;
    k := prec;
    while not ok do
        k := k + 1;
        eigs, soslist, eigs2, soslist2, obj_plus_r0 := sossdp(r, x, k);
        sumsos :=
            obj_plus_r0 + sum(eigs[j]*soslist[j]^2, j = 1 .. nops(soslist))
            ;
        u := r - sumsos;
        v := expand(e*t + u + obj_plus_r0);
        ok := true;
        for i from 0 to m do
            cnd := coeff(v, x, 2*i) - 1/4*abs(coeff(v, x, 2*i + 1))
                 - abs(coeff(v, x, 2*i - 1));
            if not (0 <= cnd) then
                printf("prec = %d\t idx = %d\t err = %8.3e\t", k, i,
                    evalf(cnd));
                lprint(cnd);
                ok := true;
                error "not enough precision";
                break
            end if
        end do
    end do;
    sqs := [op(soslist)];
    cfs := [op(eigs)];
    for i from 0 to m do
        sqs := [op(sqs), x^i];
        cfs := [op(cfs), coeff(v, x, 2*i) - 1/4*abs(coeff(v, x, 2*i + 1))
             - abs(coeff(v, x, 2*i - 1))]
    end do;
    for i from 0 to m - 1 do
        sqs := [op(sqs), x^i*(x + 1/2*sign(coeff(v, x, 2*i + 1)))];
        cfs := [op(cfs), abs(coeff(v, x, 2*i + 1))]
    end do;
    sos := [];
    for i to nops(sqs) do sos := [op(sos), maxq*cfs[i], s*sqs[i]] end do;
    return sos
end proc

Warning, (in UnivariateSumOfSquaresDecItv3) `i` is implicitly declared local
|univsos/univsos3.mm:111|
Warning, (in UnivariateSumOfSquaresDecItv3) `c` is implicitly declared local
|univsos/univsos3.mm:120|
Warning, (in UnivariateSumOfSquaresDecItv3) `si` is implicitly declared local
|univsos/univsos3.mm:123|
Warning, (in UnivariateSumOfSquaresDecItv3) `r` is implicitly declared local
|univsos/univsos3.mm:128|
Warning, (in UnivariateSumOfSquaresDecItv3) `j` is implicitly declared local
|univsos/univsos3.mm:128|
Warning, (in UnivariateSumOfSquaresDecItv3) `t` is implicitly declared local
|univsos/univsos3.mm:129|
UnivariateSumOfSquaresDecItv3 := proc(f, a, b, k::integer := 1)
local psatz, bitsos, n, cf, q, sosq, clist, soslist, rlist, tlist, nc, l,
sosf1, sosf2, sosdecomp, ti, tcmp, sos, i, c, si, r, j, t;
    psatz := false;
    n := degree(f);
    if n = 0 and f < 0 then
        error "There is no decomposition into sum of squares for this po\
            lynomial"
    end if;
    if b < a then
        error cat("The interval [", convert(a, string), ", ",
            convert(b, string), "] is not valid")
    end if;
    q := add(coeff(f, x, i)*(y^2 + 1)^(n - i)*(a + b*y^2)^i, i = 0 .. n);
    ti := time[real]();
    sosq := univsos3(q, y, 2, k);
    tcmp := time[real]() - ti;
    printf("%fms\n", 1000*tcmp);
    if psatz = true then
        sos := HornerToList(sosq);
        clist := [seq(c[1]/(b - a)^n, c in sos)];
        soslist := [seq(c[2], c in sos)];
        rlist := [seq(
            add(coeff(si, y, 2*i)*y^i, i = 0 .. ceil(degree(1/2*si))),
            si in soslist)];
        tlist := [seq(
            add(coeff(si, y, 2*i + 1)*y^i, i = 0 .. ceil(degree(1/2*si))),
            si in soslist)];
        nc := floor(1/2*n);
        l := nops(clist);
        sosf1 := [seq(add(coeff(r, y, j)*(x - a)^j*(b - x)^(nc - j),
            j = 0 .. degree(r)), r in rlist)];
        if n mod 2 = 0 then
            sosf2 := [seq(add(
                coeff(t, y, j)*(x - a)^j*(b - x)^(nc - 1 - j),
                j = 0 .. degree(t)), t in tlist)]
        else
            sosf2 := [seq(add(coeff(t, y, j)*(x - a)^j*(b - x)^(nc - j),
                j = 0 .. degree(t)), t in tlist)]
        end if;
        return clist, sosf1, sosf2
    end if;
    return q, sosq
end proc

sossdp := proc(r, x, precSVD::integer := 10, precSDP::integer := 200,
epsStar::integer := 3, epsDash::integer := 3, a::rational := 0,
b::rational := 1, itv::boolean := false)
local fd, n, nsdp, nblock, nloc, i, j, Y, Y2, v, e, mons, rfloat, eigs,
eivs, eigs2, eivs2, gmp, normeig, gpround, SVD, af, bf, lowerbnd;
    n := degree(r);
    nsdp := 1 + ceil(1/2*n);
    if itv then nblock := 2 else nblock := 1 end if;
    fd := fopen("univsos/in.dat-s", WRITE, TEXT);
    writeline(fd, convert(2*ceil(1/2*n), string));
    writeline(fd, convert(nblock, string));
    if not itv then writeline(fd, convert(nsdp, string))
    else nloc := ceil(1/2*n); fprintf(fd, "%d %d\n", nsdp, nloc)
    end if;
    rfloat := convert(r, float, 100);
    af := convert(a, float);
    bf := convert(b, float);
    for i to 2*ceil(1/2*n) do fprintf(fd, "%.100f ", coeff(rfloat, x, i))
    end do;
    fprintf(fd, "\n");
    writeline(fd, "0 1 1 1 -1");
    for j from 2 to nsdp do fprintf(fd, "%d 1 %d %d 1\n", j - 1, 1, j)
    end do;
    for i from 2 to nsdp do
        for j from i to nsdp do
            fprintf(fd, "%d 1 %d %d 1\n", i + j - 2, i, j)
        end do
    end do;
    if itv then
        for i to nloc do
            for j from i to nloc do
                fprintf(fd, "%d 2 %d %d %f\n", i + j - 2, i, j,
                    -sign(i + j - 3)*bf*af);
                fprintf(fd, "%d 2 %d %d %f\n", i + j - 1, i, j,
                    sign(i + j - 2)*(bf + af));
                fprintf(fd, "%d 2 %d %d %f\n", i + j, i, j,
                    -sign(i + j - 1))
            end do
        end do
    end if;
    fclose(fd);
    if FileTools:-Exists("univsos/out.dat-s") then
        FileTools:-Remove("univsos/out.dat-s")
    end if;
    if FileTools:-Exists("univsos/out.mm") then
        FileTools:-Remove("univsos/out.mm")
    end if;
    gmp := true;
    if not gmp then
        system("sdpa -ds univsos/in.dat-s -o univsos/out.dat-s -p univso\
            s/param.sdpa > /dev/null")
    else
        write_param(precSDP, epsStar, epsDash);
        system("sdpa_gmp -ds univsos/in.dat-s -o univsos/out.dat-s -p un\
            ivsos/param_gmp.sdpa > /dev/null")
    end if;
    system("echo $(grep objValPrimal univsos/out.dat-s) ';' 'yMat:=' $(s\
        ed -n '/yMat/,/main/{//!p}' univsos/out.dat-s) ';' >> univsos/ou\
        t.mm");
    system("sed -i 's/ =/ :=/g' univsos/out.mm");
    system("sed -i 's/{/[/g' univsos/out.mm");
    system("sed -i 's/}/]/g' univsos/out.mm");
    system("sed -i 's/] \\[/], \\[/g' univsos/out.mm");
    read "univsos/out.mm";
    lowerbnd := coeff(r, x, 0) + convert(objValPrimal, rational, exact);
    SVD := true;
    Y := Matrix(yMat[1]);
    eigs, eivs := eigseivs_(Y, x, nsdp, precSVD, SVD);
    if itv then
        Y2 := Matrix(yMat[2]);
        eigs2, eivs2 := eigseivs_(Y2, x, nloc, precSVD, SVD)
    else eigs2 := Vector(1, 0); eivs2 := Vector(1, 0)
    end if;
    return convert(eigs, list), convert(eivs, list), convert(eigs2, list),
        convert(eivs2, list), lowerbnd
end proc

checkrational_ := proc(U)
local v;
    for v in U do
        if not type(convert(v, rational), realcons) then
            lprint(v);
            error "Non Rational Cholesky factor, retry with gmp = true"
        end if
    end do;
    return
end proc

eigseivs_ := proc(Y, x, nmat, precSVD, SVD)
local ti, tf, v, e, mons, eigs, eivs, gpround, normeig, U, S, V, Ysvd,
Yexact, tcmp;
    mons := Vector(nmat, j -> x^(j - 1));
    normeig := false;
    gpround := false;
    Yexact := convert(Y, rational, exact);
    if not SVD then
        ti := time[real]();
        lprint("starting Cholesky");
        U := LUDecomposition(Yexact, method = 'Cholesky');
        checkrational_(U);
        tcmp := time[real]() - ti;
        lprint(tcmp);
        lprint("ending Cholesky");
        S := IdentityMatrix(nmat)
    else
        Digits := precSVD;
        ti := time[real]();
        U, S, V := MTM[svd](Yexact);
        tcmp := time[real]() - ti;
        lprint(tcmp);
        Digits := 10
    end if;
    eigs := Diagonal(S);
    eivs := Transpose((Transpose(mons)) . U);
    return eigs, eivs
end proc

write_param := proc(precSDP, epsStar, epsDash)
local fd;
    fd := fopen("univsos/my_param_gmp.sdpa", WRITE, TEXT);
    fprintf(fd, "300\tunsigned int maxIteration;\n");
    fprintf(fd, "1.0E-%d\tdouble 0.0 < epsilonStar;\n", epsStar);
    fprintf(fd, "1.0E5   double 0.0 < lambdaStar;\n");
    fprintf(fd, "2.0   \tdouble 1.0 < omegaStar;\n");
    fprintf(fd, "-1.0E5  double lowerBound;\n");
    fprintf(fd, "1.0E5   double upperBound;\n");
    fprintf(fd, "0.1     double 0.0 <= betaStar <  1.0;\n");
    fprintf(fd,
        "0.3     double 0.0 <= betaBar  <  1.0, betaStar <= betaBar;\n");
    fprintf(fd, "0.9     double 0.0 < gammaStar  <  1.0;\n");
    fprintf(fd, "1.0E-%d\tdouble 0.0 < epsilonDash;\n", epsDash);
    fprintf(fd, "%d     precision\n", precSDP);
    fclose(fd)
end proc

      printpol := proc(p) lprint(sort(evalf(expand(p)), x, plex)) end proc

Warning, (in sositv3) `se` is implicitly declared local
|univsos/univsos3.mm:324|
Warning, (in sositv3) `so` is implicitly declared local
|univsos/univsos3.mm:325|
sositv3 := proc(f, a, b, prec::integer := 10, precSVD::integer := 10,
precSDP::integer := 200, epsStar::integer := 3, epsDash::integer := 3)
local bitsos, n, cf, q, sosq, clist, soslist, soslist2, rlist, tlist, nc, l,
sosf1, sosf2, sosdecomp, ti, tcmp, sos, sos2, h, S, c, SEVEN, SODD, s, ds,
dq, p1, p2, m, t, e, r, k, ok, eigs, eigs2, sumsos, sumsos2, u, v, i, sqs,
cfs, id, cnd, maxp1, obj_plus_r0, x, se, so;
    x := op(indets(p));
    n := degree(f);
    id := 2;
    if n = 0 and f < 0 then
        error "There is no decomposition into sum of squares for this po\
            lynomial"
    end if;
    if b < a then
        error cat("The interval [", convert(a, string), ", ",
            convert(b, string), "] is not valid")
    end if;
    h := add(coeff(f, x, i)*(y^2 + 1)^(n - i)*(a + b*y^2)^i, i = 0 .. n);
    S := sqrfree(h);
    c := lcoeff(f);
    SEVEN :=
        map(_e -> if type(_e[2], even) then _e[1]^(1/2*_e[2]) end if, S[2])
        ;
    SEVEN := [op(SEVEN), op(map(
        _e -> if type(_e[2], odd) then _e[1]^(1/2*_e[2] - 1/2) end if, S[2]))
        ];
    SEVEN := remove(member, SEVEN, [1]);
    SODD := map(_e -> if type(_e[2], odd) then _e[1] end if, S[2]);
    s := mul(se, se in SEVEN);
    q := S[1]*mul(so, so in SODD);
    ds := degree(s, y);
    dq := 1/2*degree(q, y);
    p1 := add(coeff(q, y, 2*i)*(b - x)^(dq - i)*(x - a)^i, i = 0 .. dq)/
        (b - a)^dq;
    p2 := add(coeff(s, y, 2*i)*(b - x)^(ds - i)*(x - a)^i, i = 0 .. ds)/
        (b - a)^ds;
    p1 := expand(p1);
    maxp1 := 1;
    p1 := p1/maxp1;
    n := degree(p1, x);
    m := ceil(1/2*n);
    if n = 0 then lprint(p1, " * (", p2, ")^2") end if;
    t := p1;
    if id = 3 then t := sum(abs(coeff(p1, x, i))*x^i, i = 0 .. n)
    else
        if id = 2 then t := sum(x^(2*i), i = 0 .. m)
        else if id = 1 then t := sum(x^j, j = 0 .. n) end if
        end if
    end if;
    e := 1/2^prec;
    r := p1 - e*t;
    k := prec;
    ok := false;
    while not ok do
        eigs, soslist, eigs2, soslist2, obj_plus_r0 :=
            sossdp(r, x, precSVD, precSDP, epsStar, epsDash, a, b, true);
        sumsos :=
            obj_plus_r0 + sum(eigs[j]*soslist[j]^2, j = 1 .. nops(soslist))
            ;
        sumsos2 := (b - x)*(x - a)*
            sum(eigs2[j]*soslist2[j]^2, j = 1 .. nops(soslist2));
        u := r - sumsos - sumsos2;
        v := expand(e*t + u + obj_plus_r0);
        ok := true;
        for i from 0 to m do
            cnd := coeff(v, x, 2*i) - 1/4*abs(coeff(v, x, 2*i + 1))
                 - abs(coeff(v, x, 2*i - 1));
            if not (0 <= cnd) then
                printf("prec = %d\t idx = %d\t err = %8.3e\t", k, i,
                    evalf(cnd));
                ok := true;
                error "not enough precision";
                break
            end if
        end do;
        break
    end do;
    sqs := [op(soslist)];
    cfs := [op(eigs)];
    for i from 0 to m do
        sqs := [op(sqs), x^i];
        cfs := [op(cfs), coeff(v, x, 2*i) - 1/4*abs(coeff(v, x, 2*i + 1))
             - abs(coeff(v, x, 2*i - 1))]
    end do;
    for i from 0 to m - 1 do
        sqs := [op(sqs), x^i*(x + 1/2*sign(coeff(v, x, 2*i + 1)))];
        cfs := [op(cfs), abs(coeff(v, x, 2*i + 1))]
    end do;
    sos := [];
    sos2 := [];
    for i to nops(sqs) do sos := [op(sos), maxp1*cfs[i], p2*sqs[i]] end do;
    for i to nops(eigs2) do
        sos2 := [op(sos2), maxp1*eigs2[i], p2*soslist2[i]]
    end do;
    return sos, sos2
end proc

          "/Users/typesarespaces/Documents/GithubProjects/RealCertify"

                               stack_level := -1

getSOSPoly := proc(poly, x)
local fd, _log_time_0, s, i, sos;
    stack_level := stack_level + 1;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    _log_time_0 := time();
    FileTools:-Text:-WriteString(fd, cat("Start: ", "getSOSPoly", " ",
        convert(stack_level, string), "\n"));
    FileTools:-Text:-Close(fd);
    sos := univsos1(poly, x);
    s := 0;
    for i to 1/2*nops(sos) do s := s + sos[2*i - 1]*sos[2*i]^2 end do;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    FileTools:-Text:-WriteString(fd, cat("End: ", "getSOSPoly", " ",
        convert(stack_level, string), "\nTime: ",
        convert(time() - _log_time_0, string), "\n"));
    FileTools:-Text:-Close(fd);
    stack_level := stack_level - 1;
    return s
end proc

Ord := proc(f, t, point)
local fd, _log_time_0, g, T;
    stack_level := stack_level + 1;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    _log_time_0 := time();
    FileTools:-Text:-WriteString(fd,
        cat("Start: ", "Ord", " ", convert(stack_level, string), "\n"));
    FileTools:-Text:-Close(fd);
    g := subs(t = T + point, f);
    fd := FileTools:-Text:-Open("log_time.txt", append);
    FileTools:-Text:-WriteString(fd, cat("End: ", "Ord", " ",
        convert(stack_level, string), "\nTime: ",
        convert(time() - _log_time_0, string), "\n"));
    FileTools:-Text:-Close(fd);
    stack_level := stack_level - 1;
    return ldegree(expand(g), T)
end proc

Eps := proc(f, t, point)
local fd, _log_time_0, g;
    stack_level := stack_level + 1;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    _log_time_0 := time();
    FileTools:-Text:-WriteString(fd,
        cat("Start: ", "Eps", " ", convert(stack_level, string), "\n"));
    FileTools:-Text:-Close(fd);
    g := subs(t = y + point, f);
    fd := FileTools:-Text:-Open("log_time.txt", append);
    FileTools:-Text:-WriteString(fd, cat("End: ", "Eps", " ",
        convert(stack_level, string), "\nTime: ",
        convert(time() - _log_time_0, string), "\n"));
    FileTools:-Text:-Close(fd);
    stack_level := stack_level - 1;
    return tcoeff(expand(g), y)
end proc

Type_of_poly := proc(p, t, point)
local fd, _log_time_0, O, E, output;
    stack_level := stack_level + 1;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    _log_time_0 := time();
    FileTools:-Text:-WriteString(fd, cat("Start: ", "Type_of_poly", " ",
        convert(stack_level, string), "\n"));
    FileTools:-Text:-Close(fd);
    O := Ord(p, t, point);
    E := Eps(p, t, point);
    if type(O, even) and 0 < E then output := 0
    elif type(O, even) and E < 0 then output := 1
    elif type(O, odd) and 0 < E then output := 2
    elif type(O, odd) and E < 0 then output := 3
    end if;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    FileTools:-Text:-WriteString(fd, cat("End: ", "Type_of_poly", " ",
        convert(stack_level, string), "\nTime: ",
        convert(time() - _log_time_0, string), "\n"));
    FileTools:-Text:-Close(fd);
    stack_level := stack_level - 1;
    return output
end proc

Type_of_P := proc(G, t, point)
local fd, _log_time_0, O_1, O_2, E_1, E_2;
    stack_level := stack_level + 1;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    _log_time_0 := time();
    FileTools:-Text:-WriteString(fd, cat("Start: ", "Type_of_P", " ",
        convert(stack_level, string), "\n"));
    FileTools:-Text:-Close(fd);
    O_1 := Ord(G[1], t, point);
    O_2 := Ord(G[2], t, point);
    E_1 := Eps(G[1], t, point);
    E_2 := Eps(G[2], t, point);
    if type(O_1, even) and E_1 < 0 then
        if O_1 <= O_2 or Type_of_poly(G[2], t, point) = 0 then
            fd := FileTools:-Text:-Open("log_time.txt", append);
            FileTools:-Text:-WriteString(fd, cat("End: ", "Type_of_P", " ",
                convert(stack_level, string), "\nTime: ",
                convert(time() - _log_time_0, string), "\n"));
            FileTools:-Text:-Close(fd);
            stack_level := stack_level - 1;
            return 1
        elif O_2 < O_1 and Type_of_poly(G[2], t, point) <> 0 then
            if E_2 < 0 then
                fd := FileTools:-Text:-Open("log_time.txt", append);
                FileTools:-Text:-WriteString(fd, cat("End: ", "Type_of_P",
                    " ", convert(stack_level, string), "\nTime: ",
                    convert(time() - _log_time_0, string), "\n"));
                FileTools:-Text:-Close(fd);
                stack_level := stack_level - 1;
                return 2
            elif 0 < E_2 then
                fd := FileTools:-Text:-Open("log_time.txt", append);
                FileTools:-Text:-WriteString(fd, cat("End: ", "Type_of_P",
                    " ", convert(stack_level, string), "\nTime: ",
                    convert(time() - _log_time_0, string), "\n"));
                FileTools:-Text:-Close(fd);
                stack_level := stack_level - 1;
                return 3
            end if
        end if
    elif type(O_2, even) and E_2 < 0 then
        if O_2 <= O_1 or Type_of_poly(G[1], t, point) = 0 then
            fd := FileTools:-Text:-Open("log_time.txt", append);
            FileTools:-Text:-WriteString(fd, cat("End: ", "Type_of_P", " ",
                convert(stack_level, string), "\nTime: ",
                convert(time() - _log_time_0, string), "\n"));
            FileTools:-Text:-Close(fd);
            stack_level := stack_level - 1;
            return 1
        elif O_1 < O_2 and Type_of_poly(G[1], t, point) <> 0 then
            if E_1 < 0 then
                fd := FileTools:-Text:-Open("log_time.txt", append);
                FileTools:-Text:-WriteString(fd, cat("End: ", "Type_of_P",
                    " ", convert(stack_level, string), "\nTime: ",
                    convert(time() - _log_time_0, string), "\n"));
                FileTools:-Text:-Close(fd);
                stack_level := stack_level - 1;
                return 2
            elif 0 < E_1 then
                fd := FileTools:-Text:-Open("log_time.txt", append);
                FileTools:-Text:-WriteString(fd, cat("End: ", "Type_of_P",
                    " ", convert(stack_level, string), "\nTime: ",
                    convert(time() - _log_time_0, string), "\n"));
                FileTools:-Text:-Close(fd);
                stack_level := stack_level - 1;
                return 3
            end if
        end if
    elif E_1*E_2 < 0 and O_1*O_2 <> 0 then
        fd := FileTools:-Text:-Open("log_time.txt", append);
        FileTools:-Text:-WriteString(fd, cat("End: ", "Type_of_P", " ",
            convert(stack_level, string), "\nTime: ",
            convert(time() - _log_time_0, string), "\n"));
        FileTools:-Text:-Close(fd);
        stack_level := stack_level - 1;
        return 4
    elif O_1 = 0 then
        if 0 < E_2 then
            fd := FileTools:-Text:-Open("log_time.txt", append);
            FileTools:-Text:-WriteString(fd, cat("End: ", "Type_of_P", " ",
                convert(stack_level, string), "\nTime: ",
                convert(time() - _log_time_0, string), "\n"));
            FileTools:-Text:-Close(fd);
            stack_level := stack_level - 1;
            return 5
        elif E_2 < 0 then
            fd := FileTools:-Text:-Open("log_time.txt", append);
            FileTools:-Text:-WriteString(fd, cat("End: ", "Type_of_P", " ",
                convert(stack_level, string), "\nTime: ",
                convert(time() - _log_time_0, string), "\n"));
            FileTools:-Text:-Close(fd);
            stack_level := stack_level - 1;
            return 6
        end if
    elif O_2 = 0 then
        if 0 < E_1 then
            fd := FileTools:-Text:-Open("log_time.txt", append);
            FileTools:-Text:-WriteString(fd, cat("End: ", "Type_of_P", " ",
                convert(stack_level, string), "\nTime: ",
                convert(time() - _log_time_0, string), "\n"));
            FileTools:-Text:-Close(fd);
            stack_level := stack_level - 1;
            return 5
        elif E_1 < 0 then
            fd := FileTools:-Text:-Open("log_time.txt", append);
            FileTools:-Text:-WriteString(fd, cat("End: ", "Type_of_P", " ",
                convert(stack_level, string), "\nTime: ",
                convert(time() - _log_time_0, string), "\n"));
            FileTools:-Text:-Close(fd);
            stack_level := stack_level - 1;
            return 6
        end if
    elif 0 < E_1 then
        fd := FileTools:-Text:-Open("log_time.txt", append);
        FileTools:-Text:-WriteString(fd, cat("End: ", "Type_of_P", " ",
            convert(stack_level, string), "\nTime: ",
            convert(time() - _log_time_0, string), "\n"));
        FileTools:-Text:-Close(fd);
        stack_level := stack_level - 1;
        return 5
    elif E_1 < 0 then
        fd := FileTools:-Text:-Open("log_time.txt", append);
        FileTools:-Text:-WriteString(fd, cat("End: ", "Type_of_P", " ",
            convert(stack_level, string), "\nTime: ",
            convert(time() - _log_time_0, string), "\n"));
        FileTools:-Text:-Close(fd);
        stack_level := stack_level - 1;
        return 6
    end if
end proc

Type_of_Point := proc(G, f, t, point)
local fd, _log_time_0, T_1, T_2, output;
    stack_level := stack_level + 1;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    _log_time_0 := time();
    FileTools:-Text:-WriteString(fd, cat("Start: ", "Type_of_Point", " ",
        convert(stack_level, string), "\n"));
    FileTools:-Text:-Close(fd);
    T_1 := Type_of_poly(f, t, point);
    T_2 := Type_of_P(G, t, point);
    if T_1 = 1 and 1 <= T_2 and T_2 <= 3 then output := 1
    elif T_1 = 1 and T_2 = 4 then output := 2
    elif T_1 = 2 and 1 <= T_2 and T_2 <= 2 then output := 3
    elif T_1 = 2 and 3 <= T_2 and T_2 <= 5 then output := 4
    elif T_1 = 3 and (T_2 = 1 or T_2 = 3) then output := 5
    elif T_1 = 3 and (T_2 = 2 or T_2 = 4 or T_2 = 6) then output := 6
    end if;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    FileTools:-Text:-WriteString(fd, cat("End: ", "Type_of_Point", " ",
        convert(stack_level, string), "\nTime: ",
        convert(time() - _log_time_0, string), "\n"));
    FileTools:-Text:-Close(fd);
    stack_level := stack_level - 1;
    return output
end proc

Pre_poly := proc(g, f, t, S, point)
local fd, _log_time_0, h, i, d;
    stack_level := stack_level + 1;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    _log_time_0 := time();
    FileTools:-Text:-WriteString(fd,
        cat("Start: ", "Pre_poly", " ", convert(stack_level, string), "\n"))
        ;
    FileTools:-Text:-Close(fd);
    h := 1;
    for i in S do
        if i <> point then
            if Ord(g, t, i) <= Ord(f, t, i) then
                d := 2*floor(1/2*Ord(f, t, i) - 1/2*Ord(g, t, i)) + 2;
                h := (t - i)^d*h
            end if
        end if
    end do;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    FileTools:-Text:-WriteString(fd, cat("End: ", "Pre_poly", " ",
        convert(stack_level, string), "\nTime: ",
        convert(time() - _log_time_0, string), "\n"));
    FileTools:-Text:-Close(fd);
    stack_level := stack_level - 1;
    return h
end proc

Fixing_case_1 := proc(g, f, t, point)
local fd, _log_time_0, m, n, c_1, c_2, h, a;
    stack_level := stack_level + 1;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    _log_time_0 := time();
    FileTools:-Text:-WriteString(fd, cat("Start: ", "Fixing_case_1", " ",
        convert(stack_level, string), "\n"));
    FileTools:-Text:-Close(fd);
    m := Ord(f, t, point);
    n := Ord(g, t, point);
    c_1 := Eps(f, t, point);
    c_2 := Eps(g, t, point);
    a := (abs(c_1) + 1)/abs(c_2);
    h := a*(t - point)^(m - n);
    fd := FileTools:-Text:-Open("log_time.txt", append);
    FileTools:-Text:-WriteString(fd, cat("End: ", "Fixing_case_1", " ",
        convert(stack_level, string), "\nTime: ",
        convert(time() - _log_time_0, string), "\n"));
    FileTools:-Text:-Close(fd);
    stack_level := stack_level - 1;
    return h
end proc

Fixing_case_2 := proc(g_1, g_2, f, t, point)
local fd, _log_time_0, m, n_1, n_2, c_1, c_2, h_1, h_2, a, g, h;
    stack_level := stack_level + 1;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    _log_time_0 := time();
    FileTools:-Text:-WriteString(fd, cat("Start: ", "Fixing_case_2", " ",
        convert(stack_level, string), "\n"));
    FileTools:-Text:-Close(fd);
    m := Ord(f, t, point);
    h := 1;
    n_1 := Ord(g_1, t, point);
    n_2 := Ord(g_2, t, point);
    c_1 := Eps(g_1, t, point);
    c_2 := Eps(g_2, t, point);
    h_1 := (t - point)^(2*floor(1/2*m - 1/2*n_1))/abs(c_1);
    h_2 := (t - point)^(2*floor(1/2*m - 1/2*n_2))/abs(c_2);
    if 0 < c_1 then
        h_1 := 1/4*h_1*(t - point - 1)^2; h_2 := 1/4*h_2*(t - point + 1)^2
    elif c_1 < 0 then
        h_1 := 1/4*h_1*(t - point + 1)^2; h_2 := 1/4*h_2*(t - point - 1)^2
    end if;
    g := h_1*g_1 + h_2*g_2;
    h := Fixing_case_1(expand(g), f, t, point);
    fd := FileTools:-Text:-Open("log_time.txt", append);
    FileTools:-Text:-WriteString(fd, cat("End: ", "Fixing_case_2", " ",
        convert(stack_level, string), "\nTime: ",
        convert(time() - _log_time_0, string), "\n"));
    FileTools:-Text:-Close(fd);
    stack_level := stack_level - 1;
    return [h*h_1, h*h_2]
end proc

Fixing_case_3 := proc(g, f, t, point)
local fd, _log_time_0, m, n, c, h_1, g_1, h_2, h;
    stack_level := stack_level + 1;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    _log_time_0 := time();
    FileTools:-Text:-WriteString(fd, cat("Start: ", "Fixing_case_3", " ",
        convert(stack_level, string), "\n"));
    FileTools:-Text:-Close(fd);
    m := Ord(f, t, point);
    n := Ord(g, t, point);
    c := Eps(g, t, point);
    h_1 := 1/4*(t - point - 1)^2/abs(c);
    g_1 := h_1*g + 1/4*(t - point)^n*(t - point + 1)^2;
    h_2 := Fixing_case_4(g_1, f, t, point);
    h := h_1*h_2;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    FileTools:-Text:-WriteString(fd, cat("End: ", "Fixing_case_3", " ",
        convert(stack_level, string), "\nTime: ",
        convert(time() - _log_time_0, string), "\n"));
    FileTools:-Text:-Close(fd);
    stack_level := stack_level - 1;
    return h
end proc

Fixing_case_4 := proc(g, f, t, point)
local fd, _log_time_0, m, n, b_1, b_2, d, c_1, c_2, h;
    stack_level := stack_level + 1;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    _log_time_0 := time();
    FileTools:-Text:-WriteString(fd, cat("Start: ", "Fixing_case_4", " ",
        convert(stack_level, string), "\n"));
    FileTools:-Text:-Close(fd);
    m := Ord(f, t, point);
    n := Ord(g, t, point);
    c_1 := Eps(f, t, point);
    b_1 := Eps(g, t, point);
    c_2 := Eps(f - c_1*(t - point)^m, t, point);
    b_2 := Eps(g - b_1*(t - point)^n, t, point);
    if 0 < c_2/c_1 - b_2/b_1 then d := 0; h := c_1*(t - point)^(m - n)/b_1
    else
        d := 2/(c_2/c_1 - b_2/b_1 - 1);
        h := c_1*(t - point)^(m - n)*(x - point + d)^2/(b_1*d^2)
    end if;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    FileTools:-Text:-WriteString(fd, cat("End: ", "Fixing_case_4", " ",
        convert(stack_level, string), "\nTime: ",
        convert(time() - _log_time_0, string), "\n"));
    FileTools:-Text:-Close(fd);
    stack_level := stack_level - 1;
    return h
end proc

Fixing_case_5 := proc(g, f, t, point)
local fd, _log_time_0, m, n, c, h_1, g_1, h_2, h;
    stack_level := stack_level + 1;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    _log_time_0 := time();
    FileTools:-Text:-WriteString(fd, cat("Start: ", "Fixing_case_5", " ",
        convert(stack_level, string), "\n"));
    FileTools:-Text:-Close(fd);
    m := Ord(f, t, point);
    n := Ord(g, t, point);
    c := Eps(g, t, point);
    h_1 := 1/4*(t - point + 1)^2/abs(c);
    g_1 := h_1*g + 1/4*(t - point)^n*(t - point - 1)^2;
    h_2 := Fixing_case_6(g_1, f, t, point);
    h := h_1*h_2;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    FileTools:-Text:-WriteString(fd, cat("End: ", "Fixing_case_5", " ",
        convert(stack_level, string), "\nTime: ",
        convert(time() - _log_time_0, string), "\n"));
    FileTools:-Text:-Close(fd);
    stack_level := stack_level - 1;
    return h
end proc

Fixing_case_6 := proc(g, f, t, point)
local fd, _log_time_0, m, n, a, d, b_1, b_2, c_1, c_2, h;
    stack_level := stack_level + 1;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    _log_time_0 := time();
    FileTools:-Text:-WriteString(fd, cat("Start: ", "Fixing_case_6", " ",
        convert(stack_level, string), "\n"));
    FileTools:-Text:-Close(fd);
    m := Ord(f, t, point);
    n := Ord(g, t, point);
    c_1 := Eps(f, t, point);
    b_1 := Eps(g, t, point);
    c_2 := Eps(f - c_1*(t - point)^m, t, point);
    b_2 := Eps(g - b_1*(t - point)^n, t, point);
    if c_2/c_1 - b_2/b_1 < 0 then d := 0; h := c_1*(t - point)^(m - n)/b_1
    else
        d := 2/(c_2/c_1 - b_2/b_1 + 1);
        h := c_1*(t - point)^(m - n)*(x - point + d)^2/(b_1*d^2)
    end if;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    FileTools:-Text:-WriteString(fd, cat("End: ", "Fixing_case_6", " ",
        convert(stack_level, string), "\nTime: ",
        convert(time() - _log_time_0, string), "\n"));
    FileTools:-Text:-Close(fd);
    stack_level := stack_level - 1;
    return h
end proc

Fixing_points := proc(f, g_1, g_2, t)
local
fd, _log_time_0, fixing, S, interval, flag, point, H_1, H_2, h_1, h_2, h, g
;
    stack_level := stack_level + 1;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    _log_time_0 := time();
    FileTools:-Text:-WriteString(fd, cat("Start: ", "Fixing_points", " ",
        convert(stack_level, string), "\n"));
    FileTools:-Text:-Close(fd);
    S := map(proc(bound)
            interval := bound_info(t, bound, 0);
            ASSERT(evalb(interval[1] = interval[2]));
            return interval[1]
        end proc, SolveTools:-SemiAlgebraic([0 <= g_1, 0 <= g_2], [t]));
    H_1 := 0;
    H_2 := 0;
    for point in S do
        flag := Type_of_Point([g_1, g_2], f, t, point);
        if flag = 1 then
            if type(Ord(g_1, t, point), even) and Eps(g_1, t, point) < 0
             and Ord(g_1, t, point) <= Ord(g_2, t, point) then
                h := Pre_poly(g_1, f, t, S, point);
                H_1 := H_1 + h*Fixing_case_1(h*g_1, f, t, point)
            elif type(Ord(g_2, t, point), even) and Eps(g_2, t, point) < 0
             and Ord(g_2, t, point) <= Ord(g_1, t, point) then
                h := Pre_poly(g_2, f, t, S, point);
                H_2 := H_2 + h*Fixing_case_1(h*g_2, f, t, point)
            end if
        elif flag = 2 then
            h_1 := Pre_poly(g_1, f, t, S, point);
            h_2 := Pre_poly(g_2, f, t, S, point);
            fixing := Fixing_case_2(h_1*g_1, h_2*g_2, f, t, point);
            H_1 := H_1 + h_1*fixing[1];
            H_2 := H_2 + h_2*fixing[2]
        elif flag = 3 then
            if Type_of_poly(g_1, t, point) = 1 then
                g := g_1;
                h_1 := Pre_poly(g, f, t, S, point);
                H_1 := H_1 + h_1*Fixing_case_3(h_1*g, f, t, point)
            elif Type_of_poly(g_2, t, point) = 1 then
                g := g_2;
                h_2 := Pre_poly(g, f, t, S, point);
                H_2 := H_2 + h_2*Fixing_case_3(h_2*g, f, t, point)
            end if
        elif flag = 4 then
            if Type_of_poly(g_1, t, point) = 2 then
                g := g_1;
                h_1 := Pre_poly(g, f, t, S, point);
                H_1 := H_1 + h_1*Fixing_case_4(h_1*g_1, f, t, point)
            elif Type_of_poly(g_2, t, point) = 2 then
                g := g_2;
                h_2 := Pre_poly(g, f, t, S, point);
                H_2 := H_2 + h_2*Fixing_case_4(h_2*g, f, t, point)
            end if
        elif flag = 5 then
            if Type_of_poly(g_1, t, point) = 1 then
                g := g_1;
                h_1 := Pre_poly(g, f, t, S, point);
                H_1 := H_1 + h_1*Fixing_case_5(h_1*g_1, f, t, point)
            elif Type_of_poly(g_2, t, point) = 1 then
                g := g_2;
                h_2 := Pre_poly(g, f, t, S, point);
                H_2 := H_2 + h_2*Fixing_case_5(h_2*g, f, t, point)
            end if
        elif flag = 6 then
            if Type_of_poly(g_1, t, point) = 3 then
                g := g_1;
                h_1 := Pre_poly(g, f, t, S, point);
                H_1 := H_1 + h_1*Fixing_case_6(h_1*g_1, f, t, point)
            elif Type_of_poly(g_2, t, point) = 3 then
                g := g_2;
                h_2 := Pre_poly(g, f, t, S, point);
                H_2 := H_2 + h_2*Fixing_case_6(h_2*g, f, t, point)
            end if
        end if
    end do;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    FileTools:-Text:-WriteString(fd, cat("End: ", "Fixing_points", " ",
        convert(stack_level, string), "\nTime: ",
        convert(time() - _log_time_0, string), "\n"));
    FileTools:-Text:-Close(fd);
    stack_level := stack_level - 1;
    return [H_1, H_2]
end proc

bound_poly := proc(g_1, g_2, x)
local fd, _log_time_0, d, c, c_1, g, h1, h2;
    stack_level := stack_level + 1;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    _log_time_0 := time();
    FileTools:-Text:-WriteString(fd, cat("Start: ", "bound_poly", " ",
        convert(stack_level, string), "\n"));
    FileTools:-Text:-Close(fd);
    d := [degree(g_1, x), degree(g_2, x)];
    c := [coeff(g_1, x^d[1]), coeff(g_2, x^d[2])];
    c_1 := [
        if d[1] = 1 then subs(x = 0, g_1)/abs(c[1])
        else coeff(g_1/abs(c[1]), x^(d[1] - 1))
        end if,
        if d[2] = 1 then subs(x = 0, g_2)/abs(c[2])
        else coeff(g_2/abs(c[2]), x^(d[2] - 1))
        end if];
    if type(d[1], even) and c[1] < 0 then
        fd := FileTools:-Text:-Open("log_time.txt", append);
        FileTools:-Text:-WriteString(fd, cat("End: ", "bound_poly", " ",
            convert(stack_level, string), "\nTime: ",
            convert(time() - _log_time_0, string), "\n"));
        FileTools:-Text:-Close(fd);
        stack_level := stack_level - 1;
        return [g_1, 1, 0]
    elif type(d[2], even) and c[2] < 0 then
        fd := FileTools:-Text:-Open("log_time.txt", append);
        FileTools:-Text:-WriteString(fd, cat("End: ", "bound_poly", " ",
            convert(stack_level, string), "\nTime: ",
            convert(time() - _log_time_0, string), "\n"));
        FileTools:-Text:-Close(fd);
        stack_level := stack_level - 1;
        return [g_2, 0, 1]
    else
        if d[1] = d[2] then
            h1 := x^2/abs(c[1]);
            h2 :=
                (x + sign(c[1])*(1/2*c_1[1] + 1/2*c_1[2] + 1))^2/abs(c[2]);
            g := h1*g_1 + h2*g_2
        elif d[2] < d[1] then
            h1 := 1/abs(c[1]);
            h2 := x^(d[1] - d[2] - 2)*
                (x + sign(c[1])*(1/2*c_1[1] + 1/2*c_1[2] + 1))^2/abs(c[2])
        else
            h1 := x^(d[2] - d[1] - 2)*
                (x - sign(c[1])*(1/2*c_1[1] + 1/2*c_1[2] + 1))^2/abs(c[1]);
            h2 := 1/abs(c[2])
        end if
    end if;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    FileTools:-Text:-WriteString(fd, cat("End: ", "bound_poly", " ",
        convert(stack_level, string), "\nTime: ",
        convert(time() - _log_time_0, string), "\n"));
    FileTools:-Text:-Close(fd);
    stack_level := stack_level - 1;
    return [expand(h1*g_1 + h2*g_2), h1, h2]
end proc

dot_product := proc(v1, v2)
local fd, _log_time_0, out, i;
    stack_level := stack_level + 1;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    _log_time_0 := time();
    FileTools:-Text:-WriteString(fd, cat("Start: ", "dot_product", " ",
        convert(stack_level, string), "\n"));
    FileTools:-Text:-Close(fd);
    out := 0;
    for i to min(nops(v1), nops(v2)) do out := out + v1[i]*v2[i] end do;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    FileTools:-Text:-WriteString(fd, cat("End: ", "dot_product", " ",
        convert(stack_level, string), "\nTime: ",
        convert(time() - _log_time_0, string), "\n"));
    FileTools:-Text:-Close(fd);
    stack_level := stack_level - 1;
    return out
end proc

bound_info := proc(x, bound, eps)
local fd, _log_time_0, i1, i2, j1, j2;
    stack_level := stack_level + 1;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    _log_time_0 := time();
    FileTools:-Text:-WriteString(fd, cat("Start: ", "bound_info", " ",
        convert(stack_level, string), "\n"));
    FileTools:-Text:-Close(fd);
    if nops(bound) = 2 then
        i1 := simplify(op(bound[1])[1]);
        i2 := simplify(op(bound[1])[2]);
        j1 := simplify(op(bound[2])[1]);
        j2 := simplify(op(bound[2])[2]);
        if evalb(i1 = x) then
            if evalb(j1 = x) then
                fd := FileTools:-Text:-Open("log_time.txt", append);
                FileTools:-Text:-WriteString(fd, cat("End: ", "bound_info",
                    " ", convert(stack_level, string), "\nTime: ",
                    convert(time() - _log_time_0, string), "\n"));
                FileTools:-Text:-Close(fd);
                stack_level := stack_level - 1;
                return [min(i2, j2) + eps, max(i2, j2) - eps]
            else
                fd := FileTools:-Text:-Open("log_time.txt", append);
                FileTools:-Text:-WriteString(fd, cat("End: ", "bound_info",
                    " ", convert(stack_level, string), "\nTime: ",
                    convert(time() - _log_time_0, string), "\n"));
                FileTools:-Text:-Close(fd);
                stack_level := stack_level - 1;
                return [min(i2, j1) + eps, max(i2, j1) - eps]
            end if
        else
            if evalb(j1 = x) then
                fd := FileTools:-Text:-Open("log_time.txt", append);
                FileTools:-Text:-WriteString(fd, cat("End: ", "bound_info",
                    " ", convert(stack_level, string), "\nTime: ",
                    convert(time() - _log_time_0, string), "\n"));
                FileTools:-Text:-Close(fd);
                stack_level := stack_level - 1;
                return [min(i1, j2) + eps, max(i1, j2) - eps]
            else
                fd := FileTools:-Text:-Open("log_time.txt", append);
                FileTools:-Text:-WriteString(fd, cat("End: ", "bound_info",
                    " ", convert(stack_level, string), "\nTime: ",
                    convert(time() - _log_time_0, string), "\n"));
                FileTools:-Text:-Close(fd);
                stack_level := stack_level - 1;
                return [min(i1, j1) + eps, max(i1, j1) - eps]
            end if
        end if
    else
        i1 := simplify(op(bound[1])[1]);
        j1 := simplify(op(bound[1])[2]);
        if type(bound[1], `=`) then
            if evalb(i1 = x) then
                fd := FileTools:-Text:-Open("log_time.txt", append);
                FileTools:-Text:-WriteString(fd, cat("End: ", "bound_info",
                    " ", convert(stack_level, string), "\nTime: ",
                    convert(time() - _log_time_0, string), "\n"));
                FileTools:-Text:-Close(fd);
                stack_level := stack_level - 1;
                return [j1, j1]
            else
                fd := FileTools:-Text:-Open("log_time.txt", append);
                FileTools:-Text:-WriteString(fd, cat("End: ", "bound_info",
                    " ", convert(stack_level, string), "\nTime: ",
                    convert(time() - _log_time_0, string), "\n"));
                FileTools:-Text:-Close(fd);
                stack_level := stack_level - 1;
                return [i1, i1]
            end if
        end if;
        if type(bound[1], `<=`) then
            if evalb(i1 = x) then
                fd := FileTools:-Text:-Open("log_time.txt", append);
                FileTools:-Text:-WriteString(fd, cat("End: ", "bound_info",
                    " ", convert(stack_level, string), "\nTime: ",
                    convert(time() - _log_time_0, string), "\n"));
                FileTools:-Text:-Close(fd);
                stack_level := stack_level - 1;
                return [-infinity, j1 - eps]
            else
                fd := FileTools:-Text:-Open("log_time.txt", append);
                FileTools:-Text:-WriteString(fd, cat("End: ", "bound_info",
                    " ", convert(stack_level, string), "\nTime: ",
                    convert(time() - _log_time_0, string), "\n"));
                FileTools:-Text:-Close(fd);
                stack_level := stack_level - 1;
                return [i1 + eps, infinity]
            end if
        end if
    end if
end proc

averkov_lemma_7 := proc(x, f, basis, B_poly)
local fd, _log_time_0, _gamma, interval, lowerbound, upperbound, eps,
tobe_disjoint_set, N, g, term, semialgebraic_of_B, R, M, mu, m, N_list,
temp_bound_N, pos_coeff, _pos_coeff, T, semialgebraic_for_mu, N_top,
N_bottom, N_old, N_curr;
    stack_level := stack_level + 1;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    _log_time_0 := time();
    FileTools:-Text:-WriteString(fd, cat("Start: ", "averkov_lemma_7", " ",
        convert(stack_level, string), "\n"));
    FileTools:-Text:-Close(fd);
    R := RegularChains:-PolynomialRing([x]);
    semialgebraic_of_B := SolveTools:-SemiAlgebraic([0 <= B_poly], [x]);
    _gamma := 1/2*max(map(proc(g_i)
            map(proc(bound)
                    interval := bound_info(x, bound, 0);
                    lowerbound := convert(evalf(interval[1]), rational);
                    upperbound := convert(evalf(interval[2]), rational);
                    simplify(maximize(g_i, x = lowerbound .. upperbound))
                end proc, semialgebraic_of_B)
        end proc, basis));
    _gamma := ceil(evalf(_gamma));
    T := SolveTools:-SemiAlgebraic([0 <= B_poly, f < 0], [x]);
    eps := -1/2*min(map(proc(g_i)
            map(proc(bound)
                    interval := bound_info(x, bound, 0);
                    lowerbound := convert(evalf(interval[1]), rational);
                    upperbound := convert(evalf(interval[2]), rational);
                    simplify(maximize(g_i, x = lowerbound .. upperbound))
                end proc, T)
        end proc, basis));
    if eps = -infinity then eps := 1 end if;
    semialgebraic_for_mu := SolveTools:-SemiAlgebraic(
        [0 <= B_poly, op(map(g_i -> 0 <= g_i + 2*eps, basis))], [x]);
    mu := min(map(proc(bound)
            interval := bound_info(x, bound, 0);
            lowerbound := convert(evalf(interval[1]), rational);
            upperbound := convert(evalf(interval[2]), rational);
            simplify(minimize(f, x = lowerbound .. upperbound))
        end proc, semialgebraic_for_mu));
    mu := convert(evalf(mu), rational);
    M := -min(map(proc(bound)
            interval := bound_info(x, bound, 0);
            lowerbound := convert(evalf(interval[1]), rational);
            upperbound := convert(evalf(interval[2]), rational);
            simplify(minimize(f, x = lowerbound .. upperbound))
        end proc, semialgebraic_of_B));
    m := numelems(basis);
    N_list := [-infinity, 1];
    temp_bound_N :=
        ceil((log(mu) - log(2*m*_gamma))/(log(_gamma) - log(_gamma + eps)))
        ;
    if type(temp_bound_N, realcons) then
        if evalb(0 < 2*m*_gamma/mu) then
            _pos_coeff := 2*m*_gamma/mu; mu := _pos_coeff*mu
        end if;
        temp_bound_N := ceil(
            (log(mu) - log(2*m*_gamma))/(log(_gamma) - log(_gamma + eps)));
        N_list := N_list, [temp_bound_N, _pos_coeff]
    end if;
    temp_bound_N := ceil(
        (log(M) - log(2*eps))/(log(_gamma + 2*eps) - log(_gamma + eps)));
    if type(temp_bound_N, realcons) then
        if evalb(0 < evalf(2*eps/M)) then
            _pos_coeff := 2*eps/M; M := _pos_coeff*M
        end if;
        temp_bound_N := ceil(
            (log(M) - log(2*eps))/(log(_gamma + 2*eps) - log(_gamma + eps)))
            ;
        N_list := N_list, [temp_bound_N, _pos_coeff]
    end if;
    temp_bound_N :=
        ceil((log(M) - log(2*m*_gamma))/(log(_gamma) - log(_gamma + eps)));
    if type(temp_bound_N, realcons) then
        if evalb(0 < m*_gamma/M) then
            _pos_coeff := m*_gamma/M; M := _pos_coeff*M
        end if;
        temp_bound_N := ceil(
            (log(M) - log(2*m*_gamma))/(log(_gamma) - log(_gamma + eps)));
        N_list := N_list, [temp_bound_N, _pos_coeff]
    end if;
    N, pos_coeff :=
        op(foldl((x, y) -> if y[1] < x[1] then x else y end if, N_list));
    N := ceil(1/2*N);
    g := add(term, term in map(
        g_i -> g_i*((g_i - _gamma)/(_gamma + eps))^(2*N)/pos_coeff, basis))
        ;
    N_top := N;
    N_bottom := 0;
    N_old := N_top;
    do
        N_curr := iquo(N_top + N_bottom, 2);
        g := add(term, term in map(
            g_i -> g_i*((g_i - _gamma)/(_gamma + eps))^(2*N_curr)/pos_coeff
            , basis));
        if SolveTools:-SemiAlgebraic([0 <= B_poly, 0 <= g - f], [x]) = []
        then N_top := N_curr
        else N_bottom := N_curr
        end if;
        break if N_curr = N_old;
        N_old := N_curr
    end do;
    if N_top = 0 and RegularChains:-SemiAlgebraicSetTools:-IsEmpty([],
    [B_poly, -f], [], [], R) then N := -1
    else N := N_top
    end if;
    if N = -1 then
        fd := FileTools:-Text:-Open("log_time.txt", append);
        FileTools:-Text:-WriteString(fd, cat("End: ", "averkov_lemma_7",
            " ", convert(stack_level, string), "\nTime: ",
            convert(time() - _log_time_0, string), "\n"));
        FileTools:-Text:-Close(fd);
        stack_level := stack_level - 1;
        return map(g_i -> 0, basis)
    else
        fd := FileTools:-Text:-Open("log_time.txt", append);
        FileTools:-Text:-WriteString(fd, cat("End: ", "averkov_lemma_7",
            " ", convert(stack_level, string), "\nTime: ",
            convert(time() - _log_time_0, string), "\n"));
        FileTools:-Text:-Close(fd);
        stack_level := stack_level - 1;
        return map(g_i -> ((g_i - _gamma)/(_gamma + eps))^(2*N)/pos_coeff,
            basis)
    end if
end proc

Lower_bound_poly := proc(x, poly, g)
local fd, _log_time_0, i, d_poly, c_poly, d_g, h, S, _point, G, C, eps,
_log_time_1, _log_time_2, opt_roots, _log_time_3;
    stack_level := stack_level + 1;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    _log_time_0 := time();
    FileTools:-Text:-WriteString(fd, cat("Start: ", "Lower_bound_poly", " ",
        convert(stack_level, string), "\n"));
    FileTools:-Text:-Close(fd);
    eps := 1/1000;
    stack_level := stack_level + 1;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    _log_time_1 := time();
    FileTools:-Text:-WriteString(fd, cat("Start: ",
        "Lower_bound_poly::expand(poly)", " ", convert(stack_level, string),
        "\n"));
    FileTools:-Text:-Close(fd);
    d_poly := degree(expand(poly), x);
    c_poly := coeff(poly, x^d_poly);
    fd := FileTools:-Text:-Open("log_time.txt", append);
    FileTools:-Text:-WriteString(fd, cat("End: ",
        "Lower_bound_poly::expand(poly)", " ", convert(stack_level, string),
        "\nTime: ", convert(time() - _log_time_1, string), "\n"));
    FileTools:-Text:-Close(fd);
    stack_level := stack_level - 1;
    if type(d_poly, even) and evalb(0 < evala(c_poly)) then
        fd := FileTools:-Text:-Open("log_time.txt", append);
        FileTools:-Text:-WriteString(fd, cat("End: ", "Lower_bound_poly",
            " ", convert(stack_level, string), "\nTime: ",
            convert(time() - _log_time_0, string), "\n"));
        FileTools:-Text:-Close(fd);
        stack_level := stack_level - 1;
        return [poly, 0]
    end if;
    stack_level := stack_level + 1;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    _log_time_2 := time();
    FileTools:-Text:-WriteString(fd, cat("Start: ",
        "Lower_bound_poly::SemiAlgebraic(g)", " ",
        convert(stack_level, string), "\n"));
    FileTools:-Text:-Close(fd);
    S := map(bound -> bound_info(x, bound, eps),
        SolveTools:-SemiAlgebraic([0 <= g], [x]));
    d_g := degree(expand(g), x);
    _point := S[1][1];
    fd := FileTools:-Text:-Open("log_time.txt", append);
    FileTools:-Text:-WriteString(fd, cat("End: ",
        "Lower_bound_poly::SemiAlgebraic(g)", " ",
        convert(stack_level, string), "\nTime: ",
        convert(time() - _log_time_2, string), "\n"));
    FileTools:-Text:-Close(fd);
    stack_level := stack_level - 1;
    if d_g <= d_poly then
        if type(d_poly - d_g, even) then
            h := (x - _point)^(d_poly - d_g + 2)
        else h := (x - _point)^(d_poly - d_g + 1)
        end if
    else h := 1
    end if;
    G := h*g;
    stack_level := stack_level + 1;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    _log_time_3 := time();
    FileTools:-Text:-WriteString(fd, cat("Start: ",
        "Lower_bound_poly::Minimization_problem", " ",
        convert(stack_level, string), "\n"));
    FileTools:-Text:-Close(fd);
    C := 1/2*min(seq(
        if evalb(S[i][1] = S[i][2]) then 1
        else minimize(simplify(poly/G), x = S[i][1] .. S[i][2])
        end if, i = 1 .. numelems(S)));
    fd := FileTools:-Text:-Open("log_time.txt", append);
    FileTools:-Text:-WriteString(fd, cat("End: ",
        "Lower_bound_poly::Minimization_problem", " ",
        convert(stack_level, string), "\nTime: ",
        convert(time() - _log_time_3, string), "\n"));
    FileTools:-Text:-Close(fd);
    stack_level := stack_level - 1;
    C := evalf(C);
    C := convert(C, rational);
    fd := FileTools:-Text:-Open("log_time.txt", append);
    FileTools:-Text:-WriteString(fd, cat("End: ", "Lower_bound_poly", " ",
        convert(stack_level, string), "\nTime: ",
        convert(time() - _log_time_0, string), "\n"));
    FileTools:-Text:-Close(fd);
    stack_level := stack_level - 1;
    return [poly - C*G, C*h]
end proc

findPositiveConstantAvoidExponent := proc(f, g)
local fd, _log_time_0, i, _args, curr_condition, conditions, pos_coeff, sol
;
    stack_level := stack_level + 1;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    _log_time_0 := time();
    FileTools:-Text:-WriteString(fd, cat("Start: ",
        "findPositiveConstantAvoidExponent", " ",
        convert(stack_level, string), "\n"));
    FileTools:-Text:-Close(fd);
    sol := solve({0 <= c*f - g, 0 < c}, {x}, 'parametric', 'real',
        'parameters' = {c});
    _args := op(sol);
    conditions := [];
    for i to 1/2*nops(sol) do
        if evalb(_args[2*i] = [[x = x]]) then
            conditions := [evalf(_args[2*i - 1]), op(conditions)];
            pos_coeff :=
                Optimization:-Minimize(c, map(`<=`@op, conditions))[1];
            if pos_coeff = 0 then
                fd := FileTools:-Text:-Open("log_time.txt", append);
                FileTools:-Text:-WriteString(fd, cat("End: ",
                    "findPositiveConstantAvoidExponent", " ",
                    convert(stack_level, string), "\nTime: ",
                    convert(time() - _log_time_0, string), "\n"));
                FileTools:-Text:-Close(fd);
                stack_level := stack_level - 1;
                return 1
            else
                fd := FileTools:-Text:-Open("log_time.txt", append);
                FileTools:-Text:-WriteString(fd, cat("End: ",
                    "findPositiveConstantAvoidExponent", " ",
                    convert(stack_level, string), "\nTime: ",
                    convert(time() - _log_time_0, string), "\n"));
                FileTools:-Text:-Close(fd);
                stack_level := stack_level - 1;
                return 1/convert(pos_coeff, rational, exact)
            end if
        end if;
        curr_condition := _args[2*i - 1];
        conditions := [op(0, curr_condition)(
            seq(map(v -> -evalf(v + 1/100), [op(curr_condition)]))),
            op(conditions)]
    end do;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    FileTools:-Text:-WriteString(fd, cat("End: ",
        "findPositiveConstantAvoidExponent", " ",
        convert(stack_level, string), "\nTime: ",
        convert(time() - _log_time_0, string), "\n"));
    FileTools:-Text:-Close(fd);
    stack_level := stack_level - 1;
    return 0
end proc

Last_step := proc(x, _poly, g)
local fd, _log_time_0, A, i, j, Ga, Ep, tobe_disjoint_set, N, N1, N2, poly,
_g, pos_coeff, semialgebraic_Ep_lifted, m, mu, interval, lowerbound,
upperbound, R, SemiAlg_poly, N_list, temp_bound_N, N_top, N_bottom, N_old,
N_curr;
    stack_level := stack_level + 1;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    _log_time_0 := time();
    FileTools:-Text:-WriteString(fd, cat("Start: ", "Last_step", " ",
        convert(stack_level, string), "\n"));
    FileTools:-Text:-Close(fd);
    poly := _poly;
    pos_coeff := 1;
    R := RegularChains:-PolynomialRing([x]);
    A := RegularChains:-SemiAlgebraicSetTools:-IsEmpty([], [-poly], [], [],
        R);
    if evalb(A) then
        fd := FileTools:-Text:-Open("log_time.txt", append);
        FileTools:-Text:-WriteString(fd, cat("End: ", "Last_step", " ",
            convert(stack_level, string), "\nTime: ",
            convert(time() - _log_time_0, string), "\n"));
        FileTools:-Text:-Close(fd);
        stack_level := stack_level - 1;
        return 0
    end if;
    pos_coeff := 1;
    Ga := convert(1/2*evalf(1.001*maximize(g)), rational);
    SemiAlg_poly := SolveTools:-SemiAlgebraic([poly <= 0], [x]);
    Ep := -1/2*max(map(proc(bound)
            interval := bound_info(x, bound, 0);
            lowerbound := interval[1];
            upperbound := interval[2];
            simplify(maximize(g, x = lowerbound .. upperbound))
        end proc, SemiAlg_poly));
    Ep := convert(evalf(Ep), rational);
    semialgebraic_Ep_lifted :=
        SolveTools:-SemiAlgebraic([0 <= g + 17/10*Ep], [x]);
    mu := min(map(proc(bound)
            interval := bound_info(x, bound, 0);
            lowerbound := convert(evalf(interval[1]), rational);
            upperbound := convert(evalf(interval[2]), rational);
            simplify(minimize(poly, x = lowerbound .. upperbound))
        end proc, semialgebraic_Ep_lifted));
    m := ceil(evalf(minimize(poly))) - 1;
    N_list := [];
    temp_bound_N := ceil((log(mu) - log(2*Ga))/(log(Ga) - log(Ga + Ep)));
    N_list := [op(N_list), temp_bound_N];
    temp_bound_N :=
        ceil((log(-m) - log(2*Ep))/(log(Ga + 2*Ep) - log(Ga + Ep)));
    N_list := [op(N_list), temp_bound_N];
    pos_coeff := convert(evalf(solve(
        (log(alpha*mu) - log(2*Ga))/(log(Ga) - log(Ga + Ep)) =
        (log(-alpha*m) - log(2*Ep))/(log(Ga + 2*Ep) - log(Ga + Ep)), alpha,
        'maxsols' = 1)), rational);
    N := ceil(1/2*subs(alpha = pos_coeff,
        (log(alpha*mu) - log(2*Ga))/(log(Ga) - log(Ga + Ep))));
    if N < 50 then
        N_top := N;
        N_bottom := 0;
        N_old := N_top;
        do
            N_curr := iquo(N_top + N_bottom, 2);
            _g := g*((g - Ga)/(Ga + Ep))^(2*N_curr)/pos_coeff;
            if RegularChains:-SemiAlgebraicSetTools:-IsEmpty([],
            [_g - _poly], [], [], R) then N_top := N_curr
            else N_bottom := N_curr
            end if;
            break if N_curr = N_old;
            N_old := N_curr
        end do;
        if N_top = 0 and RegularChains:-SemiAlgebraicSetTools:-IsEmpty([],
        [-_poly], [], [], R) then N := -1
        else N := N_top
        end if
    end if;
    if N = -1 then
        fd := FileTools:-Text:-Open("log_time.txt", append);
        FileTools:-Text:-WriteString(fd, cat("End: ", "Last_step", " ",
            convert(stack_level, string), "\nTime: ",
            convert(time() - _log_time_0, string), "\n"));
        FileTools:-Text:-Close(fd);
        stack_level := stack_level - 1;
        return 0
    else
        fd := FileTools:-Text:-Open("log_time.txt", append);
        FileTools:-Text:-WriteString(fd, cat("End: ", "Last_step", " ",
            convert(stack_level, string), "\nTime: ",
            convert(time() - _log_time_0, string), "\n"));
        FileTools:-Text:-Close(fd);
        stack_level := stack_level - 1;
        return ((g - Ga)/(Ga + Ep))^(2*N)/pos_coeff
    end if
end proc

Sqf := proc(x, poly)
local fd, _log_time_0, L, h, f_u, i;
    stack_level := stack_level + 1;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    _log_time_0 := time();
    FileTools:-Text:-WriteString(fd,
        cat("Start: ", "Sqf", " ", convert(stack_level, string), "\n"));
    FileTools:-Text:-Close(fd);
    L := sqrfree(poly);
    h := 1;
    f_u := L[1];
    for i to numelems(L[2]) do
        if type(L[2][i][2], even) then h := h*L[2][i][1]^L[2][i][2]
        else h := h*L[2][i][1]^(L[2][i][2] - 1); f_u := f_u*L[2][i][1]
        end if
    end do;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    FileTools:-Text:-WriteString(fd, cat("End: ", "Sqf", " ",
        convert(stack_level, string), "\nTime: ",
        convert(time() - _log_time_0, string), "\n"));
    FileTools:-Text:-Close(fd);
    stack_level := stack_level - 1;
    return [f_u, h]
end proc

find_certificate := proc(poly, QM_list, x)
local fd, _log_time_0, Sqm, Hs, f1, g, A, B, H2, f2, H3, f3, H4, F, s1, s2,
certificates, R;
    stack_level := stack_level + 1;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    _log_time_0 := time();
    FileTools:-Text:-WriteString(fd, cat("Start: ", "find_certificate", " ",
        convert(stack_level, string), "\n"));
    FileTools:-Text:-Close(fd);
    R := RegularChains:-PolynomialRing([x]);
    Hs := Fixing_points(poly, QM_list[1], QM_list[2], x);
    f1 := poly - QM_list[1]*Hs[1] - QM_list[2]*Hs[2];
    F := Sqf(x, f1);
    f1 := simplify(F[1]);
    if evalb(
    RegularChains:-SemiAlgebraicSetTools:-IsEmpty([], [-f1], [], [], R))
    then
        s1 := Hs[1];
        s2 := Hs[2];
        certificates := [poly - s1*QM_list[1] - s2*QM_list[2], s1, s2];
        fd := FileTools:-Text:-Open("log_time.txt", append);
        FileTools:-Text:-WriteString(fd, cat("End: ", "find_certificate",
            " ", convert(stack_level, string), "\nTime: ",
            convert(time() - _log_time_0, string), "\n"));
        FileTools:-Text:-Close(fd);
        stack_level := stack_level - 1;
        return certificates
    end if;
    g := bound_poly(QM_list[1], QM_list[2], x);
    H2 := averkov_lemma_7(x, f1, QM_list, g[1]);
    f2 := f1 - QM_list[1]*H2[1] - QM_list[2]*H2[2];
    H3 := Lower_bound_poly(x, f2, g[1]);
    f3 := f2 - g[1]*H3[2];
    H4 := Last_step(x, f3, g[1]);
    s1 := Hs[1] + (H2[1] + (H3[2] + H4)*g[2])*F[2];
    s2 := Hs[2] + (H2[2] + (H3[2] + H4)*g[3])*F[2];
    certificates := [poly - s1*QM_list[1] - s2*QM_list[2], s1, s2];
    fd := FileTools:-Text:-Open("log_time.txt", append);
    FileTools:-Text:-WriteString(fd, cat("End: ", "find_certificate", " ",
        convert(stack_level, string), "\nTime: ",
        convert(time() - _log_time_0, string), "\n"));
    FileTools:-Text:-Close(fd);
    stack_level := stack_level - 1;
    return certificates
end proc

bitsizeI := proc(integer)
    if integer = 0 then return 1 end if;
    return ceil(evalf(log(abs(integer), 2))) + 1
end proc

bitsizeR := proc(rat)
local d;
    d := denom(rat);
    if d = 1 then return bitsizeI(numer(rat))
    else return bitsizeI(numer(rat)) + bitsizeI(denom(rat))
    end if
end proc

bitsizeP := proc(poly, x)
local _sum;
    return add(_sum, _sum in map(bitsizeR, [coeffs(collect(poly, x))]))
end proc

_quickdegree := proc(f, x)
local _f, _exp;
    if type(f, `+`) then
        return max(map(_f -> _quickdegree(_f, x), convert(f, list, `+`)))
    end if;
    if type(f, `*`) then
        return foldl((x1, x2) -> x1 + x2, 0,
            op(map(_f -> _quickdegree(_f, x), convert(f, list, `*`))))
    end if;
    if type(f, `^`) then _f, _exp := op(f); return _exp*_quickdegree(_f, x)
    end if;
    if f = x then return 1 else return 0 end if
end proc

quickdegree := proc(f, x)
local output;
    output := _quickdegree(f, x); return output
end proc

checkWeifeng := proc(f, basis, x, test_name)
local st, H;
    printf("\n>> Test\n%s\n", test_name);
    printf(">> input polynomial\n%s\n", convert(f, string));
    printf(">> basis\n%s\n", convert(basis, string));
    st := time();
    H := find_certificate(f, basis, x);
    printf(">> Time taken\n%f\n", time() - st);
    lprint(">> Sums of squares multipliers", H);
    printf(">> Degree size\n%s\n", convert(foldl((_x, _y) -> max(_x, _y), 0,
        op(map(h -> quickdegree(h, x), H))), string));
    return
end proc

                                [SemiAlgebraic]

                    [SemiAlgebraicSetTools, PolynomialRing]

                              [Maximize, Minimize]

                                     [Text]

                           [Open, Close, WriteString]

_pwd := "/Users/typesarespaces/Documents/GithubProjects/phd-thesis/Documents\
    /Seminars/BeihangUniversity-Fall2021/Weifeng-Notes/Weifeng-Certificates/\
    tests"

  "/Users/typesarespaces/Documents/GithubProjects/phd-thesis/Documents/Seminars/BeihangUniversity-Fall2021/Weifeng-Notes/Weifeng-Certificates/tests"

                            "/Users/typesarespaces"

univsos1 := proc(f)
local s, X;
    X := op(indets(f));
    s := SOSDecomp(expand(f), X, 0);
    return HornerToList1(s)
end proc

Warning, (in SOSDecomp) `s` is implicitly declared local
|univsos/univsos1.mm:54|
SOSDecomp := proc(f, X, prec::integer := 64)
local g, h, S, SEVEN, SODD, newF, s;
    if degree(f) = 0 and f < 0 then
        lprint(f);
        error "There is no decomposition into sum of squares for this po\
            lynomial"
    end if;
    if degree(f) = 0 and 0 <= f then return [[0, [0, 0, f]]] end if;
    if f = 0 then return [[0, [0, 0, 0]]] end if;
    if lcoeff(f, X) < 0 then
        lprint(f);
        error "There is no decomposition into sum of squares for this po\
            lynomial"
    end if;
    if irem(degree(f), 2) = 1 then
        lprint(f);
        error "There is no decomposition into sum of squares for this po\
            lynomial"
    else
        if degree(f, X) = 2 then return [[0, SOSDecompDegree2(f, X)]]
        end if;
        g := gcd(f, diff(f, X), 'newF');
        if degree(g) = 1 then
            newF := quo(newF, g, X);
            if degree(newF) = 2 then
                return [[g, [0, 0, 0]], [0, SOSDecompDegree2(newF, X)]]
            else return [[g, [0, 0, 0]], op(SOSDecompSQF(newF, X, prec))]
            end if
        end if;
        S := sqrfree(f);
        SEVEN := map(
            _e -> if type(_e[2], even) then _e[1]^(1/2*_e[2]) end if, S[2])
            ;
        SEVEN := [op(SEVEN), op(map(
            _e -> if type(_e[2], odd) then _e[1]^(1/2*_e[2] - 1/2) end if,
            S[2]))];
        SEVEN := remove(member, SEVEN, [1]);
        SODD := map(_e -> if type(_e[2], odd) then _e[1] end if, S[2]);
        if nops(SEVEN) = 0 then return SOSDecompSQF(f, X, prec)
        else
            g := mul(s, s in SEVEN);
            h := S[1]*mul(s, s in SODD);
            return [[g, [0, 0, 0]], op(SOSDecomp(h, X, prec))]
        end if
    end if
end proc

SOSDecompSQF := proc(f, X, prec::integer := 64)
local g, h, content_h, SOS_h, SOS_g;
    g := ConstructGPolynomial(f, X, 10);
    h := expand(f - g[1]*g[2]^2);
    if h <> 0 then
        SOS_g := g;
        SOS_h := SOSDecomp(h, X, prec);
        return [[1, SOS_g], op(SOS_h)]
    else SOS_g := g; return [[0, SOS_g]]
    end if
end proc

SOSDecompDegree2 := proc(f, X)
local a, b, c, mycouple;
    if f = 0 then return [f, 0, 0] end if;
    if degree(f) = 0 and 0 < f then return [0, 0, f] end if;
    if degree(f) = 1 or degree(f) = 0 and f < 0 or coeff(f, X, 2) < 0 or
    0 < coeff(f, X, 1)^2 - 4*coeff(f, X, 2)*coeff(f, X, 0) then
        lprint(f);
        error "There is no decomposition into sum of squares for this po\
            lynomial"
    end if;
    c, b, a := seq(coeff(f, X, i), i = 0 .. 2);
    return [a, X + 1/2*b/a, c - 1/4*b^2/a]
end proc

ConstructGPolynomial := proc(f, X, myprec := 10)
local i, inv_roots1, smallest, sf, sdf, g, t, df, values, mymin, minimizer,
a, b, c, newt, _interval, count, mybound, boo;
    df := numer(diff(f, X));
    inv_roots1 := map(s -> rhs(s),
        RootFinding[Isolate](df, X, digits = myprec, output = interval));
    values := map(_s -> subs(X = _s, f), map(_r -> _r[1], inv_roots1));
    mymin := min(op(values));
    for i to nops(inv_roots1) do
        if subs(X = inv_roots1[i][1], f) = mymin then
            minimizer := inv_roots1[i]; _interval := inv_roots1[i]
        end if
    end do;
    if myprec = 0 then t := round(minimizer[1])
    else
        if minimizer[1] < 0 then t := ceil(minimizer[1])
        else t := floor(minimizer[1])
        end if
    end if;
    sf := subs(X = t, f);
    if sf = 0 then
        lprint(f);
        error "There is no decomposition into sum of squares for this po\
            lynomial"
    end if;
    sdf := subs(X = t, diff(f, X));
    a := 1/4*sdf^2/sf;
    c := sf - sdf*t + 1/4*t^2*sdf^2/sf;
    b := sdf - 1/2*sdf^2*t/sf;
    boo := CheckTvalue(t, a, b, c, f, X);
    if boo then return [1/sf, 1/2*sdf*(X - t) + sf, 0] end if;
    if 0 < minimizer[1] - t then mybound := floor(log[2](minimizer[1] - t))
    else mybound := myprec
    end if;
    count := mybound;
    t := t + 2^mybound;
    sf := subs(X = t, f);
    sdf := subs(X = t, diff(f, X));
    while boo = false and 0 <= sf and t < minimizer[2] and sdf <= 0 do
        a := 1/4*sdf^2/sf;
        c := sf - sdf*t + 1/4*t^2*sdf^2/sf;
        b := sdf - 1/2*sdf^2*t/sf;
        boo := CheckTvalue(t, a, b, c, f, X);
        if boo = true then return [1/sf, 1/2*sdf*(X - t) + sf, 0] end if;
        newt := t + 2^count;
        sf := subs(X = newt, f);
        sdf := subs(X = newt, diff(f, X));
        while minimizer[2] <= newt or sf <= 0 do
            count := count - 1; newt := t + 2^count
        end do;
        t := newt
    end do;
    return ConstructGPolynomialRec(f, X, 2*myprec)
end proc

getcoeffs := proc(f, X)
local c, nc, dc, lcmf;
    c := PolynomialTools:-CoefficientVector(f, X);
    nc, dc := MTM[numden](c);
    lcmf := ilcm(op(convert(dc, list)));
    return Vector(lcmf*c)
end proc

ConstructGPolynomialRec := proc(f, X, myprec, useNewton::boolean := false,
aNewton::rational := 0, bNewton::rational := 0)
local mid, fcoeffs, newaNewton, newbNewton, dfa, dfb, i, inv_roots1,
smallest, sf, sdf, g, t, df, values, mymin, minimizer, a, b, c, _interval;
    df := convert(diff(f, X), horner);
    if useNewton then
        mid := 1/2*aNewton + 1/2*bNewton;
        fcoeffs := getcoeffs(diff(f, X), X);
        newaNewton, newbNewton :=
            MyUnivariateNewton(fcoeffs, aNewton, bNewton, mid);
        if 0 < newaNewton then t := newbNewton else t := newaNewton end if
    else
        inv_roots1 := fgbrs:-rs_isolate_uni(primpart(diff(f, X)), X,
            precision = myprec, verbose = 0);
        values := map(_s -> subs(X = _s, f), map(_r -> _r[1], inv_roots1));
        mymin := min(op(values));
        for i to nops(inv_roots1) do
            if subs(X = inv_roots1[i][1], f) = mymin then
                minimizer := inv_roots1[i]; _interval := inv_roots1[i]
            end if
        end do;
        newaNewton := minimizer[1];
        newbNewton := minimizer[2];
        t := minimizer[1]
    end if;
    sf := subs(X = t, f);
    if sf = 0 then
        error "There is no decomposition into sum of squares for this po\
            lynomial"
    end if;
    sdf := subs(X = t, df);
    a := 1/4*sdf^2/sf;
    c := sf - sdf*t + t^2*a;
    b := sdf - 2*t*a;
    if CheckTvalue(t, a, b, c, f, X) then
        return [1/sf, 1/2*sdf*(X - t) + sf, 0]
    end if;
    return ConstructGPolynomialRec(f, X, 2*myprec, false, newaNewton,
        newbNewton)
end proc

NaiveBolzano := proc(f, X)
local df, inv_roots1, values, mymin, i, minimizer, _interval, t1, t2;
    df := convert(diff(f, X), horner);
    inv_roots1 := fgbrs:-rs_isolate_uni(primpart(diff(f, X)), X,
        precision = 2, verbose = 0);
    values := map(_s -> subs(X = _s, f), map(_r -> _r[1], inv_roots1));
    mymin := min(op(values));
    for i to nops(inv_roots1) do
        if subs(X = inv_roots1[i][1], f) = mymin then
            minimizer := inv_roots1[i]; _interval := inv_roots1[i]
        end if
    end do;
    t1 := minimizer[1];
    t2 := minimizer[2];
    return BolzanoRec(f, df, X, t1, t2)
end proc

BolzanoRec := proc(f, df, X, t1, t2)
local t, sf, sdf, a, c, b;
    t := 1/2*t1 + 1/2*t2;
    sf := subs(X = t, f);
    if sf = 0 then
        error "There is no decomposition into sum of squares for this po\
            lynomial"
    end if;
    sdf := subs(X = t, df);
    a := 1/4*sdf^2/sf;
    c := sf - sdf*t + t^2*a;
    b := sdf - 2*a*t;
    if sdf = 0 then return [1/sf, 1/2*sdf*(X - t) + sf, 0] end if;
    if 0 < sdf then
        if CheckTvalue(t, a, b, c, f, X) then
            return [1/sf, 1/2*sdf*(X - t) + sf, 0]
        end if;
        return BolzanoRec(f, df, X, t1, t)
    end if;
    if CheckTvalue(t, a, b, c, f, X) then
        return [1/sf, 1/2*sdf*(X - t) + sf, 0]
    end if;
    return BolzanoRec(f, df, X, t, t2)
end proc

ConFrac := proc(t, f, df, X, sf, sdf, myprec)
local newt, newsf, newsdf, a, b, c;
    newt := confrac2rat(convert(t, confrac, myprec));
    lprint(newt);
    newsf := subs(X = t, f);
    newsdf := subs(X = t, df);
    a := 1/4*newsdf^2/newsf;
    c := newsf - newsdf*newt + newt^2*a;
    b := newsdf - 2*a*newt;
    if CheckTvalue(newt, a, b, c, f, X) then
        return [1/newsf, 1/2*newsdf*(X - newt) + newsf, 0]
    else return [1/sf, 1/2*sdf*(X - t) + sf, 0]
    end if
end proc

SmallerApprox := proc(t, f, df, X, sf, sdf)
local newt, newsf, newsdf, a, b, c, myprec;
    myprec := floor(1/8*BitRat(t));
    if 0 < t then newt := BinaryApproximationDown(t, myprec)
    else newt := BinaryApproximationUp(t, myprec)
    end if;
    newsf := subs(X = t, f);
    newsdf := subs(X = t, df);
    a := 1/4*newsdf^2/newsf;
    c := newsf - newsdf*newt + newt^2*a;
    b := newsdf - 2*a*newt;
    if CheckTvalue(newt, a, b, c, f, X) then
        lprint("After rounding ", newt);
        return [1/newsf, 1/2*newsdf*(X - newt) + newsf, 0]
    else return [1/sf, 1/2*sdf*(X - t) + sf, 0]
    end if
end proc

Warning, (in CheckTvalue) `s` is implicitly declared local
|univsos/univsos1.mm:370|
CheckTvalue := proc(t, a, b, c, f, X)
local F, S, SODD, newg, g, newF, s;
    if a = 0 and b <> 0 or a = 0 and b = 0 and c < 0 then return false
    end if;
    if a <> 0 and 0 < b^2 - 4*a*c then return false end if;
    F := f - a*X^2 - b*X - c;
    g := gcd(F, diff(F, X), 'newF');
    if degree(g) = 1 then
        newF := quo(newF, g, X);
        if 0 < nops(fgbrs:-rs_isolate_uni(numer(newF), X, precision = 1))
        then return false
        else return true
        end if
    else
        S := sqrfree(F);
        SODD := map(_e -> if type(_e[2], odd) then _e[1] end if, S[2]);
        SODD := mul(s, s in SODD);
        if 0 < nops(fgbrs:-rs_isolate_uni(SODD, X, precision = 1)) then
            return false
        else return true
        end if
    end if
end proc

Warning, (in oldCheckTvalue) `s` is implicitly declared local
|univsos/univsos1.mm:402|
oldCheckTvalue := proc(t, g, f, X)
local a, b, c, F, S, SODD, newg, s;
    a, b, c := coeff(g, X, 2), coeff(g, X, 1), coeff(g, X, 0);
    if a = 0 and b <> 0 or a = 0 and b = 0 and c < 0 then return false
    end if;
    if a <> 0 and 0 < b^2 - 4*c*a then return false end if;
    F := normal(f - g);
    S := sqrfree(F);
    SODD := map(_e -> if type(_e[2], odd) then _e[1] end if, S[2]);
    SODD := mul(s, s in SODD);
    if 0 < nops(fgbrs:-rs_isolate_uni(primpart(SODD), X, precision = 1))
    then return false
    else return true
    end if
end proc

MyNewtonIterator := proc(_interval, pol)
local a, b, c, X, newa;
    a := _interval[1];
    b := _interval[2];
    X := op(1, indets(pol));
    newa := a - subs({X = a}, pol)/subs({X = a}, diff(pol, X));
    return [newa, b]
end proc

BolzanoIterator := proc(_interval, pol)
local a, b, c, X, sc;
    a := _interval[1];
    b := _interval[2];
    c := 1/2*a + 1/2*b;
    X := op(1, indets(pol));
    sc := eval(pol, X = c);
    if sc = 0 then return [a, c] end if;
    if sign(sc) = sign(eval(pol, X = a)) then return [c, b]
    else return [a, c]
    end if
end proc

Warning, (in UnivariateSumOfSquaresDecItv) `i` is implicitly declared local
|univsos/univsos1.mm:468|
Warning, (in UnivariateSumOfSquaresDecItv) `c` is implicitly declared local
|univsos/univsos1.mm:476|
Warning, (in UnivariateSumOfSquaresDecItv) `si` is implicitly declared local
|univsos/univsos1.mm:479|
Warning, (in UnivariateSumOfSquaresDecItv) `r` is implicitly declared local
|univsos/univsos1.mm:484|
Warning, (in UnivariateSumOfSquaresDecItv) `j` is implicitly declared local
|univsos/univsos1.mm:484|
Warning, (in UnivariateSumOfSquaresDecItv) `t` is implicitly declared local
|univsos/univsos1.mm:485|
UnivariateSumOfSquaresDecItv := proc(f, a, b)
local psatz, bitsos, n, cf, q, sosq, clist, soslist, rlist, tlist, nc, l,
sosf1, sosf2, sosdecomp, ti, tcmp, sos, i, c, si, r, j, t;
    psatz := false;
    n := degree(f);
    if n = 0 and f < 0 then
        error "There is no decomposition into sum of squares for this po\
            lynomial"
    end if;
    if b < a then
        error cat("The interval [", convert(a, string), ", ",
            convert(b, string), "] is not valid")
    end if;
    q := add(coeff(f, x, i)*(y^2 + 1)^(n - i)*(a + b*y^2)^i, i = 0 .. n);
    ti := time();
    sosq := SOSDecomp(q, y, 2);
    tcmp := time() - ti;
    lprint(tcmp);
    if psatz = true then
        sos := HornerToList(sosq);
        clist := [seq(c[1]/(b - a)^n, c in sos)];
        soslist := [seq(c[2], c in sos)];
        rlist := [seq(
            add(coeff(si, y, 2*i)*y^i, i = 0 .. ceil(degree(1/2*si))),
            si in soslist)];
        tlist := [seq(
            add(coeff(si, y, 2*i + 1)*y^i, i = 0 .. ceil(degree(1/2*si))),
            si in soslist)];
        nc := floor(1/2*n);
        l := nops(clist);
        sosf1 := [seq(add(coeff(r, y, j)*(x - a)^j*(b - x)^(nc - j),
            j = 0 .. degree(r)), r in rlist)];
        if n mod 2 = 0 then
            sosf2 := [seq(add(
                coeff(t, y, j)*(x - a)^j*(b - x)^(nc - 1 - j),
                j = 0 .. degree(t)), t in tlist)]
        else
            sosf2 := [seq(add(coeff(t, y, j)*(x - a)^j*(b - x)^(nc - j),
                j = 0 .. degree(t)), t in tlist)]
        end if;
        return clist, sosf1, sosf2
    end if;
    return q, sosq
end proc

HornerToList := proc(sos)
local hd, tl, p, c, q, d;
    if nops(sos) = 0 then return [] end if;
    if nops(sos) = 1 then
        p, c, q, d := sos[1][1], op(sos[1][2]);
        if c = 0 and d = 0 then return [[1, p]] end if;
        if c = 0 then return [[1, p], [d, 1]] end if;
        if d = 0 then return [[1, p], [c, q]] end if;
        return [[1, p], [c, q], [d, 1]]
    end if;
    hd, tl := HdTailList(sos);
    p, c, q, d := hd[1], op(hd[2]);
    if c = 0 and d = 0 then return [op(MulPolList2(p, HornerToList(tl)))]
    end if;
    if c = 0 then return [op(MulPolList2(p, HornerToList(tl))), [d, 1]]
    end if;
    if d = 0 then return [op(MulPolList2(p, HornerToList(tl))), [c, q]]
    end if;
    return [op(MulPolList2(p, HornerToList(tl))), [c, q], [d, 1]]
end proc

Warning, (in HdTailList) `i` is implicitly declared local
|univsos/univsos1.mm:507|
HdTailList :=

    proc(l) local i; return l[1], [seq(l[i], i = 2 .. nops(l))] end proc

       MulPolList2 := proc(p, l) map(el -> [el[1], p*el[2]], l) end proc

              MulPolList := proc(p, l) map(el -> p*el, l) end proc

HornerToList1 := proc(l)
local l1;
    l1 := HornerToList(l);
    return foldr((a, b) -> [op(a), op(b)], [], op(l1))
end proc

SOSCHECK := proc(f, sos)
local res;
    res := expand(f - foldr(
        (_e, a) -> _e[1]^2*a + _e[2][1]*_e[2][2]^2 + _e[2][3], 1, op(sos)))
        ;
    if res = 0 then return res
    else
        lprint(f);
        lprint(sos);
        error "Invalid sum of squares decomposition"
    end if
end proc

SOSCHECK2 := proc(f, sos)
local s, i, res;
    s := 0;
    for i to 1/2*nops(sos) do s := s + sos[2*i - 1]*sos[2*i]^2 end do;
    res := expand(f - s);
    if res = 0 then return res
    else
        lprint(f);
        lprint(sos);
        error "Invalid sum of squares decomposition"
    end if
end proc

          soscheck1 := proc(f, sos) return SOSCHECK2(f, sos) end proc

Warning, (in univsos2) `se` is implicitly declared local
|univsos/univsos2.mm:23|
Warning, (in univsos2) `so` is implicitly declared local
|univsos/univsos2.mm:24|
univsos2 := proc(p, id::integer := 2, iter::boolean := false)
local x, S, s, c, SEVEN, SODD, q, n, m, t, e, r, k, ok, l, a, p_can, p_cnj,
s1, s2, u, v, i, j, sqs, cfs, sos, rfloat, gp, gproots, se, so;
    x := op(indets(p));
    S := sqrfree(p);
    c := lcoeff(p);
    if c < 0 then
        lprint(p);
        lprint(c);
        error "There is no decomposition into sum of squares for this po\
            lynomial"
    end if;
    SEVEN :=
        map(_e -> if type(_e[2], even) then _e[1]^(1/2*_e[2]) end if, S[2])
        ;
    SEVEN := [op(SEVEN), op(map(
        _e -> if type(_e[2], odd) then _e[1]^(1/2*_e[2] - 1/2) end if, S[2]))
        ];
    SEVEN := remove(member, SEVEN, [1]);
    SODD := map(_e -> if type(_e[2], odd) then _e[1] end if, S[2]);
    s := mul(se, se in SEVEN);
    q := S[1]*mul(so, so in SODD);
    n := degree(q, x);
    m := floor(1/2*n);
    if 2*m <> n then
        lprint(p);
        error "There is no decomposition into sum of squares for this po\
            lynomial"
    end if;
    if n = 0 then lprint(q, " * (", s, ")^2") end if;
    t := q;
    if id = 2 then t := sum(x^(2*i), i = 0 .. m)
    else if id = 1 then t := sum(x^j, j = 0 .. n) end if
    end if;
    e := max(1, c);
    printf("Perturbation loop\n");
    while q - e*t <> 0 and 0 < nops(realroot(q - e*t)) do e := 1/2*e end do
    ;
    printf("  epsilon = ");
    lprint(e);
    e := 1/2*e;
    r := q - e*t;
    k := 1;
    ok := false;
    printf("Root isolation loop\n");
    while not ok do
        k := 2*k;
        l := lcoeff(r, x);
        printf("  precision of root isolation = %d\n", k);
        gproots := true;
        gp := true;
        if gp then s1, s2 := gpsquares(r, x, k, iter)
        else
            a := polroots(r, x, gproots, iter);
            p_can := mul(x - a[2*i - 1], i = 1 .. 1/2*degree(r));
            p_cnj := mul(x - a[2*i], i = 1 .. 1/2*degree(r));
            s1 := convert(evalc(Re(1/2*p_can + 1/2*p_cnj)), rational, k);
            s2 := convert(evalc(Re(-1/2*I*(p_can - p_cnj))), rational, k)
        end if;
        u := r - l*(s1^2 + s2^2);
        v := expand(e*t + u);
        ok := true;
        for i from 0 to m do
            ok := ok and
                1/4*abs(coeff(v, x, 2*i + 1)) + abs(coeff(v, x, 2*i - 1))
                 <= coeff(v, x, 2*i)
        end do
    end do;
    sqs := [s1, s2];
    cfs := [l, l];
    for i from 0 to m do
        sqs := [op(sqs), x^i];
        cfs := [op(cfs), coeff(v, x, 2*i) - 1/4*abs(coeff(v, x, 2*i + 1))
             - abs(coeff(v, x, 2*i - 1))]
    end do;
    for i from 0 to m - 1 do
        sqs := [op(sqs), x^i*(x + 1/2*sign(coeff(v, x, 2*i + 1)))];
        cfs := [op(cfs), abs(coeff(v, x, 2*i + 1))]
    end do;
    sos := [];
    for i to 2*m + 3 do sos := [op(sos), cfs[i], s*sqs[i]] end do;
    return sos
end proc

Warning, (in UnivariateSumOfSquaresDecItv2) `i` is implicitly declared local
|univsos/univsos2.mm:129|
Warning, (in UnivariateSumOfSquaresDecItv2) `c` is implicitly declared local
|univsos/univsos2.mm:137|
Warning, (in UnivariateSumOfSquaresDecItv2) `si` is implicitly declared local
|univsos/univsos2.mm:140|
Warning, (in UnivariateSumOfSquaresDecItv2) `r` is implicitly declared local
|univsos/univsos2.mm:145|
Warning, (in UnivariateSumOfSquaresDecItv2) `j` is implicitly declared local
|univsos/univsos2.mm:145|
Warning, (in UnivariateSumOfSquaresDecItv2) `t` is implicitly declared local
|univsos/univsos2.mm:146|
UnivariateSumOfSquaresDecItv2 := proc(f, a, b)
local psatz, bitsos, n, cf, q, sosq, clist, soslist, rlist, tlist, nc, l,
sosf1, sosf2, sosdecomp, ti, tcmp, sos, i, c, si, r, j, t;
    psatz := false;
    n := degree(f);
    if n = 0 and f < 0 then
        error "There is no decomposition into sum of squares for this po\
            lynomial"
    end if;
    if b < a then
        error cat("The interval [", convert(a, string), ", ",
            convert(b, string), "] is not valid")
    end if;
    q := add(coeff(f, x, i)*(y^2 + 1)^(n - i)*(a + b*y^2)^i, i = 0 .. n);
    ti := time[real]();
    sosq := univsos2(expand(q), y, 2);
    tcmp := time[real]() - ti;
    printf("%fms\n", 1000*tcmp);
    if psatz = true then
        sos := HornerToList(sosq);
        clist := [seq(c[1]/(b - a)^n, c in sos)];
        soslist := [seq(c[2], c in sos)];
        rlist := [seq(
            add(coeff(si, y, 2*i)*y^i, i = 0 .. ceil(degree(1/2*si))),
            si in soslist)];
        tlist := [seq(
            add(coeff(si, y, 2*i + 1)*y^i, i = 0 .. ceil(degree(1/2*si))),
            si in soslist)];
        nc := floor(1/2*n);
        l := nops(clist);
        sosf1 := [seq(add(coeff(r, y, j)*(x - a)^j*(b - x)^(nc - j),
            j = 0 .. degree(r)), r in rlist)];
        if n mod 2 = 0 then
            sosf2 := [seq(add(
                coeff(t, y, j)*(x - a)^j*(b - x)^(nc - 1 - j),
                j = 0 .. degree(t)), t in tlist)]
        else
            sosf2 := [seq(add(coeff(t, y, j)*(x - a)^j*(b - x)^(nc - j),
                j = 0 .. degree(t)), t in tlist)]
        end if;
        return clist, sosf1, sosf2
    end if;
    return q, sosq
end proc

gpsquares := proc(r, x, k, iter)
local fd, ok, prec, cmd, status;
    fd := fopen("univsos/in.gp", WRITE, TEXT);
    writeline(fd, "r =", StringTools:-SubstituteAll(
        StringTools:-SubstituteAll(convert(r, string), "\n", ""), "\\", ""))
        ;
    writeline(fd, "x =", convert(x, string));
    writeline(fd, "k =", convert(k, string));
    fclose(fd);
    ok := true;
    if iter then
        prec := 1000000000;
        while ok do
            if FileTools:-Exists("univsos/out.mm") then
                FileTools:-Remove("univsos/out.mm")
            end if;
            cmd := sprintf("gp -q -s %d univsos/gpsquares.gp", prec);
            ssystem(cmd);
            try read "univsos/out.mm"
            catch:
                prec := 10*prec;
                printf("   Issue with PARI/GP root isolation: trying wit\
                    h stack precision = %d\n", prec)
            finally ok := false
            end try
        end do
    else
        if FileTools:-Exists("univsos/out.mm") then
            FileTools:-Remove("univsos/out.mm")
        end if;
        ssystem("gp -q univsos/gpsquares.gp");
        read "univsos/out.mm"
    end if;
    return s1gp, s2gp
end proc

polroots := proc(r, x, gproots)
local fd, a, rfloat;
    rfloat := r;
    if gproots then
        fd := fopen("univsos/in.gp", WRITE, TEXT);
        writeline(fd, "r =", convert(rfloat, string));
        fclose(fd);
        if FileTools:-Exists("univsos/out.mm") then
            FileTools:-Remove("univsos/out.mm")
        end if;
        ssystem("gp -q  univsos/mypolroots.gp");
        ssystem("sed -i 's/0\\.E/0\\.0E/g' univsos/out.mm");
        ssystem("sed -i 's/ E/E/g' univsos/out.mm");
        read "univsos/out.mm";
        return agp
    else
        a := [fsolve([r = 0], x, complex, fulldigits)];
        return map(sol -> rhs(sol[1]), a)
    end if
end proc

SOSCHECK2 := proc(f, sos)
local s, i, res;
    s := 0;
    for i to 1/2*nops(sos) do s := s + sos[2*i - 1]*sos[2*i]^2 end do;
    res := expand(f - s);
    if res = 0 then return res
    else
        lprint(f);
        lprint(sos);
        error "Invalid sum of squares decomposition"
    end if
end proc

          soscheck2 := proc(f, sos) return SOSCHECK2(f, sos) end proc

Warning, (in univsos3) `se` is implicitly declared local
|univsos/univsos3.mm:21|
Warning, (in univsos3) `so` is implicitly declared local
|univsos/univsos3.mm:22|
univsos3 := proc(p, prec::integer := 10)
local S, s, c, SEVEN, SODD, q, n, m, t, e, r, ok, l, a, p_can, p_cnj, s1,
s2, u, v, i, j, sqs, cfs, sos, rfloat, gp, eigs, eigs2, soslist, soslist2,
sumsos, cnd, maxq, k, obj_plus_r0, id, x, se, so;
    x := op(indets(p));
    id := 2;
    S := sqrfree(p);
    c := lcoeff(p);
    if c < 0 then
        lprint(p);
        error "There is no decomposition into sum of squares for this po\
            lynomial"
    end if;
    SEVEN :=
        map(_e -> if type(_e[2], even) then _e[1]^(1/2*_e[2]) end if, S[2])
        ;
    SEVEN := [op(SEVEN), op(map(
        _e -> if type(_e[2], odd) then _e[1]^(1/2*_e[2] - 1/2) end if, S[2]))
        ];
    SEVEN := remove(member, SEVEN, [1]);
    SODD := map(_e -> if type(_e[2], odd) then _e[1] end if, S[2]);
    s := mul(se, se in SEVEN);
    q := S[1]*mul(so, so in SODD);
    maxq := 1;
    q := q/maxq;
    n := degree(q, x);
    m := floor(1/2*n);
    if 2*m <> n then
        lprint(p);
        error "There is no decomposition into sum of squares for this po\
            lynomial"
    end if;
    if n = 0 then lprint(q, " * (", s, ")^2") end if;
    t := q;
    if id = 2 then t := sum(x^(2*i), i = 0 .. m)
    else if id = 1 then t := sum(x^j, j = 0 .. n) end if
    end if;
    e := min(1, c);
    while
    degree(q - e*t, x) <= 0 or q - e*t <> 0 and 0 < nops(realroot(q - e*t))
    do e := 1/2*e
    end do;
    e := 1/2*e;
    r := q - e*t;
    ok := false;
    k := prec;
    while not ok do
        k := k + 1;
        eigs, soslist, eigs2, soslist2, obj_plus_r0 := sossdp(r, x, k);
        sumsos :=
            obj_plus_r0 + sum(eigs[j]*soslist[j]^2, j = 1 .. nops(soslist))
            ;
        u := r - sumsos;
        v := expand(e*t + u + obj_plus_r0);
        ok := true;
        for i from 0 to m do
            cnd := coeff(v, x, 2*i) - 1/4*abs(coeff(v, x, 2*i + 1))
                 - abs(coeff(v, x, 2*i - 1));
            if not (0 <= cnd) then
                printf("prec = %d\t idx = %d\t err = %8.3e\t", k, i,
                    evalf(cnd));
                lprint(cnd);
                ok := true;
                error "not enough precision";
                break
            end if
        end do
    end do;
    sqs := [op(soslist)];
    cfs := [op(eigs)];
    for i from 0 to m do
        sqs := [op(sqs), x^i];
        cfs := [op(cfs), coeff(v, x, 2*i) - 1/4*abs(coeff(v, x, 2*i + 1))
             - abs(coeff(v, x, 2*i - 1))]
    end do;
    for i from 0 to m - 1 do
        sqs := [op(sqs), x^i*(x + 1/2*sign(coeff(v, x, 2*i + 1)))];
        cfs := [op(cfs), abs(coeff(v, x, 2*i + 1))]
    end do;
    sos := [];
    for i to nops(sqs) do sos := [op(sos), maxq*cfs[i], s*sqs[i]] end do;
    return sos
end proc

Warning, (in UnivariateSumOfSquaresDecItv3) `i` is implicitly declared local
|univsos/univsos3.mm:111|
Warning, (in UnivariateSumOfSquaresDecItv3) `c` is implicitly declared local
|univsos/univsos3.mm:120|
Warning, (in UnivariateSumOfSquaresDecItv3) `si` is implicitly declared local
|univsos/univsos3.mm:123|
Warning, (in UnivariateSumOfSquaresDecItv3) `r` is implicitly declared local
|univsos/univsos3.mm:128|
Warning, (in UnivariateSumOfSquaresDecItv3) `j` is implicitly declared local
|univsos/univsos3.mm:128|
Warning, (in UnivariateSumOfSquaresDecItv3) `t` is implicitly declared local
|univsos/univsos3.mm:129|
UnivariateSumOfSquaresDecItv3 := proc(f, a, b, k::integer := 1)
local psatz, bitsos, n, cf, q, sosq, clist, soslist, rlist, tlist, nc, l,
sosf1, sosf2, sosdecomp, ti, tcmp, sos, i, c, si, r, j, t;
    psatz := false;
    n := degree(f);
    if n = 0 and f < 0 then
        error "There is no decomposition into sum of squares for this po\
            lynomial"
    end if;
    if b < a then
        error cat("The interval [", convert(a, string), ", ",
            convert(b, string), "] is not valid")
    end if;
    q := add(coeff(f, x, i)*(y^2 + 1)^(n - i)*(a + b*y^2)^i, i = 0 .. n);
    ti := time[real]();
    sosq := univsos3(q, y, 2, k);
    tcmp := time[real]() - ti;
    printf("%fms\n", 1000*tcmp);
    if psatz = true then
        sos := HornerToList(sosq);
        clist := [seq(c[1]/(b - a)^n, c in sos)];
        soslist := [seq(c[2], c in sos)];
        rlist := [seq(
            add(coeff(si, y, 2*i)*y^i, i = 0 .. ceil(degree(1/2*si))),
            si in soslist)];
        tlist := [seq(
            add(coeff(si, y, 2*i + 1)*y^i, i = 0 .. ceil(degree(1/2*si))),
            si in soslist)];
        nc := floor(1/2*n);
        l := nops(clist);
        sosf1 := [seq(add(coeff(r, y, j)*(x - a)^j*(b - x)^(nc - j),
            j = 0 .. degree(r)), r in rlist)];
        if n mod 2 = 0 then
            sosf2 := [seq(add(
                coeff(t, y, j)*(x - a)^j*(b - x)^(nc - 1 - j),
                j = 0 .. degree(t)), t in tlist)]
        else
            sosf2 := [seq(add(coeff(t, y, j)*(x - a)^j*(b - x)^(nc - j),
                j = 0 .. degree(t)), t in tlist)]
        end if;
        return clist, sosf1, sosf2
    end if;
    return q, sosq
end proc

sossdp := proc(r, x, precSVD::integer := 10, precSDP::integer := 200,
epsStar::integer := 3, epsDash::integer := 3, a::rational := 0,
b::rational := 1, itv::boolean := false)
local fd, n, nsdp, nblock, nloc, i, j, Y, Y2, v, e, mons, rfloat, eigs,
eivs, eigs2, eivs2, gmp, normeig, gpround, SVD, af, bf, lowerbnd;
    n := degree(r);
    nsdp := 1 + ceil(1/2*n);
    if itv then nblock := 2 else nblock := 1 end if;
    fd := fopen("univsos/in.dat-s", WRITE, TEXT);
    writeline(fd, convert(2*ceil(1/2*n), string));
    writeline(fd, convert(nblock, string));
    if not itv then writeline(fd, convert(nsdp, string))
    else nloc := ceil(1/2*n); fprintf(fd, "%d %d\n", nsdp, nloc)
    end if;
    rfloat := convert(r, float, 100);
    af := convert(a, float);
    bf := convert(b, float);
    for i to 2*ceil(1/2*n) do fprintf(fd, "%.100f ", coeff(rfloat, x, i))
    end do;
    fprintf(fd, "\n");
    writeline(fd, "0 1 1 1 -1");
    for j from 2 to nsdp do fprintf(fd, "%d 1 %d %d 1\n", j - 1, 1, j)
    end do;
    for i from 2 to nsdp do
        for j from i to nsdp do
            fprintf(fd, "%d 1 %d %d 1\n", i + j - 2, i, j)
        end do
    end do;
    if itv then
        for i to nloc do
            for j from i to nloc do
                fprintf(fd, "%d 2 %d %d %f\n", i + j - 2, i, j,
                    -sign(i + j - 3)*bf*af);
                fprintf(fd, "%d 2 %d %d %f\n", i + j - 1, i, j,
                    sign(i + j - 2)*(bf + af));
                fprintf(fd, "%d 2 %d %d %f\n", i + j, i, j,
                    -sign(i + j - 1))
            end do
        end do
    end if;
    fclose(fd);
    if FileTools:-Exists("univsos/out.dat-s") then
        FileTools:-Remove("univsos/out.dat-s")
    end if;
    if FileTools:-Exists("univsos/out.mm") then
        FileTools:-Remove("univsos/out.mm")
    end if;
    gmp := true;
    if not gmp then
        system("sdpa -ds univsos/in.dat-s -o univsos/out.dat-s -p univso\
            s/param.sdpa > /dev/null")
    else
        write_param(precSDP, epsStar, epsDash);
        system("sdpa_gmp -ds univsos/in.dat-s -o univsos/out.dat-s -p un\
            ivsos/param_gmp.sdpa > /dev/null")
    end if;
    system("echo $(grep objValPrimal univsos/out.dat-s) ';' 'yMat:=' $(s\
        ed -n '/yMat/,/main/{//!p}' univsos/out.dat-s) ';' >> univsos/ou\
        t.mm");
    system("sed -i 's/ =/ :=/g' univsos/out.mm");
    system("sed -i 's/{/[/g' univsos/out.mm");
    system("sed -i 's/}/]/g' univsos/out.mm");
    system("sed -i 's/] \\[/], \\[/g' univsos/out.mm");
    read "univsos/out.mm";
    lowerbnd := coeff(r, x, 0) + convert(objValPrimal, rational, exact);
    SVD := true;
    Y := Matrix(yMat[1]);
    eigs, eivs := eigseivs_(Y, x, nsdp, precSVD, SVD);
    if itv then
        Y2 := Matrix(yMat[2]);
        eigs2, eivs2 := eigseivs_(Y2, x, nloc, precSVD, SVD)
    else eigs2 := Vector(1, 0); eivs2 := Vector(1, 0)
    end if;
    return convert(eigs, list), convert(eivs, list), convert(eigs2, list),
        convert(eivs2, list), lowerbnd
end proc

checkrational_ := proc(U)
local v;
    for v in U do
        if not type(convert(v, rational), realcons) then
            lprint(v);
            error "Non Rational Cholesky factor, retry with gmp = true"
        end if
    end do;
    return
end proc

eigseivs_ := proc(Y, x, nmat, precSVD, SVD)
local ti, tf, v, e, mons, eigs, eivs, gpround, normeig, U, S, V, Ysvd,
Yexact, tcmp;
    mons := Vector(nmat, j -> x^(j - 1));
    normeig := false;
    gpround := false;
    Yexact := convert(Y, rational, exact);
    if not SVD then
        ti := time[real]();
        lprint("starting Cholesky");
        U := LUDecomposition(Yexact, method = 'Cholesky');
        checkrational_(U);
        tcmp := time[real]() - ti;
        lprint(tcmp);
        lprint("ending Cholesky");
        S := IdentityMatrix(nmat)
    else
        Digits := precSVD;
        ti := time[real]();
        U, S, V := MTM[svd](Yexact);
        tcmp := time[real]() - ti;
        lprint(tcmp);
        Digits := 10
    end if;
    eigs := Diagonal(S);
    eivs := Transpose((Transpose(mons)) . U);
    return eigs, eivs
end proc

write_param := proc(precSDP, epsStar, epsDash)
local fd;
    fd := fopen("univsos/my_param_gmp.sdpa", WRITE, TEXT);
    fprintf(fd, "300\tunsigned int maxIteration;\n");
    fprintf(fd, "1.0E-%d\tdouble 0.0 < epsilonStar;\n", epsStar);
    fprintf(fd, "1.0E5   double 0.0 < lambdaStar;\n");
    fprintf(fd, "2.0   \tdouble 1.0 < omegaStar;\n");
    fprintf(fd, "-1.0E5  double lowerBound;\n");
    fprintf(fd, "1.0E5   double upperBound;\n");
    fprintf(fd, "0.1     double 0.0 <= betaStar <  1.0;\n");
    fprintf(fd,
        "0.3     double 0.0 <= betaBar  <  1.0, betaStar <= betaBar;\n");
    fprintf(fd, "0.9     double 0.0 < gammaStar  <  1.0;\n");
    fprintf(fd, "1.0E-%d\tdouble 0.0 < epsilonDash;\n", epsDash);
    fprintf(fd, "%d     precision\n", precSDP);
    fclose(fd)
end proc

      printpol := proc(p) lprint(sort(evalf(expand(p)), x, plex)) end proc

Warning, (in sositv3) `se` is implicitly declared local
|univsos/univsos3.mm:324|
Warning, (in sositv3) `so` is implicitly declared local
|univsos/univsos3.mm:325|
sositv3 := proc(f, a, b, prec::integer := 10, precSVD::integer := 10,
precSDP::integer := 200, epsStar::integer := 3, epsDash::integer := 3)
local bitsos, n, cf, q, sosq, clist, soslist, soslist2, rlist, tlist, nc, l,
sosf1, sosf2, sosdecomp, ti, tcmp, sos, sos2, h, S, c, SEVEN, SODD, s, ds,
dq, p1, p2, m, t, e, r, k, ok, eigs, eigs2, sumsos, sumsos2, u, v, i, sqs,
cfs, id, cnd, maxp1, obj_plus_r0, x, se, so;
    x := op(indets(p));
    n := degree(f);
    id := 2;
    if n = 0 and f < 0 then
        error "There is no decomposition into sum of squares for this po\
            lynomial"
    end if;
    if b < a then
        error cat("The interval [", convert(a, string), ", ",
            convert(b, string), "] is not valid")
    end if;
    h := add(coeff(f, x, i)*(y^2 + 1)^(n - i)*(a + b*y^2)^i, i = 0 .. n);
    S := sqrfree(h);
    c := lcoeff(f);
    SEVEN :=
        map(_e -> if type(_e[2], even) then _e[1]^(1/2*_e[2]) end if, S[2])
        ;
    SEVEN := [op(SEVEN), op(map(
        _e -> if type(_e[2], odd) then _e[1]^(1/2*_e[2] - 1/2) end if, S[2]))
        ];
    SEVEN := remove(member, SEVEN, [1]);
    SODD := map(_e -> if type(_e[2], odd) then _e[1] end if, S[2]);
    s := mul(se, se in SEVEN);
    q := S[1]*mul(so, so in SODD);
    ds := degree(s, y);
    dq := 1/2*degree(q, y);
    p1 := add(coeff(q, y, 2*i)*(b - x)^(dq - i)*(x - a)^i, i = 0 .. dq)/
        (b - a)^dq;
    p2 := add(coeff(s, y, 2*i)*(b - x)^(ds - i)*(x - a)^i, i = 0 .. ds)/
        (b - a)^ds;
    p1 := expand(p1);
    maxp1 := 1;
    p1 := p1/maxp1;
    n := degree(p1, x);
    m := ceil(1/2*n);
    if n = 0 then lprint(p1, " * (", p2, ")^2") end if;
    t := p1;
    if id = 3 then t := sum(abs(coeff(p1, x, i))*x^i, i = 0 .. n)
    else
        if id = 2 then t := sum(x^(2*i), i = 0 .. m)
        else if id = 1 then t := sum(x^j, j = 0 .. n) end if
        end if
    end if;
    e := 1/2^prec;
    r := p1 - e*t;
    k := prec;
    ok := false;
    while not ok do
        eigs, soslist, eigs2, soslist2, obj_plus_r0 :=
            sossdp(r, x, precSVD, precSDP, epsStar, epsDash, a, b, true);
        sumsos :=
            obj_plus_r0 + sum(eigs[j]*soslist[j]^2, j = 1 .. nops(soslist))
            ;
        sumsos2 := (b - x)*(x - a)*
            sum(eigs2[j]*soslist2[j]^2, j = 1 .. nops(soslist2));
        u := r - sumsos - sumsos2;
        v := expand(e*t + u + obj_plus_r0);
        ok := true;
        for i from 0 to m do
            cnd := coeff(v, x, 2*i) - 1/4*abs(coeff(v, x, 2*i + 1))
                 - abs(coeff(v, x, 2*i - 1));
            if not (0 <= cnd) then
                printf("prec = %d\t idx = %d\t err = %8.3e\t", k, i,
                    evalf(cnd));
                ok := true;
                error "not enough precision";
                break
            end if
        end do;
        break
    end do;
    sqs := [op(soslist)];
    cfs := [op(eigs)];
    for i from 0 to m do
        sqs := [op(sqs), x^i];
        cfs := [op(cfs), coeff(v, x, 2*i) - 1/4*abs(coeff(v, x, 2*i + 1))
             - abs(coeff(v, x, 2*i - 1))]
    end do;
    for i from 0 to m - 1 do
        sqs := [op(sqs), x^i*(x + 1/2*sign(coeff(v, x, 2*i + 1)))];
        cfs := [op(cfs), abs(coeff(v, x, 2*i + 1))]
    end do;
    sos := [];
    sos2 := [];
    for i to nops(sqs) do sos := [op(sos), maxp1*cfs[i], p2*sqs[i]] end do;
    for i to nops(eigs2) do
        sos2 := [op(sos2), maxp1*eigs2[i], p2*soslist2[i]]
    end do;
    return sos, sos2
end proc

          "/Users/typesarespaces/Documents/GithubProjects/RealCertify"

                               stack_level := -1

getSOSPoly := proc(poly, x)
local fd, _log_time_0, s, i, sos;
    stack_level := stack_level + 1;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    _log_time_0 := time();
    FileTools:-Text:-WriteString(fd, cat("Start: ", "getSOSPoly", " ",
        convert(stack_level, string), "\n"));
    FileTools:-Text:-Close(fd);
    sos := univsos1(poly, x);
    s := 0;
    for i to 1/2*nops(sos) do s := s + sos[2*i - 1]*sos[2*i]^2 end do;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    FileTools:-Text:-WriteString(fd, cat("End: ", "getSOSPoly", " ",
        convert(stack_level, string), "\nTime: ",
        convert(time() - _log_time_0, string), "\n"));
    FileTools:-Text:-Close(fd);
    stack_level := stack_level - 1;
    return s
end proc

Ord := proc(f, t, point)
local fd, _log_time_0, g, T;
    stack_level := stack_level + 1;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    _log_time_0 := time();
    FileTools:-Text:-WriteString(fd,
        cat("Start: ", "Ord", " ", convert(stack_level, string), "\n"));
    FileTools:-Text:-Close(fd);
    g := subs(t = T + point, f);
    fd := FileTools:-Text:-Open("log_time.txt", append);
    FileTools:-Text:-WriteString(fd, cat("End: ", "Ord", " ",
        convert(stack_level, string), "\nTime: ",
        convert(time() - _log_time_0, string), "\n"));
    FileTools:-Text:-Close(fd);
    stack_level := stack_level - 1;
    return ldegree(expand(g), T)
end proc

Eps := proc(f, t, point)
local fd, _log_time_0, g;
    stack_level := stack_level + 1;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    _log_time_0 := time();
    FileTools:-Text:-WriteString(fd,
        cat("Start: ", "Eps", " ", convert(stack_level, string), "\n"));
    FileTools:-Text:-Close(fd);
    g := subs(t = y + point, f);
    fd := FileTools:-Text:-Open("log_time.txt", append);
    FileTools:-Text:-WriteString(fd, cat("End: ", "Eps", " ",
        convert(stack_level, string), "\nTime: ",
        convert(time() - _log_time_0, string), "\n"));
    FileTools:-Text:-Close(fd);
    stack_level := stack_level - 1;
    return tcoeff(expand(g), y)
end proc

Type_of_poly := proc(p, t, point)
local fd, _log_time_0, O, E, output;
    stack_level := stack_level + 1;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    _log_time_0 := time();
    FileTools:-Text:-WriteString(fd, cat("Start: ", "Type_of_poly", " ",
        convert(stack_level, string), "\n"));
    FileTools:-Text:-Close(fd);
    O := Ord(p, t, point);
    E := Eps(p, t, point);
    if type(O, even) and 0 < E then output := 0
    elif type(O, even) and E < 0 then output := 1
    elif type(O, odd) and 0 < E then output := 2
    elif type(O, odd) and E < 0 then output := 3
    end if;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    FileTools:-Text:-WriteString(fd, cat("End: ", "Type_of_poly", " ",
        convert(stack_level, string), "\nTime: ",
        convert(time() - _log_time_0, string), "\n"));
    FileTools:-Text:-Close(fd);
    stack_level := stack_level - 1;
    return output
end proc

Type_of_P := proc(G, t, point)
local fd, _log_time_0, O_1, O_2, E_1, E_2;
    stack_level := stack_level + 1;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    _log_time_0 := time();
    FileTools:-Text:-WriteString(fd, cat("Start: ", "Type_of_P", " ",
        convert(stack_level, string), "\n"));
    FileTools:-Text:-Close(fd);
    O_1 := Ord(G[1], t, point);
    O_2 := Ord(G[2], t, point);
    E_1 := Eps(G[1], t, point);
    E_2 := Eps(G[2], t, point);
    if type(O_1, even) and E_1 < 0 then
        if O_1 <= O_2 or Type_of_poly(G[2], t, point) = 0 then
            fd := FileTools:-Text:-Open("log_time.txt", append);
            FileTools:-Text:-WriteString(fd, cat("End: ", "Type_of_P", " ",
                convert(stack_level, string), "\nTime: ",
                convert(time() - _log_time_0, string), "\n"));
            FileTools:-Text:-Close(fd);
            stack_level := stack_level - 1;
            return 1
        elif O_2 < O_1 and Type_of_poly(G[2], t, point) <> 0 then
            if E_2 < 0 then
                fd := FileTools:-Text:-Open("log_time.txt", append);
                FileTools:-Text:-WriteString(fd, cat("End: ", "Type_of_P",
                    " ", convert(stack_level, string), "\nTime: ",
                    convert(time() - _log_time_0, string), "\n"));
                FileTools:-Text:-Close(fd);
                stack_level := stack_level - 1;
                return 2
            elif 0 < E_2 then
                fd := FileTools:-Text:-Open("log_time.txt", append);
                FileTools:-Text:-WriteString(fd, cat("End: ", "Type_of_P",
                    " ", convert(stack_level, string), "\nTime: ",
                    convert(time() - _log_time_0, string), "\n"));
                FileTools:-Text:-Close(fd);
                stack_level := stack_level - 1;
                return 3
            end if
        end if
    elif type(O_2, even) and E_2 < 0 then
        if O_2 <= O_1 or Type_of_poly(G[1], t, point) = 0 then
            fd := FileTools:-Text:-Open("log_time.txt", append);
            FileTools:-Text:-WriteString(fd, cat("End: ", "Type_of_P", " ",
                convert(stack_level, string), "\nTime: ",
                convert(time() - _log_time_0, string), "\n"));
            FileTools:-Text:-Close(fd);
            stack_level := stack_level - 1;
            return 1
        elif O_1 < O_2 and Type_of_poly(G[1], t, point) <> 0 then
            if E_1 < 0 then
                fd := FileTools:-Text:-Open("log_time.txt", append);
                FileTools:-Text:-WriteString(fd, cat("End: ", "Type_of_P",
                    " ", convert(stack_level, string), "\nTime: ",
                    convert(time() - _log_time_0, string), "\n"));
                FileTools:-Text:-Close(fd);
                stack_level := stack_level - 1;
                return 2
            elif 0 < E_1 then
                fd := FileTools:-Text:-Open("log_time.txt", append);
                FileTools:-Text:-WriteString(fd, cat("End: ", "Type_of_P",
                    " ", convert(stack_level, string), "\nTime: ",
                    convert(time() - _log_time_0, string), "\n"));
                FileTools:-Text:-Close(fd);
                stack_level := stack_level - 1;
                return 3
            end if
        end if
    elif E_1*E_2 < 0 and O_1*O_2 <> 0 then
        fd := FileTools:-Text:-Open("log_time.txt", append);
        FileTools:-Text:-WriteString(fd, cat("End: ", "Type_of_P", " ",
            convert(stack_level, string), "\nTime: ",
            convert(time() - _log_time_0, string), "\n"));
        FileTools:-Text:-Close(fd);
        stack_level := stack_level - 1;
        return 4
    elif O_1 = 0 then
        if 0 < E_2 then
            fd := FileTools:-Text:-Open("log_time.txt", append);
            FileTools:-Text:-WriteString(fd, cat("End: ", "Type_of_P", " ",
                convert(stack_level, string), "\nTime: ",
                convert(time() - _log_time_0, string), "\n"));
            FileTools:-Text:-Close(fd);
            stack_level := stack_level - 1;
            return 5
        elif E_2 < 0 then
            fd := FileTools:-Text:-Open("log_time.txt", append);
            FileTools:-Text:-WriteString(fd, cat("End: ", "Type_of_P", " ",
                convert(stack_level, string), "\nTime: ",
                convert(time() - _log_time_0, string), "\n"));
            FileTools:-Text:-Close(fd);
            stack_level := stack_level - 1;
            return 6
        end if
    elif O_2 = 0 then
        if 0 < E_1 then
            fd := FileTools:-Text:-Open("log_time.txt", append);
            FileTools:-Text:-WriteString(fd, cat("End: ", "Type_of_P", " ",
                convert(stack_level, string), "\nTime: ",
                convert(time() - _log_time_0, string), "\n"));
            FileTools:-Text:-Close(fd);
            stack_level := stack_level - 1;
            return 5
        elif E_1 < 0 then
            fd := FileTools:-Text:-Open("log_time.txt", append);
            FileTools:-Text:-WriteString(fd, cat("End: ", "Type_of_P", " ",
                convert(stack_level, string), "\nTime: ",
                convert(time() - _log_time_0, string), "\n"));
            FileTools:-Text:-Close(fd);
            stack_level := stack_level - 1;
            return 6
        end if
    elif 0 < E_1 then
        fd := FileTools:-Text:-Open("log_time.txt", append);
        FileTools:-Text:-WriteString(fd, cat("End: ", "Type_of_P", " ",
            convert(stack_level, string), "\nTime: ",
            convert(time() - _log_time_0, string), "\n"));
        FileTools:-Text:-Close(fd);
        stack_level := stack_level - 1;
        return 5
    elif E_1 < 0 then
        fd := FileTools:-Text:-Open("log_time.txt", append);
        FileTools:-Text:-WriteString(fd, cat("End: ", "Type_of_P", " ",
            convert(stack_level, string), "\nTime: ",
            convert(time() - _log_time_0, string), "\n"));
        FileTools:-Text:-Close(fd);
        stack_level := stack_level - 1;
        return 6
    end if
end proc

Type_of_Point := proc(G, f, t, point)
local fd, _log_time_0, T_1, T_2, output;
    stack_level := stack_level + 1;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    _log_time_0 := time();
    FileTools:-Text:-WriteString(fd, cat("Start: ", "Type_of_Point", " ",
        convert(stack_level, string), "\n"));
    FileTools:-Text:-Close(fd);
    T_1 := Type_of_poly(f, t, point);
    T_2 := Type_of_P(G, t, point);
    if T_1 = 1 and 1 <= T_2 and T_2 <= 3 then output := 1
    elif T_1 = 1 and T_2 = 4 then output := 2
    elif T_1 = 2 and 1 <= T_2 and T_2 <= 2 then output := 3
    elif T_1 = 2 and 3 <= T_2 and T_2 <= 5 then output := 4
    elif T_1 = 3 and (T_2 = 1 or T_2 = 3) then output := 5
    elif T_1 = 3 and (T_2 = 2 or T_2 = 4 or T_2 = 6) then output := 6
    end if;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    FileTools:-Text:-WriteString(fd, cat("End: ", "Type_of_Point", " ",
        convert(stack_level, string), "\nTime: ",
        convert(time() - _log_time_0, string), "\n"));
    FileTools:-Text:-Close(fd);
    stack_level := stack_level - 1;
    return output
end proc

Pre_poly := proc(g, f, t, S, point)
local fd, _log_time_0, h, i, d;
    stack_level := stack_level + 1;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    _log_time_0 := time();
    FileTools:-Text:-WriteString(fd,
        cat("Start: ", "Pre_poly", " ", convert(stack_level, string), "\n"))
        ;
    FileTools:-Text:-Close(fd);
    h := 1;
    for i in S do
        if i <> point then
            if Ord(g, t, i) <= Ord(f, t, i) then
                d := 2*floor(1/2*Ord(f, t, i) - 1/2*Ord(g, t, i)) + 2;
                h := (t - i)^d*h
            end if
        end if
    end do;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    FileTools:-Text:-WriteString(fd, cat("End: ", "Pre_poly", " ",
        convert(stack_level, string), "\nTime: ",
        convert(time() - _log_time_0, string), "\n"));
    FileTools:-Text:-Close(fd);
    stack_level := stack_level - 1;
    return h
end proc

Fixing_case_1 := proc(g, f, t, point)
local fd, _log_time_0, m, n, c_1, c_2, h, a;
    stack_level := stack_level + 1;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    _log_time_0 := time();
    FileTools:-Text:-WriteString(fd, cat("Start: ", "Fixing_case_1", " ",
        convert(stack_level, string), "\n"));
    FileTools:-Text:-Close(fd);
    m := Ord(f, t, point);
    n := Ord(g, t, point);
    c_1 := Eps(f, t, point);
    c_2 := Eps(g, t, point);
    a := (abs(c_1) + 1)/abs(c_2);
    h := a*(t - point)^(m - n);
    fd := FileTools:-Text:-Open("log_time.txt", append);
    FileTools:-Text:-WriteString(fd, cat("End: ", "Fixing_case_1", " ",
        convert(stack_level, string), "\nTime: ",
        convert(time() - _log_time_0, string), "\n"));
    FileTools:-Text:-Close(fd);
    stack_level := stack_level - 1;
    return h
end proc

Fixing_case_2 := proc(g_1, g_2, f, t, point)
local fd, _log_time_0, m, n_1, n_2, c_1, c_2, h_1, h_2, a, g, h;
    stack_level := stack_level + 1;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    _log_time_0 := time();
    FileTools:-Text:-WriteString(fd, cat("Start: ", "Fixing_case_2", " ",
        convert(stack_level, string), "\n"));
    FileTools:-Text:-Close(fd);
    m := Ord(f, t, point);
    h := 1;
    n_1 := Ord(g_1, t, point);
    n_2 := Ord(g_2, t, point);
    c_1 := Eps(g_1, t, point);
    c_2 := Eps(g_2, t, point);
    h_1 := (t - point)^(2*floor(1/2*m - 1/2*n_1))/abs(c_1);
    h_2 := (t - point)^(2*floor(1/2*m - 1/2*n_2))/abs(c_2);
    if 0 < c_1 then
        h_1 := 1/4*h_1*(t - point - 1)^2; h_2 := 1/4*h_2*(t - point + 1)^2
    elif c_1 < 0 then
        h_1 := 1/4*h_1*(t - point + 1)^2; h_2 := 1/4*h_2*(t - point - 1)^2
    end if;
    g := h_1*g_1 + h_2*g_2;
    h := Fixing_case_1(expand(g), f, t, point);
    fd := FileTools:-Text:-Open("log_time.txt", append);
    FileTools:-Text:-WriteString(fd, cat("End: ", "Fixing_case_2", " ",
        convert(stack_level, string), "\nTime: ",
        convert(time() - _log_time_0, string), "\n"));
    FileTools:-Text:-Close(fd);
    stack_level := stack_level - 1;
    return [h*h_1, h*h_2]
end proc

Fixing_case_3 := proc(g, f, t, point)
local fd, _log_time_0, m, n, c, h_1, g_1, h_2, h;
    stack_level := stack_level + 1;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    _log_time_0 := time();
    FileTools:-Text:-WriteString(fd, cat("Start: ", "Fixing_case_3", " ",
        convert(stack_level, string), "\n"));
    FileTools:-Text:-Close(fd);
    m := Ord(f, t, point);
    n := Ord(g, t, point);
    c := Eps(g, t, point);
    h_1 := 1/4*(t - point - 1)^2/abs(c);
    g_1 := h_1*g + 1/4*(t - point)^n*(t - point + 1)^2;
    h_2 := Fixing_case_4(g_1, f, t, point);
    h := h_1*h_2;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    FileTools:-Text:-WriteString(fd, cat("End: ", "Fixing_case_3", " ",
        convert(stack_level, string), "\nTime: ",
        convert(time() - _log_time_0, string), "\n"));
    FileTools:-Text:-Close(fd);
    stack_level := stack_level - 1;
    return h
end proc

Fixing_case_4 := proc(g, f, t, point)
local fd, _log_time_0, m, n, b_1, b_2, d, c_1, c_2, h;
    stack_level := stack_level + 1;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    _log_time_0 := time();
    FileTools:-Text:-WriteString(fd, cat("Start: ", "Fixing_case_4", " ",
        convert(stack_level, string), "\n"));
    FileTools:-Text:-Close(fd);
    m := Ord(f, t, point);
    n := Ord(g, t, point);
    c_1 := Eps(f, t, point);
    b_1 := Eps(g, t, point);
    c_2 := Eps(f - c_1*(t - point)^m, t, point);
    b_2 := Eps(g - b_1*(t - point)^n, t, point);
    if 0 < c_2/c_1 - b_2/b_1 then d := 0; h := c_1*(t - point)^(m - n)/b_1
    else
        d := 2/(c_2/c_1 - b_2/b_1 - 1);
        h := c_1*(t - point)^(m - n)*(x - point + d)^2/(b_1*d^2)
    end if;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    FileTools:-Text:-WriteString(fd, cat("End: ", "Fixing_case_4", " ",
        convert(stack_level, string), "\nTime: ",
        convert(time() - _log_time_0, string), "\n"));
    FileTools:-Text:-Close(fd);
    stack_level := stack_level - 1;
    return h
end proc

Fixing_case_5 := proc(g, f, t, point)
local fd, _log_time_0, m, n, c, h_1, g_1, h_2, h;
    stack_level := stack_level + 1;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    _log_time_0 := time();
    FileTools:-Text:-WriteString(fd, cat("Start: ", "Fixing_case_5", " ",
        convert(stack_level, string), "\n"));
    FileTools:-Text:-Close(fd);
    m := Ord(f, t, point);
    n := Ord(g, t, point);
    c := Eps(g, t, point);
    h_1 := 1/4*(t - point + 1)^2/abs(c);
    g_1 := h_1*g + 1/4*(t - point)^n*(t - point - 1)^2;
    h_2 := Fixing_case_6(g_1, f, t, point);
    h := h_1*h_2;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    FileTools:-Text:-WriteString(fd, cat("End: ", "Fixing_case_5", " ",
        convert(stack_level, string), "\nTime: ",
        convert(time() - _log_time_0, string), "\n"));
    FileTools:-Text:-Close(fd);
    stack_level := stack_level - 1;
    return h
end proc

Fixing_case_6 := proc(g, f, t, point)
local fd, _log_time_0, m, n, a, d, b_1, b_2, c_1, c_2, h;
    stack_level := stack_level + 1;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    _log_time_0 := time();
    FileTools:-Text:-WriteString(fd, cat("Start: ", "Fixing_case_6", " ",
        convert(stack_level, string), "\n"));
    FileTools:-Text:-Close(fd);
    m := Ord(f, t, point);
    n := Ord(g, t, point);
    c_1 := Eps(f, t, point);
    b_1 := Eps(g, t, point);
    c_2 := Eps(f - c_1*(t - point)^m, t, point);
    b_2 := Eps(g - b_1*(t - point)^n, t, point);
    if c_2/c_1 - b_2/b_1 < 0 then d := 0; h := c_1*(t - point)^(m - n)/b_1
    else
        d := 2/(c_2/c_1 - b_2/b_1 + 1);
        h := c_1*(t - point)^(m - n)*(x - point + d)^2/(b_1*d^2)
    end if;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    FileTools:-Text:-WriteString(fd, cat("End: ", "Fixing_case_6", " ",
        convert(stack_level, string), "\nTime: ",
        convert(time() - _log_time_0, string), "\n"));
    FileTools:-Text:-Close(fd);
    stack_level := stack_level - 1;
    return h
end proc

Fixing_points := proc(f, g_1, g_2, t)
local
fd, _log_time_0, fixing, S, interval, flag, point, H_1, H_2, h_1, h_2, h, g
;
    stack_level := stack_level + 1;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    _log_time_0 := time();
    FileTools:-Text:-WriteString(fd, cat("Start: ", "Fixing_points", " ",
        convert(stack_level, string), "\n"));
    FileTools:-Text:-Close(fd);
    S := map(proc(bound)
            interval := bound_info(t, bound, 0);
            ASSERT(evalb(interval[1] = interval[2]));
            return interval[1]
        end proc, SolveTools:-SemiAlgebraic([0 <= g_1, 0 <= g_2], [t]));
    H_1 := 0;
    H_2 := 0;
    for point in S do
        flag := Type_of_Point([g_1, g_2], f, t, point);
        if flag = 1 then
            if type(Ord(g_1, t, point), even) and Eps(g_1, t, point) < 0
             and Ord(g_1, t, point) <= Ord(g_2, t, point) then
                h := Pre_poly(g_1, f, t, S, point);
                H_1 := H_1 + h*Fixing_case_1(h*g_1, f, t, point)
            elif type(Ord(g_2, t, point), even) and Eps(g_2, t, point) < 0
             and Ord(g_2, t, point) <= Ord(g_1, t, point) then
                h := Pre_poly(g_2, f, t, S, point);
                H_2 := H_2 + h*Fixing_case_1(h*g_2, f, t, point)
            end if
        elif flag = 2 then
            h_1 := Pre_poly(g_1, f, t, S, point);
            h_2 := Pre_poly(g_2, f, t, S, point);
            fixing := Fixing_case_2(h_1*g_1, h_2*g_2, f, t, point);
            H_1 := H_1 + h_1*fixing[1];
            H_2 := H_2 + h_2*fixing[2]
        elif flag = 3 then
            if Type_of_poly(g_1, t, point) = 1 then
                g := g_1;
                h_1 := Pre_poly(g, f, t, S, point);
                H_1 := H_1 + h_1*Fixing_case_3(h_1*g, f, t, point)
            elif Type_of_poly(g_2, t, point) = 1 then
                g := g_2;
                h_2 := Pre_poly(g, f, t, S, point);
                H_2 := H_2 + h_2*Fixing_case_3(h_2*g, f, t, point)
            end if
        elif flag = 4 then
            if Type_of_poly(g_1, t, point) = 2 then
                g := g_1;
                h_1 := Pre_poly(g, f, t, S, point);
                H_1 := H_1 + h_1*Fixing_case_4(h_1*g_1, f, t, point)
            elif Type_of_poly(g_2, t, point) = 2 then
                g := g_2;
                h_2 := Pre_poly(g, f, t, S, point);
                H_2 := H_2 + h_2*Fixing_case_4(h_2*g, f, t, point)
            end if
        elif flag = 5 then
            if Type_of_poly(g_1, t, point) = 1 then
                g := g_1;
                h_1 := Pre_poly(g, f, t, S, point);
                H_1 := H_1 + h_1*Fixing_case_5(h_1*g_1, f, t, point)
            elif Type_of_poly(g_2, t, point) = 1 then
                g := g_2;
                h_2 := Pre_poly(g, f, t, S, point);
                H_2 := H_2 + h_2*Fixing_case_5(h_2*g, f, t, point)
            end if
        elif flag = 6 then
            if Type_of_poly(g_1, t, point) = 3 then
                g := g_1;
                h_1 := Pre_poly(g, f, t, S, point);
                H_1 := H_1 + h_1*Fixing_case_6(h_1*g_1, f, t, point)
            elif Type_of_poly(g_2, t, point) = 3 then
                g := g_2;
                h_2 := Pre_poly(g, f, t, S, point);
                H_2 := H_2 + h_2*Fixing_case_6(h_2*g, f, t, point)
            end if
        end if
    end do;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    FileTools:-Text:-WriteString(fd, cat("End: ", "Fixing_points", " ",
        convert(stack_level, string), "\nTime: ",
        convert(time() - _log_time_0, string), "\n"));
    FileTools:-Text:-Close(fd);
    stack_level := stack_level - 1;
    return [H_1, H_2]
end proc

bound_poly := proc(g_1, g_2, x)
local fd, _log_time_0, d, c, c_1, g, h1, h2;
    stack_level := stack_level + 1;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    _log_time_0 := time();
    FileTools:-Text:-WriteString(fd, cat("Start: ", "bound_poly", " ",
        convert(stack_level, string), "\n"));
    FileTools:-Text:-Close(fd);
    d := [degree(g_1, x), degree(g_2, x)];
    c := [coeff(g_1, x^d[1]), coeff(g_2, x^d[2])];
    c_1 := [
        if d[1] = 1 then subs(x = 0, g_1)/abs(c[1])
        else coeff(g_1/abs(c[1]), x^(d[1] - 1))
        end if,
        if d[2] = 1 then subs(x = 0, g_2)/abs(c[2])
        else coeff(g_2/abs(c[2]), x^(d[2] - 1))
        end if];
    if type(d[1], even) and c[1] < 0 then
        fd := FileTools:-Text:-Open("log_time.txt", append);
        FileTools:-Text:-WriteString(fd, cat("End: ", "bound_poly", " ",
            convert(stack_level, string), "\nTime: ",
            convert(time() - _log_time_0, string), "\n"));
        FileTools:-Text:-Close(fd);
        stack_level := stack_level - 1;
        return [g_1, 1, 0]
    elif type(d[2], even) and c[2] < 0 then
        fd := FileTools:-Text:-Open("log_time.txt", append);
        FileTools:-Text:-WriteString(fd, cat("End: ", "bound_poly", " ",
            convert(stack_level, string), "\nTime: ",
            convert(time() - _log_time_0, string), "\n"));
        FileTools:-Text:-Close(fd);
        stack_level := stack_level - 1;
        return [g_2, 0, 1]
    else
        if d[1] = d[2] then
            h1 := x^2/abs(c[1]);
            h2 :=
                (x + sign(c[1])*(1/2*c_1[1] + 1/2*c_1[2] + 1))^2/abs(c[2]);
            g := h1*g_1 + h2*g_2
        elif d[2] < d[1] then
            h1 := 1/abs(c[1]);
            h2 := x^(d[1] - d[2] - 2)*
                (x + sign(c[1])*(1/2*c_1[1] + 1/2*c_1[2] + 1))^2/abs(c[2])
        else
            h1 := x^(d[2] - d[1] - 2)*
                (x - sign(c[1])*(1/2*c_1[1] + 1/2*c_1[2] + 1))^2/abs(c[1]);
            h2 := 1/abs(c[2])
        end if
    end if;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    FileTools:-Text:-WriteString(fd, cat("End: ", "bound_poly", " ",
        convert(stack_level, string), "\nTime: ",
        convert(time() - _log_time_0, string), "\n"));
    FileTools:-Text:-Close(fd);
    stack_level := stack_level - 1;
    return [expand(h1*g_1 + h2*g_2), h1, h2]
end proc

dot_product := proc(v1, v2)
local fd, _log_time_0, out, i;
    stack_level := stack_level + 1;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    _log_time_0 := time();
    FileTools:-Text:-WriteString(fd, cat("Start: ", "dot_product", " ",
        convert(stack_level, string), "\n"));
    FileTools:-Text:-Close(fd);
    out := 0;
    for i to min(nops(v1), nops(v2)) do out := out + v1[i]*v2[i] end do;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    FileTools:-Text:-WriteString(fd, cat("End: ", "dot_product", " ",
        convert(stack_level, string), "\nTime: ",
        convert(time() - _log_time_0, string), "\n"));
    FileTools:-Text:-Close(fd);
    stack_level := stack_level - 1;
    return out
end proc

bound_info := proc(x, bound, eps)
local fd, _log_time_0, i1, i2, j1, j2;
    stack_level := stack_level + 1;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    _log_time_0 := time();
    FileTools:-Text:-WriteString(fd, cat("Start: ", "bound_info", " ",
        convert(stack_level, string), "\n"));
    FileTools:-Text:-Close(fd);
    if nops(bound) = 2 then
        i1 := simplify(op(bound[1])[1]);
        i2 := simplify(op(bound[1])[2]);
        j1 := simplify(op(bound[2])[1]);
        j2 := simplify(op(bound[2])[2]);
        if evalb(i1 = x) then
            if evalb(j1 = x) then
                fd := FileTools:-Text:-Open("log_time.txt", append);
                FileTools:-Text:-WriteString(fd, cat("End: ", "bound_info",
                    " ", convert(stack_level, string), "\nTime: ",
                    convert(time() - _log_time_0, string), "\n"));
                FileTools:-Text:-Close(fd);
                stack_level := stack_level - 1;
                return [min(i2, j2) + eps, max(i2, j2) - eps]
            else
                fd := FileTools:-Text:-Open("log_time.txt", append);
                FileTools:-Text:-WriteString(fd, cat("End: ", "bound_info",
                    " ", convert(stack_level, string), "\nTime: ",
                    convert(time() - _log_time_0, string), "\n"));
                FileTools:-Text:-Close(fd);
                stack_level := stack_level - 1;
                return [min(i2, j1) + eps, max(i2, j1) - eps]
            end if
        else
            if evalb(j1 = x) then
                fd := FileTools:-Text:-Open("log_time.txt", append);
                FileTools:-Text:-WriteString(fd, cat("End: ", "bound_info",
                    " ", convert(stack_level, string), "\nTime: ",
                    convert(time() - _log_time_0, string), "\n"));
                FileTools:-Text:-Close(fd);
                stack_level := stack_level - 1;
                return [min(i1, j2) + eps, max(i1, j2) - eps]
            else
                fd := FileTools:-Text:-Open("log_time.txt", append);
                FileTools:-Text:-WriteString(fd, cat("End: ", "bound_info",
                    " ", convert(stack_level, string), "\nTime: ",
                    convert(time() - _log_time_0, string), "\n"));
                FileTools:-Text:-Close(fd);
                stack_level := stack_level - 1;
                return [min(i1, j1) + eps, max(i1, j1) - eps]
            end if
        end if
    else
        i1 := simplify(op(bound[1])[1]);
        j1 := simplify(op(bound[1])[2]);
        if type(bound[1], `=`) then
            if evalb(i1 = x) then
                fd := FileTools:-Text:-Open("log_time.txt", append);
                FileTools:-Text:-WriteString(fd, cat("End: ", "bound_info",
                    " ", convert(stack_level, string), "\nTime: ",
                    convert(time() - _log_time_0, string), "\n"));
                FileTools:-Text:-Close(fd);
                stack_level := stack_level - 1;
                return [j1, j1]
            else
                fd := FileTools:-Text:-Open("log_time.txt", append);
                FileTools:-Text:-WriteString(fd, cat("End: ", "bound_info",
                    " ", convert(stack_level, string), "\nTime: ",
                    convert(time() - _log_time_0, string), "\n"));
                FileTools:-Text:-Close(fd);
                stack_level := stack_level - 1;
                return [i1, i1]
            end if
        end if;
        if type(bound[1], `<=`) then
            if evalb(i1 = x) then
                fd := FileTools:-Text:-Open("log_time.txt", append);
                FileTools:-Text:-WriteString(fd, cat("End: ", "bound_info",
                    " ", convert(stack_level, string), "\nTime: ",
                    convert(time() - _log_time_0, string), "\n"));
                FileTools:-Text:-Close(fd);
                stack_level := stack_level - 1;
                return [-infinity, j1 - eps]
            else
                fd := FileTools:-Text:-Open("log_time.txt", append);
                FileTools:-Text:-WriteString(fd, cat("End: ", "bound_info",
                    " ", convert(stack_level, string), "\nTime: ",
                    convert(time() - _log_time_0, string), "\n"));
                FileTools:-Text:-Close(fd);
                stack_level := stack_level - 1;
                return [i1 + eps, infinity]
            end if
        end if
    end if
end proc

averkov_lemma_7 := proc(x, f, basis, B_poly)
local fd, _log_time_0, _gamma, interval, lowerbound, upperbound, eps,
tobe_disjoint_set, N, g, term, semialgebraic_of_B, R, M, mu, m, N_list,
temp_bound_N, pos_coeff, _pos_coeff, T, semialgebraic_for_mu, N_top,
N_bottom, N_old, N_curr;
    stack_level := stack_level + 1;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    _log_time_0 := time();
    FileTools:-Text:-WriteString(fd, cat("Start: ", "averkov_lemma_7", " ",
        convert(stack_level, string), "\n"));
    FileTools:-Text:-Close(fd);
    R := RegularChains:-PolynomialRing([x]);
    semialgebraic_of_B := SolveTools:-SemiAlgebraic([0 <= B_poly], [x]);
    _gamma := 1/2*max(map(proc(g_i)
            map(proc(bound)
                    interval := bound_info(x, bound, 0);
                    lowerbound := convert(evalf(interval[1]), rational);
                    upperbound := convert(evalf(interval[2]), rational);
                    simplify(maximize(g_i, x = lowerbound .. upperbound))
                end proc, semialgebraic_of_B)
        end proc, basis));
    _gamma := ceil(evalf(_gamma));
    T := SolveTools:-SemiAlgebraic([0 <= B_poly, f < 0], [x]);
    eps := -1/2*min(map(proc(g_i)
            map(proc(bound)
                    interval := bound_info(x, bound, 0);
                    lowerbound := convert(evalf(interval[1]), rational);
                    upperbound := convert(evalf(interval[2]), rational);
                    simplify(maximize(g_i, x = lowerbound .. upperbound))
                end proc, T)
        end proc, basis));
    if eps = -infinity then eps := 1 end if;
    semialgebraic_for_mu := SolveTools:-SemiAlgebraic(
        [0 <= B_poly, op(map(g_i -> 0 <= g_i + 2*eps, basis))], [x]);
    mu := min(map(proc(bound)
            interval := bound_info(x, bound, 0);
            lowerbound := convert(evalf(interval[1]), rational);
            upperbound := convert(evalf(interval[2]), rational);
            simplify(minimize(f, x = lowerbound .. upperbound))
        end proc, semialgebraic_for_mu));
    mu := convert(evalf(mu), rational);
    M := -min(map(proc(bound)
            interval := bound_info(x, bound, 0);
            lowerbound := convert(evalf(interval[1]), rational);
            upperbound := convert(evalf(interval[2]), rational);
            simplify(minimize(f, x = lowerbound .. upperbound))
        end proc, semialgebraic_of_B));
    m := numelems(basis);
    N_list := [-infinity, 1];
    temp_bound_N :=
        ceil((log(mu) - log(2*m*_gamma))/(log(_gamma) - log(_gamma + eps)))
        ;
    if type(temp_bound_N, realcons) then
        if evalb(0 < 2*m*_gamma/mu) then
            _pos_coeff := 2*m*_gamma/mu; mu := _pos_coeff*mu
        end if;
        temp_bound_N := ceil(
            (log(mu) - log(2*m*_gamma))/(log(_gamma) - log(_gamma + eps)));
        N_list := N_list, [temp_bound_N, _pos_coeff]
    end if;
    temp_bound_N := ceil(
        (log(M) - log(2*eps))/(log(_gamma + 2*eps) - log(_gamma + eps)));
    if type(temp_bound_N, realcons) then
        if evalb(0 < evalf(2*eps/M)) then
            _pos_coeff := 2*eps/M; M := _pos_coeff*M
        end if;
        temp_bound_N := ceil(
            (log(M) - log(2*eps))/(log(_gamma + 2*eps) - log(_gamma + eps)))
            ;
        N_list := N_list, [temp_bound_N, _pos_coeff]
    end if;
    temp_bound_N :=
        ceil((log(M) - log(2*m*_gamma))/(log(_gamma) - log(_gamma + eps)));
    if type(temp_bound_N, realcons) then
        if evalb(0 < m*_gamma/M) then
            _pos_coeff := m*_gamma/M; M := _pos_coeff*M
        end if;
        temp_bound_N := ceil(
            (log(M) - log(2*m*_gamma))/(log(_gamma) - log(_gamma + eps)));
        N_list := N_list, [temp_bound_N, _pos_coeff]
    end if;
    N, pos_coeff :=
        op(foldl((x, y) -> if y[1] < x[1] then x else y end if, N_list));
    N := ceil(1/2*N);
    g := add(term, term in map(
        g_i -> g_i*((g_i - _gamma)/(_gamma + eps))^(2*N)/pos_coeff, basis))
        ;
    N_top := N;
    N_bottom := 0;
    N_old := N_top;
    do
        N_curr := iquo(N_top + N_bottom, 2);
        g := add(term, term in map(
            g_i -> g_i*((g_i - _gamma)/(_gamma + eps))^(2*N_curr)/pos_coeff
            , basis));
        if SolveTools:-SemiAlgebraic([0 <= B_poly, 0 <= g - f], [x]) = []
        then N_top := N_curr
        else N_bottom := N_curr
        end if;
        break if N_curr = N_old;
        N_old := N_curr
    end do;
    if N_top = 0 and RegularChains:-SemiAlgebraicSetTools:-IsEmpty([],
    [B_poly, -f], [], [], R) then N := -1
    else N := N_top
    end if;
    if N = -1 then
        fd := FileTools:-Text:-Open("log_time.txt", append);
        FileTools:-Text:-WriteString(fd, cat("End: ", "averkov_lemma_7",
            " ", convert(stack_level, string), "\nTime: ",
            convert(time() - _log_time_0, string), "\n"));
        FileTools:-Text:-Close(fd);
        stack_level := stack_level - 1;
        return map(g_i -> 0, basis)
    else
        fd := FileTools:-Text:-Open("log_time.txt", append);
        FileTools:-Text:-WriteString(fd, cat("End: ", "averkov_lemma_7",
            " ", convert(stack_level, string), "\nTime: ",
            convert(time() - _log_time_0, string), "\n"));
        FileTools:-Text:-Close(fd);
        stack_level := stack_level - 1;
        return map(g_i -> ((g_i - _gamma)/(_gamma + eps))^(2*N)/pos_coeff,
            basis)
    end if
end proc

Lower_bound_poly := proc(x, poly, g)
local fd, _log_time_0, i, d_poly, c_poly, d_g, h, S, _point, G, C, eps,
_log_time_1, _log_time_2, opt_roots, _log_time_3;
    stack_level := stack_level + 1;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    _log_time_0 := time();
    FileTools:-Text:-WriteString(fd, cat("Start: ", "Lower_bound_poly", " ",
        convert(stack_level, string), "\n"));
    FileTools:-Text:-Close(fd);
    eps := 1/1000;
    stack_level := stack_level + 1;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    _log_time_1 := time();
    FileTools:-Text:-WriteString(fd, cat("Start: ",
        "Lower_bound_poly::expand(poly)", " ", convert(stack_level, string),
        "\n"));
    FileTools:-Text:-Close(fd);
    d_poly := degree(expand(poly), x);
    c_poly := coeff(poly, x^d_poly);
    fd := FileTools:-Text:-Open("log_time.txt", append);
    FileTools:-Text:-WriteString(fd, cat("End: ",
        "Lower_bound_poly::expand(poly)", " ", convert(stack_level, string),
        "\nTime: ", convert(time() - _log_time_1, string), "\n"));
    FileTools:-Text:-Close(fd);
    stack_level := stack_level - 1;
    if type(d_poly, even) and evalb(0 < evala(c_poly)) then
        fd := FileTools:-Text:-Open("log_time.txt", append);
        FileTools:-Text:-WriteString(fd, cat("End: ", "Lower_bound_poly",
            " ", convert(stack_level, string), "\nTime: ",
            convert(time() - _log_time_0, string), "\n"));
        FileTools:-Text:-Close(fd);
        stack_level := stack_level - 1;
        return [poly, 0]
    end if;
    stack_level := stack_level + 1;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    _log_time_2 := time();
    FileTools:-Text:-WriteString(fd, cat("Start: ",
        "Lower_bound_poly::SemiAlgebraic(g)", " ",
        convert(stack_level, string), "\n"));
    FileTools:-Text:-Close(fd);
    S := map(bound -> bound_info(x, bound, eps),
        SolveTools:-SemiAlgebraic([0 <= g], [x]));
    d_g := degree(expand(g), x);
    _point := S[1][1];
    fd := FileTools:-Text:-Open("log_time.txt", append);
    FileTools:-Text:-WriteString(fd, cat("End: ",
        "Lower_bound_poly::SemiAlgebraic(g)", " ",
        convert(stack_level, string), "\nTime: ",
        convert(time() - _log_time_2, string), "\n"));
    FileTools:-Text:-Close(fd);
    stack_level := stack_level - 1;
    if d_g <= d_poly then
        if type(d_poly - d_g, even) then
            h := (x - _point)^(d_poly - d_g + 2)
        else h := (x - _point)^(d_poly - d_g + 1)
        end if
    else h := 1
    end if;
    G := h*g;
    stack_level := stack_level + 1;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    _log_time_3 := time();
    FileTools:-Text:-WriteString(fd, cat("Start: ",
        "Lower_bound_poly::Minimization_problem", " ",
        convert(stack_level, string), "\n"));
    FileTools:-Text:-Close(fd);
    C := 1/2*min(seq(
        if evalb(S[i][1] = S[i][2]) then 1
        else minimize(simplify(poly/G), x = S[i][1] .. S[i][2])
        end if, i = 1 .. numelems(S)));
    fd := FileTools:-Text:-Open("log_time.txt", append);
    FileTools:-Text:-WriteString(fd, cat("End: ",
        "Lower_bound_poly::Minimization_problem", " ",
        convert(stack_level, string), "\nTime: ",
        convert(time() - _log_time_3, string), "\n"));
    FileTools:-Text:-Close(fd);
    stack_level := stack_level - 1;
    C := evalf(C);
    C := convert(C, rational);
    fd := FileTools:-Text:-Open("log_time.txt", append);
    FileTools:-Text:-WriteString(fd, cat("End: ", "Lower_bound_poly", " ",
        convert(stack_level, string), "\nTime: ",
        convert(time() - _log_time_0, string), "\n"));
    FileTools:-Text:-Close(fd);
    stack_level := stack_level - 1;
    return [poly - C*G, C*h]
end proc

findPositiveConstantAvoidExponent := proc(f, g)
local fd, _log_time_0, i, _args, curr_condition, conditions, pos_coeff, sol
;
    stack_level := stack_level + 1;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    _log_time_0 := time();
    FileTools:-Text:-WriteString(fd, cat("Start: ",
        "findPositiveConstantAvoidExponent", " ",
        convert(stack_level, string), "\n"));
    FileTools:-Text:-Close(fd);
    sol := solve({0 <= c*f - g, 0 < c}, {x}, 'parametric', 'real',
        'parameters' = {c});
    _args := op(sol);
    conditions := [];
    for i to 1/2*nops(sol) do
        if evalb(_args[2*i] = [[x = x]]) then
            conditions := [evalf(_args[2*i - 1]), op(conditions)];
            pos_coeff :=
                Optimization:-Minimize(c, map(`<=`@op, conditions))[1];
            if pos_coeff = 0 then
                fd := FileTools:-Text:-Open("log_time.txt", append);
                FileTools:-Text:-WriteString(fd, cat("End: ",
                    "findPositiveConstantAvoidExponent", " ",
                    convert(stack_level, string), "\nTime: ",
                    convert(time() - _log_time_0, string), "\n"));
                FileTools:-Text:-Close(fd);
                stack_level := stack_level - 1;
                return 1
            else
                fd := FileTools:-Text:-Open("log_time.txt", append);
                FileTools:-Text:-WriteString(fd, cat("End: ",
                    "findPositiveConstantAvoidExponent", " ",
                    convert(stack_level, string), "\nTime: ",
                    convert(time() - _log_time_0, string), "\n"));
                FileTools:-Text:-Close(fd);
                stack_level := stack_level - 1;
                return 1/convert(pos_coeff, rational, exact)
            end if
        end if;
        curr_condition := _args[2*i - 1];
        conditions := [op(0, curr_condition)(
            seq(map(v -> -evalf(v + 1/100), [op(curr_condition)]))),
            op(conditions)]
    end do;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    FileTools:-Text:-WriteString(fd, cat("End: ",
        "findPositiveConstantAvoidExponent", " ",
        convert(stack_level, string), "\nTime: ",
        convert(time() - _log_time_0, string), "\n"));
    FileTools:-Text:-Close(fd);
    stack_level := stack_level - 1;
    return 0
end proc

Last_step := proc(x, _poly, g)
local fd, _log_time_0, A, i, j, Ga, Ep, tobe_disjoint_set, N, N1, N2, poly,
_g, pos_coeff, semialgebraic_Ep_lifted, m, mu, interval, lowerbound,
upperbound, R, SemiAlg_poly, N_list, temp_bound_N, N_top, N_bottom, N_old,
N_curr;
    stack_level := stack_level + 1;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    _log_time_0 := time();
    FileTools:-Text:-WriteString(fd, cat("Start: ", "Last_step", " ",
        convert(stack_level, string), "\n"));
    FileTools:-Text:-Close(fd);
    poly := _poly;
    pos_coeff := 1;
    R := RegularChains:-PolynomialRing([x]);
    A := RegularChains:-SemiAlgebraicSetTools:-IsEmpty([], [-poly], [], [],
        R);
    if evalb(A) then
        fd := FileTools:-Text:-Open("log_time.txt", append);
        FileTools:-Text:-WriteString(fd, cat("End: ", "Last_step", " ",
            convert(stack_level, string), "\nTime: ",
            convert(time() - _log_time_0, string), "\n"));
        FileTools:-Text:-Close(fd);
        stack_level := stack_level - 1;
        return 0
    end if;
    pos_coeff := 1;
    Ga := convert(1/2*evalf(1.001*maximize(g)), rational);
    SemiAlg_poly := SolveTools:-SemiAlgebraic([poly <= 0], [x]);
    Ep := -1/2*max(map(proc(bound)
            interval := bound_info(x, bound, 0);
            lowerbound := interval[1];
            upperbound := interval[2];
            simplify(maximize(g, x = lowerbound .. upperbound))
        end proc, SemiAlg_poly));
    Ep := convert(evalf(Ep), rational);
    semialgebraic_Ep_lifted :=
        SolveTools:-SemiAlgebraic([0 <= g + 17/10*Ep], [x]);
    mu := min(map(proc(bound)
            interval := bound_info(x, bound, 0);
            lowerbound := convert(evalf(interval[1]), rational);
            upperbound := convert(evalf(interval[2]), rational);
            simplify(minimize(poly, x = lowerbound .. upperbound))
        end proc, semialgebraic_Ep_lifted));
    m := ceil(evalf(minimize(poly))) - 1;
    N_list := [];
    temp_bound_N := ceil((log(mu) - log(2*Ga))/(log(Ga) - log(Ga + Ep)));
    N_list := [op(N_list), temp_bound_N];
    temp_bound_N :=
        ceil((log(-m) - log(2*Ep))/(log(Ga + 2*Ep) - log(Ga + Ep)));
    N_list := [op(N_list), temp_bound_N];
    pos_coeff := convert(evalf(solve(
        (log(alpha*mu) - log(2*Ga))/(log(Ga) - log(Ga + Ep)) =
        (log(-alpha*m) - log(2*Ep))/(log(Ga + 2*Ep) - log(Ga + Ep)), alpha,
        'maxsols' = 1)), rational);
    N := ceil(1/2*subs(alpha = pos_coeff,
        (log(alpha*mu) - log(2*Ga))/(log(Ga) - log(Ga + Ep))));
    if N < 50 then
        N_top := N;
        N_bottom := 0;
        N_old := N_top;
        do
            N_curr := iquo(N_top + N_bottom, 2);
            _g := g*((g - Ga)/(Ga + Ep))^(2*N_curr)/pos_coeff;
            if RegularChains:-SemiAlgebraicSetTools:-IsEmpty([],
            [_g - _poly], [], [], R) then N_top := N_curr
            else N_bottom := N_curr
            end if;
            break if N_curr = N_old;
            N_old := N_curr
        end do;
        if N_top = 0 and RegularChains:-SemiAlgebraicSetTools:-IsEmpty([],
        [-_poly], [], [], R) then N := -1
        else N := N_top
        end if
    end if;
    if N = -1 then
        fd := FileTools:-Text:-Open("log_time.txt", append);
        FileTools:-Text:-WriteString(fd, cat("End: ", "Last_step", " ",
            convert(stack_level, string), "\nTime: ",
            convert(time() - _log_time_0, string), "\n"));
        FileTools:-Text:-Close(fd);
        stack_level := stack_level - 1;
        return 0
    else
        fd := FileTools:-Text:-Open("log_time.txt", append);
        FileTools:-Text:-WriteString(fd, cat("End: ", "Last_step", " ",
            convert(stack_level, string), "\nTime: ",
            convert(time() - _log_time_0, string), "\n"));
        FileTools:-Text:-Close(fd);
        stack_level := stack_level - 1;
        return ((g - Ga)/(Ga + Ep))^(2*N)/pos_coeff
    end if
end proc

Sqf := proc(x, poly)
local fd, _log_time_0, L, h, f_u, i;
    stack_level := stack_level + 1;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    _log_time_0 := time();
    FileTools:-Text:-WriteString(fd,
        cat("Start: ", "Sqf", " ", convert(stack_level, string), "\n"));
    FileTools:-Text:-Close(fd);
    L := sqrfree(poly);
    h := 1;
    f_u := L[1];
    for i to numelems(L[2]) do
        if type(L[2][i][2], even) then h := h*L[2][i][1]^L[2][i][2]
        else h := h*L[2][i][1]^(L[2][i][2] - 1); f_u := f_u*L[2][i][1]
        end if
    end do;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    FileTools:-Text:-WriteString(fd, cat("End: ", "Sqf", " ",
        convert(stack_level, string), "\nTime: ",
        convert(time() - _log_time_0, string), "\n"));
    FileTools:-Text:-Close(fd);
    stack_level := stack_level - 1;
    return [f_u, h]
end proc

find_certificate := proc(poly, QM_list, x)
local fd, _log_time_0, Sqm, Hs, f1, g, A, B, H2, f2, H3, f3, H4, F, s1, s2,
certificates, R;
    stack_level := stack_level + 1;
    fd := FileTools:-Text:-Open("log_time.txt", append);
    _log_time_0 := time();
    FileTools:-Text:-WriteString(fd, cat("Start: ", "find_certificate", " ",
        convert(stack_level, string), "\n"));
    FileTools:-Text:-Close(fd);
    R := RegularChains:-PolynomialRing([x]);
    Hs := Fixing_points(poly, QM_list[1], QM_list[2], x);
    f1 := poly - QM_list[1]*Hs[1] - QM_list[2]*Hs[2];
    F := Sqf(x, f1);
    f1 := simplify(F[1]);
    if evalb(
    RegularChains:-SemiAlgebraicSetTools:-IsEmpty([], [-f1], [], [], R))
    then
        s1 := Hs[1];
        s2 := Hs[2];
        certificates := [poly - s1*QM_list[1] - s2*QM_list[2], s1, s2];
        fd := FileTools:-Text:-Open("log_time.txt", append);
        FileTools:-Text:-WriteString(fd, cat("End: ", "find_certificate",
            " ", convert(stack_level, string), "\nTime: ",
            convert(time() - _log_time_0, string), "\n"));
        FileTools:-Text:-Close(fd);
        stack_level := stack_level - 1;
        return certificates
    end if;
    g := bound_poly(QM_list[1], QM_list[2], x);
    H2 := averkov_lemma_7(x, f1, QM_list, g[1]);
    f2 := f1 - QM_list[1]*H2[1] - QM_list[2]*H2[2];
    H3 := Lower_bound_poly(x, f2, g[1]);
    f3 := f2 - g[1]*H3[2];
    H4 := Last_step(x, f3, g[1]);
    s1 := Hs[1] + (H2[1] + (H3[2] + H4)*g[2])*F[2];
    s2 := Hs[2] + (H2[2] + (H3[2] + H4)*g[3])*F[2];
    certificates := [poly - s1*QM_list[1] - s2*QM_list[2], s1, s2];
    fd := FileTools:-Text:-Open("log_time.txt", append);
    FileTools:-Text:-WriteString(fd, cat("End: ", "find_certificate", " ",
        convert(stack_level, string), "\nTime: ",
        convert(time() - _log_time_0, string), "\n"));
    FileTools:-Text:-Close(fd);
    stack_level := stack_level - 1;
    return certificates
end proc

bitsizeI := proc(integer)
    if integer = 0 then return 1 end if;
    return ceil(evalf(log(abs(integer), 2))) + 1
end proc

bitsizeR := proc(rat)
local d;
    d := denom(rat);
    if d = 1 then return bitsizeI(numer(rat))
    else return bitsizeI(numer(rat)) + bitsizeI(denom(rat))
    end if
end proc

bitsizeP := proc(poly, x)
local _sum;
    return add(_sum, _sum in map(bitsizeR, [coeffs(collect(poly, x))]))
end proc

  "/Users/typesarespaces/Documents/GithubProjects/phd-thesis/Documents/Seminars/BeihangUniversity-Fall2021/Weifeng-Notes/Weifeng-Certificates/tests"

                            "/Users/typesarespaces"

Warning, (in monshom) `i` is implicitly declared local
|multivsos/multivsos.mm:20|
monshom := proc(n, d)
local l1, i;
    l1 := [seq(1, i = 1 .. n)];
    return map(_c -> _c - l1, combinat:-composition(n + d, n))
end proc

Warning, (in revmons) `i` is implicitly declared local
|multivsos/multivsos.mm:26|
revmons := proc(n, d)
local i;
    if d = 0 then return [[seq(0, i = 1 .. n)]]
    else return [op(monshom(n, d)), op(revmons(n, d - 1))]
    end if
end proc

Warning, (in revmons2) `i` is implicitly declared local
|multivsos/multivsos.mm:33|
revmons2 := proc(n, d)
local mons0, i;
    mons0 := [[seq(0, i = 1 .. n)]];
    return [seq(op(monshom(n, d - i + 1)), i = 1 .. d), mons0]
end proc

     monspt := proc(n, d) return ListTools:-Reverse(revmons(n, d)) end proc

Warning, (in mymons) `m` is implicitly declared local
|multivsos/multivsos.mm:48|
Warning, (in mymons) `v` is implicitly declared local
|multivsos/multivsos.mm:48|
Warning, (in anonymous procedure within mons) `i` is implicitly declared local
|multivsos/multivsos.mm:54|
mons := proc(n, d, X, ms::list := monspt(n, d))
    return map(a -> local i; mul(X[i]^a[i], i = 1 .. n), ms)
end proc

Warning, (in support) `m` is implicitly declared local
|multivsos/multivsos.mm:62|
support := proc(f, X, monslist)
local cf, idxf, monsf, m;
    cf := coeffs(f, X, 'monsf');
    monsf := [monsf];
    idxf := seq(ListTools:-Search(m, monslist), m in monsf);
    if member(0, [idxf]) then lprint(m); error "Bug in list of monomials"
    end if;
    return [cf], [idxf]
end proc

Warning, (in dense_perturbation) `m` is implicitly declared local
|multivsos/multivsos.mm:68|
   dense_perturbation := proc(ms) local m; return add(m^2, m in ms) end proc

sos2sdp := proc(r, X, relaxorder, mspt, msptk, ms, msk, rc, ridx, e,
precSVD::integer := 40, precSDP::integer := 200, epsStar::integer := 30,
precOut::integer := 30, precIn::integer := 100, gmp::boolean := false,
algo::integer := 1, g::list := [], gc::list := [], gidx::list := [])
local start_idx, sub_idx, nvars, zero, d, k, n, ng, r0, msdp, nsdp, nblock,
fd, rList, i, rfloat, j, lowerbnd, eigs, eivs, eigs2, eivs2, Y, Yrat,
absorb_tbl, m, absorb_PP, nsdpg, nsdponeg, gic, giidx, ni, ig, igc, gifloat,
mgi, eigsi, eivsi, nl, yMatText, objValPrimalText, mski, epsList, alg,
msptgi, di, msptki;
    k := relaxorder;
    d := 2*k;
    n := nops(X);
    ng := nops(g);
    zero := [seq(0, i = 1 .. n)];
    msdp := nops(mspt);
    nsdp := nops(msk);
    nblock := 1 + ng;
    if FileTools:-Exists("multivsos/in.dat-s") then
        FileTools:-Remove("multivsos/in.dat-s")
    end if;
    fd := fopen("multivsos/in.dat-s", WRITE, TEXT);
    rList := Array([seq(0, i = 1 .. msdp)]);
    for i to nops(rc) do rList[ridx[i]] := rc[i] end do;
    if mspt[1] = zero then sub_idx := 1; nvars := msdp - 1; r0 := rList[1]
    else
        sub_idx := ListTools:-Search(2*mspt[1], mspt) - 1;
        for j from 2 to nsdp do
            k := ListTools:-Search(mspt[1] + mspt[j], mspt);
            sub_idx := min(sub_idx, k - 1)
        end do;
        nvars := msdp - sub_idx;
        r0 := 0
    end if;
    writeline(fd, convert(nvars, string));
    writeline(fd, convert(nblock, string));
    fprintf(fd, "%d ", nsdp);
    nsdpg := locmatsizes(g, k, n);
    for ni in nsdpg do fprintf(fd, "%d ", ni) end do;
    fprintf(fd, "\n");
    rfloat := convert(rList, float, precIn);
    if mspt[1] = zero then
        for i from 2 to msdp do fprintf(fd, "%.*f ", precIn, rfloat[i])
        end do
    else
        for i to nvars do fprintf(fd, "%.*f ", precIn, rfloat[i + sub_idx])
        end do
    end if;
    fprintf(fd, "\n");
    if mspt[1] = zero then
        writeline(fd, "0 1 1 1 -1");
        for j from 2 to nsdp do fprintf(fd, "%d 1 %d %d 1\n", j - 1, 1, j)
        end do;
        for i from 2 to nsdp do
            for j from i to nsdp do
                k := ListTools:-Search(mspt[i] + mspt[j], mspt);
                fprintf(fd, "%d 1 %d %d 1\n", k - 1, i, j)
            end do
        end do
    else
        for i to nsdp do
            for j from i to nsdp do
                k := ListTools:-Search(mspt[i] + mspt[j], mspt);
                fprintf(fd, "%d 1 %d %d 1\n", k - sub_idx, i, j)
            end do
        end do
    end if;
    for ig to ng do
        gic := gc[ig];
        giidx := gidx[ig];
        for igc to nops(gic) do
            msptgi := monspt(n, 1/2*d - ceil(1/2*degree(g[ig])));
            mgi := mspt[giidx[igc]];
            gifloat := convert(gic[igc], float, precIn);
            if mgi = zero then
                fprintf(fd, "0 %d 1 1 %.*f\n", ig + 1, precIn, -gifloat);
                for j from 2 to nsdpg[ig] do
                    fprintf(fd, "%d %d 1 %d %.*f\n", j - 1, ig + 1, j,
                        precIn, gifloat)
                end do;
                for i from 2 to nsdpg[ig] do
                    for j from i to nsdpg[ig] do
                        k := ListTools:-Search(msptgi[i] + msptgi[j] + mgi,
                            mspt);
                        fprintf(fd, "%d %d %d %d %.*f\n", k - 1, ig + 1, i,
                            j, precIn, gifloat)
                    end do
                end do
            else
                for i to nsdpg[ig] do
                    for j from i to nsdpg[ig] do
                        k := ListTools:-Search(msptgi[i] + msptgi[j] + mgi,
                            mspt);
                        fprintf(fd, "%d %d %d %d %.*f\n", k - sub_idx,
                            ig + 1, i, j, precIn, gifloat)
                    end do
                end do
            end if
        end do
    end do;
    absorb_tbl := table([seq(0, i = 1 .. msdp)]);
    for i to nsdp do
        for j from i to nsdp do
            m := mspt[i] + mspt[j];
            if not_even(m) then
                k := ListTools:-Search(m, mspt); absorb_tbl[k] := i
            end if
        end do
    end do;
    absorb_PP := table([seq([], i = 1 .. msdp)]);
    for i to nsdp do
        k := ListTools:-Search(2*mspt[i], mspt);
        absorb_PP[k] := [op(absorb_PP[k]), i, i];
        for j from i + 1 to nsdp do
            m := mspt[i] + mspt[j];
            k := ListTools:-Search(m, mspt);
            absorb_PP[k] := [op(absorb_PP[k]), i, j, j, i]
        end do
    end do;
    fclose(fd);
    if FileTools:-Exists("multivsos/out.dat-s") then
        FileTools:-Remove("multivsos/out.dat-s")
    end if;
    if FileTools:-Exists("multivsos/out.mm") then
        FileTools:-Remove("multivsos/out.mm")
    end if;
    if not gmp then
        ssystem("sdpa -ds multivsos/in.dat-s -o multivsos/out.dat-s -p m\
            ultivsos/param.sdpa > /dev/null")
    else
        write_param(precSDP, epsStar, epsStar);
        ssystem("sdpa_gmp -ds multivsos/in.dat-s -o multivsos/out.dat-s \
            -p multivsos/my_param_gmp.sdpa > /dev/null")
    end if;
    fd := fopen("multivsos/out.dat-s", READ, TEXT);
    nl := "";
    yMatText := "yMat := ";
    do
        nl := readline(fd);
        if SearchText("objValPrimal", nl) = 1 then
            objValPrimalText :=
                StringTools[RegSubs]("objValPrimal = (.*)" = "\\1", nl);
            break
        end if
    end do;
    do nl := readline(fd); break if SearchText("yMat", nl) = 1 end do;
    do
        nl := readline(fd);
        break if 0 < SearchText("main loop", nl);
        yMatText := cat(yMatText, nl)
    end do;
    fclose(fd);
    yMatText := StringTools[SubstituteAll](yMatText, "{", "[");
    yMatText := StringTools[SubstituteAll](yMatText, "}", "]");
    yMatText := StringTools[SubstituteAll](yMatText, "][", "],[");
    fd := fopen("multivsos/out.mm", WRITE, TEXT);
    fprintf(fd, "objValPrimal := %s:\n%s:", objValPrimalText, yMatText);
    fd := fclose(fd);
    read "multivsos/out.mm";
    printf("Numerical SDP ended\n");
    lowerbnd := r0 + convert(objValPrimal, rational, exact);
    printf("Lower bound: %f\n", evalf(lowerbnd));
    eigs := Array([]);
    eivs := Array([]);
    nsdponeg := [nsdp, op(nsdpg)];
    alg := 1;
    for j to 1 + ng do
        i := ng + 2 - j;
        Y := Matrix(yMat[i]);
        if 1 < i then
            di := 1/2*d - ceil(1/2*degree(g[i - 1]));
            msptki := monspt(n, di);
            mski := mons(n, di, X, msptki)
        else mski := msk
        end if;
        if algo = 1 or 1 < i then Yrat := Matrix(Y)
        else
            if 30 <= precOut then Y := convert(Y, rational, exact)
            else Y := convert(Y, rational, precOut)
            end if;
            Y := 1/2*Y + 1/2*LinearAlgebra:-Transpose(Y);
            epsList := epsPP(convert(eigs, list), convert(eivs, list), r, g,
                nsdpg, X, ms, msdp);
            Yrat := absorber_PP(Y, epsList, absorb_PP, nsdp, msptk, mspt)
        end if;
        if (algo = 2 or algo = 3) and i = 1 then alg := algo end if;
        eigsi, eivsi := eigseivs(Yrat, X, mski, precSVD, precOut, alg, e);
        eigs := ArrayTools:-Concatenate(1, eigsi, eigs);
        eivs := ArrayTools:-Concatenate(1, eivsi, eivs)
    end do;
    return convert(eigs, list), convert(eivs, list), lowerbnd, absorb_tbl,
        nsdponeg
end proc

Warning, (in absorber_PP) `im` is implicitly declared local
|multivsos/multivsos.mm:350|
write_param := proc(precSDP, epsStar, epsDash)
local fd;
    fd := fopen("multivsos/my_param_gmp.sdpa", WRITE, TEXT);
    fprintf(fd, "300\tunsigned int maxIteration;\n");
    fprintf(fd, "1.0E-%d\t\t double 0.0 < epsilonStar;\n", epsStar);
    fprintf(fd, "1.0E5   double 0.0 < lambdaStar;\n");
    fprintf(fd, "2.0   \tdouble 1.0 < omegaStar;\n");
    fprintf(fd, "-1.0E5  double lowerBound;\n");
    fprintf(fd, "1.0E5   double upperBound;\n");
    fprintf(fd, "0.1     double 0.0 <= betaStar <  1.0;\n");
    fprintf(fd,
        "0.3     double 0.0 <= betaBar  <  1.0, betaStar <= betaBar;\n");
    fprintf(fd, "0.9     double 0.0 < gammaStar  <  1.0;\n");
    fprintf(fd, "1.0E-%d\t\t double 0.0 < epsilonDash;\n", epsDash);
    fprintf(fd, "%d     precision\n", precSDP);
    fprintf(fd, "%%+50.40Fe     char* \t xPrint \t   (default %%+8.3e, \t\
            NOPRINT skips printout) \n");
    fprintf(fd, "%%+50.40Fe     char* \t XPrint \t   (default %%+8.3e, \t\
            NOPRINT skips printout) \n");
    fprintf(fd, "%%+50.40Fe     char* \t YPrint \t   (default %%+8.3e, \t\
            NOPRINT skips printout) \n");
    fprintf(fd, "%%+50.40Fe     char* \t infPrint \t (default %%+10.16e, \
        \t  NOPRINT skips printout) \n");
    fclose(fd)
end proc

checkrational := proc(U)
local v;
    for v in U do
        if not type(convert(v, rational), realcons) then
            error "Complex Cholesky factor, retry with gmp = true or mor\
                e SDP precision"
        end if
    end do;
    return
end proc

eigseivs := proc(Yrat, X, ms, precSVD, precOut, algo, e)
local v, msvec, eigs, eivs, U, S, V, Ysvd, SVD, ti, tcmp;
    SVD := false;
    msvec := Vector(ms);
    ti := time();
    printf("Cholesky decomposition ... ");
    S := LinearAlgebra:-IdentityMatrix(nops(ms));
    if algo = 1 or algo = 3 then Digits := precSVD end if;
    if algo < 3 then
        U := LinearAlgebra:-LUDecomposition(Yrat, method = 'Cholesky')
    else
        U :=
            LinearAlgebra:-LUDecomposition(Yrat - e*S, method = 'Cholesky')
    end if;
    checkrational(U);
    tcmp := time() - ti;
    printf("done.\n");
    eigs := LinearAlgebra:-Diagonal(S);
    eivs := LinearAlgebra:-Transpose((LinearAlgebra:-Transpose(msvec)) . U)
        ;
    Digits := 10;
    Ysvd := U . S . (V^%T);
    if 30 <= precOut then
        eigs := convert(eigs, rational, exact);
        eivs := map(_e -> convert(_e, rational, exact), eivs)
    else
        eigs := convert(eigs, rational, precOut);
        eivs := map(_e -> convert(_e, rational, precOut), eivs)
    end if;
    return eigs, eivs
end proc

     not_even := proc(m) return has(1, map(_c -> irem(_c, 2), m)) end proc

decomp_mon := proc(a, n)
local c, b, degb, cm, cnt, i;
    c := map(_c -> iquo(_c, 2), a);
    b := a - 2*c;
    degb := ceil(1/2*add(i, i in b));
    cm := [seq(0, i = 1 .. n)];
    cnt := 0;
    for i to n do
        if b[i] = 1 then cm[i] := b[i]; cnt := cnt + 1 end if;
        break if degb <= cnt
    end do;
    return c, cm, b - cm
end proc

NP_PolyhedralSets := proc(f, X, mspt, ms)
local cf, idxf, msptf, ps;
    cf, idxf := support(f, X, ms);
    msptf := map(_idx -> mspt[_idx], idxf);
    ps := PolyhedralSets:-PolyhedralSet(msptf);
    return PolyhedralSets:-ConvexHull(ps)
end proc

absorber := proc(u, X, e, even_mons, ms, mspt, absorb_tbl)
local i, j, k, ucoeffs, uidx, uc, err_list, err, m, bad_m, n, c, cm, cp,
cfs, sqs, n1, m1, m2, k1, k2;
    ucoeffs, uidx := support(u, X, ms);
    n := nops(X);
    err_list := Array([seq(e, i = 1 .. nops(even_mons))]);
    cfs := [];
    sqs := [];
    for i to nops(ucoeffs) do
        uc := ucoeffs[i];
        bad_m := mspt[uidx[i]];
        if not_even(bad_m) then
            k := ListTools:-Search(bad_m, mspt);
            m1 := mspt[absorb_tbl[k]];
            m2 := bad_m - m1;
            cfs := [op(cfs), 1/2*abs(uc)];
            sqs := [op(sqs), mul(X[i]^m1[i], i = 1 .. n)
                 + sign(uc)*mul(X[i]^m2[i], i = 1 .. n)];
            k1 := ListTools:-Search(2*m1, even_mons);
            k2 := ListTools:-Search(2*m2, even_mons);
            err_list[k1] := err_list[k1] - 1/2*abs(uc);
            err_list[k2] := err_list[k2] - 1/2*abs(uc)
        else
            k := ListTools:-Search(bad_m, even_mons);
            err_list[k] := err_list[k] + uc
        end if
    end do;
    err_list := convert(err_list, list);
    cfs := [op(cfs), op(err_list)];
    sqs := [op(sqs), seq(mul(X[i]^(1/2*m[i]), i = 1 .. n), m in even_mons)]
        ;
    return cfs, sqs
end proc

old_absorber := proc(u, X, e, even_mons, ms, mspt, even_mons_n1, absorb_tbl)
local i, j, k, ucoeffs, uidx, uc, err_list, err, m, bad_m, n, c, cm, cp,
cfs, sqs, n1, m1, m2;
    printf("\nu = ");
    lprint(evalf(u));
    ucoeffs, uidx := support(u, X, ms);
    n := nops(X);
    err_list := [];
    for j to nops(even_mons) do
        m := even_mons[j];
        n1 := even_mons_n1[j];
        err := e;
        for i to nops(ucoeffs) do
            uc := ucoeffs[i];
            bad_m := mspt[uidx[i]];
            if m = bad_m then err := err + uc
            else if has(bad_m, n1) then err := err - 1/2*abs(uc) end if
            end if
        end do;
        err_list := [op(err_list), err]
    end do;
    printf("\nerr list = ");
    cfs := [op(err_list)];
    sqs := [seq(mul(X[i]^(1/2*m[i]), i = 1 .. n), m in even_mons)];
    for i to nops(ucoeffs) do
        uc := ucoeffs[i];
        bad_m := mspt[uidx[i]];
        if not_even(bad_m) then
            k := ListTools:-Search(bad_m, mspt);
            m1 := mspt[absorb_tbl[k]];
            m2 := bad_m - m1;
            printf("\n");
            lprint(bad_m);
            lprint(m1);
            lprint(m2);
            cfs := [op(cfs), 1/2*abs(uc)];
            sqs := [op(sqs), mul(X[i]^m1[i], i = 1 .. n)
                 + sign(uc)*mul(X[i]^m2[i], i = 1 .. n)]
        end if
    end do;
    return cfs, sqs
end proc

Warning, (in relaxordermin) `gi` is implicitly declared local
|multivsos/multivsos.mm:625|
Warning, (in locmatsizes) `gi` is implicitly declared local
|multivsos/multivsos.mm:629|
locmatsizes := proc(g, k, n)
local gi;
    return
        [seq(combinat:-binomial(n + k - ceil(1/2*degree(gi)), n), gi in g)]
end proc

Warning, (in preliminary_test_negativity) `x` is implicitly declared local
|multivsos/multivsos.mm:651|
Warning, (in permutepoly) `i` is implicitly declared local
|multivsos/multivsos.mm:678|
Warning, (in is_homogeneous) `v` is implicitly declared local
|multivsos/multivsos.mm:708|
Warning, (in multivsos) `i` is implicitly declared local
|multivsos/multivsos.mm:719|
Warning, (in multivsos_internal) `m` is implicitly declared local
|multivsos/multivsos.mm:815|
multivsos_internal := proc(f, {algo::integer := 1, denom::boolean := false,
epsStar::integer := 5, epsilon::integer := 8, glist::list := [],
gmp::boolean := false, iter_prec::integer := 0, precIn::integer := 100,
precOut::integer := 30, precSDP::integer := 100, precSVD::integer := 40,
relaxorder::integer := 0})
local p, d, mspt, ms, rc, ridx, pc, pidx, ng, gc, gidx, gic, giidx, S, s, c,
q, n, k, t, e, r, l, a, s1, s2, u, v, i, j, sqs, cfs, sos, rfloat, eigs,
eigsg, eigsgi, soslist, soslistg, soslistgi, sumsos, cnd, maxq, obj_plus_r0,
card_nk, even_mons, err_list, err, msptk, msk, absorb_tbl, rmin, nsdponeg,
idx, oneg, idxi, g, X, ti, tf, gi, cg, use_convex, newf, hf, vars,
deg_denom, mspt_denom, ms_denom, msptk_denom, msk_denom, sigma1, bitsos, m;
    use_convex := true;
    ti := time[real]();
    c := max(map(_c -> abs(_c), coeffs(expand(f))));
    c := max(c, 1);
    p := f/c;
    X := [op(indets([p, op(glist)]))];
    g := [];
    ng := nops(glist);
    for i to ng do
        gi := expand(glist[i]);
        cg := max(map(_c -> abs(_c), coeffs(expand(gi))));
        cg := 1;
        g := [op(g), gi/cg]
    end do;
    n := nops(X);
    rmin := relaxordermin([p, op(g)]);
    d := 2*max(relaxorder, rmin);
    k := ceil(1/2*d);
    mspt := monspt(n, d);
    card_nk := combinat:-binomial(n + k, n);
    msptk := monspt(n, k);
    ms := mons(n, d, X, mspt);
    lprint(X);
    printf("Polynomial system with %d variables and degree at most %d\n", n,
        d);
    printf("Size of monomial basis = %d\n", nops(msptk));
    printf("Number of moment variables = %d\n", nops(ms));
    if ng = 0 then
        mspt, msptk := truncate_withNP(p, X, mspt, msptk, ms, true);
        printf("\nAfter Newton polytope reduction:\n");
        printf("Size of monomial basis = %d\n", nops(msptk));
        printf("Number of moment variables = %d\n", nops(mspt))
    end if;
    if ng = 1 and denom then
        deg_denom := d - degree(glist[1]);
        mspt_denom := monspt(n, deg_denom);
        ms_denom := mons(n, deg_denom, X, mspt_denom);
        msptk_denom := monspt(n, 1/2*deg_denom);
        msk_denom := mons(n, 1/2*deg_denom, X, msptk_denom);
        sigma1 := expand(add(m, m in msk_denom)^2);
        mspt, msptk :=
            truncate_withNP(glist[1]*sigma1, X, mspt, msptk, ms, true);
        printf("\nAfter Newton polytope reduction:\n");
        printf("Size of monomial basis = %d\n", nops(msptk));
        printf("Number of moment variables = %d\n", nops(mspt))
    end if;
    ms := mons(n, d, X, mspt);
    msk := mons(n, k, X, msptk);
    if algo = 1 or algo = 3 then
        t := dense_perturbation(msk);
        even_mons := 2*msptk;
        e := 1/2^epsilon
    else e := 0; t := 0
    end if;
    r := expand(p - e*t);
    pc, pidx := support(expand(p), X, ms);
    if r = 0 then rc := [0]; ridx := [1]
    else rc, ridx := support(r, X, ms)
    end if;
    gc := [];
    gidx := [];
    for i to ng do
        gic, giidx := support(g[i], X, ms);
        gc := [op(gc), gic];
        gidx := [op(gidx), giidx]
    end do;
    printf("SDPA starts...\n");
    if algo = 3 then
        eigs, soslist, obj_plus_r0, absorb_tbl, nsdponeg := sos2sdp(p, X, k,
            mspt, msptk, ms, msk, pc, pidx, e, precSVD, precSDP, epsStar,
            precOut, precIn, gmp, algo, g, gc, gidx)
    else
        eigs, soslist, obj_plus_r0, absorb_tbl, nsdponeg := sos2sdp(r, X, k,
            mspt, msptk, ms, msk, rc, ridx, e, precSVD, precSDP, epsStar,
            precOut, precIn, gmp, algo, g, gc, gidx)
    end if;
    idx := 0;
    sumsos := obj_plus_r0;
    oneg := [1, op(g)];
    for i to ng + 1 do
        idxi := idx + nsdponeg[i];
        sumsos :=
            sumsos + oneg[i]*sum(eigs[j]*soslist[j]^2, j = idx + 1 .. idxi)
            ;
        idx := idxi
    end do;
    if algo = 1 or algo = 3 then
        u := expand(r - sumsos + obj_plus_r0);
        try cfs, sqs := absorber(u, X, e, even_mons, ms, mspt, absorb_tbl)
        catch "invalid subscript selector":
            lprint("Invalid absorbtion table, certainly a Newton polytop\
                e issue");
            return false
        end try;
        nsdponeg[1] := nsdponeg[1] + nops(sqs)
    else u := 0; cfs := []; sqs := []
    end if;
    err := expand(u + e*t - add(cfs[i]*sqs[i]^2, i = 1 .. nops(sqs)));
    cfs := [op(cfs), op(eigs)];
    sqs := [op(sqs), op(soslist)];
    sos := [];
    for i to nops(sqs) do sos := [op(sos), c*cfs[i], sqs[i]] end do;
    if soscheck1(f, sos, nsdponeg, g) = 1 then
        printf("\n Exact sum of squares decomposition\n");
        tf := time[real]() - ti;
        bitsos := BitSizePolSeq(sos, X);
        printf("bitsize= %d\n", bitsos);
        printf("time= %fsecs\n", tf);
        return {sos, nsdponeg, tf, bitsos}
    else
        if 2 <= iter_prec then printf("\n Aborting \n"); return {false}
        end if;
        printf("\n***************************\n");
        printf("****   RECURSIVE CALL  ****\n");
        lprint(2*epsilon, 2*precSVD, 2*precSDP, 2*epsStar, 2*precOut,
            2*precIn);
        printf("***************************\n\n");
        if epsilon <= 16 then
            return multivsos_internal(f, ':-epsilon' = 2*epsilon,
                ':-precSVD' = 2*precSVD, ':-precSDP' = 2*precSDP,
                ':-epsStar' = 2*epsStar, ':-precOut' = 2*precOut,
                ':-precIn' = 2*precIn, ':-gmp' = gmp, ':-algo' = algo,
                ':-glist' = glist, ':-relaxorder' = relaxorder,
                ':-denom' = denom, ':-iter_prec' = iter_prec + 1)
        else
            return multivsos_internal(f, ':-epsilon' = 2*epsilon,
                ':-precSVD' = 2*precSVD, ':-precSDP' = 2*precSDP,
                ':-epsStar' = 2*epsStar, ':-precOut' = 2*precOut,
                ':-precIn' = 2*precIn, ':-gmp' = true, ':-algo' = algo,
                ':-glist' = glist, ':-relaxorder' = relaxorder,
                ':-denom' = denom, ':-iter_prec' = iter_prec + 1)
        end if
    end if;
    tf := time[real]() - ti;
    printf("bitsize= %d\n", BitSizePolSeq(sos, X));
    printf("time= %fsecs\n", tf)
end proc

soscheck1 := proc(f, sos, nsdponeg, g::list := [])
local s, i, j, idx, idxi, oneg;
    oneg := [1, op(g)];
    s := 0;
    idx := 0;
    for i to nops(g) + 1 do
        idxi := idx + nsdponeg[i];
        for j from idx + 1 to idxi do
            if sos[2*j - 1] < 0 then
                printf("Negative number => invalid sum of squares decomp\
                    osition\n");
                return 0;
                error "Negative number => invalid sum of squares decompo\
                    sition"
            else s := s + oneg[i]*sos[2*j - 1]*sos[2*j]^2
            end if
        end do;
        idx := idxi
    end do;
    if not (expand(f - s) = 0) then
        printf("Inexact sum of squares decomposition");
        return 0;
        error "Inexact sum of squares decomposition"
    else return 1
    end if
end proc

Warning, (in BitSizeSos) `p` is implicitly declared local
|multivsos/multivsos.mm:996|
BitSizeSos := proc(sos, X)
local p;
    return add(BitSizePol(p[1], X) + BitSizePolQuadr(p[2], X), p in sos)
end proc

BitSizePolQuadr := proc(q, X)
    return BitRat(q[1]) + BitSizePol(q[2], X) + BitRat(q[3])
end proc

Warning, (in BitSizePolSeq3) `p` is implicitly declared local
|multivsos/multivsos.mm:1004|
BitSizePolSeq3 := proc(listpol, X)
local p;
    return add(BitSizePol(p[1], X) + BitSizePolSeq(p[2], X), p in listpol)
end proc

Warning, (in BitSizePolSeq) `p` is implicitly declared local
|multivsos/multivsos.mm:1008|
BitSizePolSeq := proc(listpol, X)
local p;
    return add(BitSizePol(p, X), p in listpol)
end proc

BitSizePol := proc(p, X)
local res;
    res := [coeffs(expand(p), X)]; return BitSizeSeq(res)
end proc

Warning, (in BitSizeSeq) `c` is implicitly declared local
|multivsos/multivsos.mm:1018|
     BitSizeSeq := proc(l) local c; return add(BitRat(c), c in l) end proc

BitRat := proc(r)
local n, d, res, rs;
    if type(r, rational) then rs := r else rs := r^2 end if;
    if rs = 0 then return 1 end if;
    n, d := abs(numer(rs)), abs(denom(rs));
    if d = 1 then res := ilog2(n) + 1
    else res := ilog2(n) + ilog2(d) + 2
    end if;
    return res
end proc

benchRAGLib := proc(f, g::list := [])
local sys, i, ti, tf, sol;
    ti := time[real]();
    sys := [f < 0];
    for i to nops(g) do sys := [op(sys), expand(-g[i]) < 0] end do;
    lprint(sys);
    sol := RAG:-HasRealSolutions(sys);
    tf := time[real]() - ti;
    printf("time= %esecs\n", tf);
    return sol
end proc

benchSamplePoints := proc(f, g::list := [])
local sys, vars, R, P, i, ti, tf;
    ti := time[real]();
    sys := [f < 0];
    for i to nops(g) do sys := [op(sys), 0 <= g[i]] end do;
    vars := [op(indets(f))];
    R := RegularChains:-PolynomialRing(vars);
    P := SamplePoints(sys, R);
    tf := time[real]() - ti;
    printf("time= %esecs\n", tf);
    return P
end proc

printms := proc(ms)
local i;
    for i to nops(ms) do printf("%d ", i); lprint(ms[i]) end do; return
end proc

extractCertificates := proc(out)
local i, j, certificates, sos, rlist, oneWithBasis, s, idx, idxi;
    if not (out[1] = false) then
        certificates := [];
        s := 0;
        idx := 0;
        sos := out[4];
        rlist := out[3];
        oneWithBasis := [1, op(basis)];
        for i to nops(basis) + 1 do
            certificates := [op(certificates), 0];
            idxi := idx + rlist[i];
            for j from 1 + idx to idxi do
                s := s + oneWithBasis[i]*sos[2*j - 1]*sos[2*j]^2;
                certificates[i] :=
                    sos[2*j]^2*sos[2*j - 1] + certificates[i]
            end do;
            idx := idxi
        end do;
        return true, certificates, s
    end if;
    return false, [0], 0
end proc

checkRealCertify := proc(f, basis, test_name)
local st, out, isvalid, certificates, s, h;
    printf("\n>> Test\n%s\n", test_name);
    printf(">> input polynomial\n%s\n", convert(f, string));
    printf(">> basis\n%s\n", convert(basis, string));
    st := time();
    out := multivsos_internal(f, epsilon = 1, precSVD = 10, precSDP = 200,
        precOut = 30, precIn = 100, gmp = true, algo = 2, glist = basis,
        relaxorder = 1, denom = false);
    isvalid, certificates, s := extractCertificates(out);
    if isvalid then
        printf(">> Time taken\n%f\n", time() - st);
        lprint(">> Sums of squares multipliers", certificates);
        printf(">> Degree size\n%s\n", convert(foldl(
            (_x, _y) -> max(_x, _y), 0,
            op(map(h -> quickdegree(h, x), certificates))), string));
        return
    else
        printf(">> RealCertify couldnt find certificates\n%f\n",
            time() - st)
    end if
end proc

weifengExamples := proc()
local x, f, g_1, g_2, G;
    f := -x*(x - 1)^3*(x - 2)^2;
    g_1 := x*(x - 1/2)*(x - 1)^2*(x - 2);
    g_2 := -x*(x - 1)*(x - 2);
    G := [g_1, g_2];
    try checkWeifeng(f, G, x, "Test 1")
    catch: printf(">> Weifeng approach fails Test 1\n")
    end try;
    try checkRealCertify(f, G, "Test 1")
    catch: printf(">> RealCertify fails Test 1\n")
    end try;
    f := -x*(x - 3);
    g_1 := x*(x - 1)*(x - 2)*(x - 3);
    g_2 := -x*(x - 1)*(x - 2)*(x - 3);
    G := [g_1, g_2];
    try checkWeifeng(f, G, x, "Test 2")
    catch: printf(">> Weifeng approach fails Test 2\n")
    end try;
    try checkRealCertify(f, G, "Test 2")
    catch: printf(">> RealCertify fails Test 2\n")
    end try;
    f := -x + 10;
    g_1 := (x - 2)^3;
    g_2 := -(x - 2)^3;
    G := [g_1, g_2];
    try checkRealCertify(f, G, "Test 3")
    catch: printf(">> RealCertify fails Test 3\n")
    end try;
    checkWeifeng(f, G, x, "Test 3");
    try checkRealCertify(f, G, "Test 3")
    catch: printf(">> RealCertify fails Test 3\n")
    end try
end proc

weifengExamples1 := proc()
local x, f, g_1, g_2, G;
    f := -x*(x - 1)^3*(x - 2)^2;
    g_1 := x*(x - 1/2)*(x - 1)^2*(x - 2);
    g_2 := -x*(x - 1)*(x - 2);
    G := [g_1, g_2];
    try checkWeifeng(f, G, x, "Test 1")
    catch: printf(">> Weifeng approach fails Test 1\n")
    end try
end proc

realCertifyIssues1 := proc()
local x;
    try
        checkRealCertify(x + 1, [x*(x - 1)*(x - 2), -x*(x - 1)*(x - 2)],
            "Test")
    catch: printf(">> RealCertify fails with test\n")
    end try;
    checkWeifeng(x + 1, [x*(x - 1)*(x - 2), -x*(x - 1)*(x - 2)], x, "Test")
end proc

oldProblematicExamples1 := proc()
    checkWeifeng(x + 101/100, [
        (x - 118/25)*(x - 657/100)*(x - 89/10)*(x - 413/20)*(x - 561/25),
        (-x + 118/25)*(x - 657/100)*(x - 89/10)*(x - 413/20)*(x - 561/25)],
        x, "Works");
    checkRealCertify(x + 101/100, [-x^2 + 100,
        (x - 118/25)*(x - 657/100)*(x - 89/10)*(x - 413/20)*(x - 561/25),
        (-x + 118/25)*(x - 657/100)*(x - 89/10)*(x - 413/20)*(x - 561/25)],
        "Works");
    checkWeifeng(x + 53/100, [(x - 577/100)*(x - 317/50)*(x - 1069/100)*
        (x - 1443/100)*(x - 381/25), -(x - 577/100)*(x - 317/50)*
        (x - 1069/100)*(x - 1443/100)*(x - 381/25)], x, "Now works!");
    checkRealCertify(x + 53/100, [-x^2 + 100, (x - 577/100)*(x - 317/50)*
        (x - 1069/100)*(x - 1443/100)*(x - 381/25), -(x - 577/100)*
        (x - 317/50)*(x - 1069/100)*(x - 1443/100)*(x - 381/25)], "Works")
end proc

oldProblematicExamples2 := proc()
    checkWeifeng((x - 7)*(x - 71/10), [
        (x - 118/25)*(x - 657/100)*(x - 89/10)*(x - 413/20)*(x - 561/25),
        (-x + 118/25)*(x - 657/100)*(x - 89/10)*(x - 413/20)*(x - 561/25)],
        x, "PASSED");
    checkWeifeng((x - 7)*(x - 71/10), [
        (x - 118/25)*(x - 657/100)*(x - 89/10)*(x - 413/20)*(x - 561/25),
        (-x + 118/25)^3*(x - 657/100)*(x - 89/10)*(x - 413/20)*(x - 561/25)
        ], x, "FAILS");
    checkWeifeng((x - 10)*(x - 15), [
        (x - 118/25)*(x - 657/100)*(x - 89/10)*(x - 413/20)*(x - 561/25),
        (-x + 118/25)^3*(x - 657/100)*(x - 89/10)*(x - 413/20)*(x - 561/25)
        ], x, "PASSED")
end proc

leftStrictPositiveBenchmark := proc(num_iterations, basisGeneratorFunc)
local
i, intervals1, basis1, isolated_points1, archimedean_poly1, f1, benchmarks;
    benchmarks := [];
    for i to num_iterations do
        intervals1 := intervalsGenerator(x, 3, 1, 10, 100);
        basis1 := basisGeneratorFunc(x, intervals1);
        isolated_points1 := getIsolatedPoints(intervals1);
        archimedean_poly1 :=
            getArchimedeanPolynomial(x, isolated_points1, 2);
        f1 := strictlyLeftPolynomial(x, isolated_points1, 10);
        benchmarks := [op(benchmarks), [f1, basis1, archimedean_poly1]]
    end do;
    return benchmarks
end proc

rightStrictPositiveBenchmark := proc(num_iterations, basisGeneratorFunc)
local i, test_name1, intervals1, basis1, isolated_points1,
archimedean_poly1, f1, benchmarks;
    benchmarks := [];
    for i to num_iterations do
        intervals1 := intervalsGenerator(x, 3, 1, 10, 100);
        basis1 := basisGeneratorFunc(x, intervals1);
        isolated_points1 := getIsolatedPoints(intervals1);
        archimedean_poly1 :=
            getArchimedeanPolynomial(x, isolated_points1, 2);
        f1 := strictlyRightPolynomial(x, isolated_points1, 10);
        benchmarks := [op(benchmarks), [f1, basis1, archimedean_poly1]]
    end do;
    return benchmarks
end proc

Warning, (in productGensBenchmark) `random_point` is implicitly declared local
|benchmarking.mpl:207|
productGensBenchmark := proc(num_iterations, basisGeneratorFunc)
local i, test_name1, intervals1, basis1, isolated_points1,
archimedean_poly1, f1, benchmarks, random_point;
    benchmarks := [];
    for i to num_iterations do
        random_point := genRandomPoint(1, 10, 100);
        basis1 := [x - random_point, -x + random_point];
        isolated_points1 := [random_point];
        archimedean_poly1 :=
            getArchimedeanPolynomial(x, isolated_points1, 2);
        f1 := basis1[1]*basis1[2] + 35;
        benchmarks := [op(benchmarks), [f1, basis1, archimedean_poly1]]
    end do;
    return benchmarks
end proc

archimedeanBenchmark := proc(num_iterations, basisGeneratorFunc)
local i, test_name1, intervals1, basis1, isolated_points1,
archimedean_poly1, f1, benchmarks;
    benchmarks := [];
    for i to num_iterations do
        intervals1 := intervalsGenerator(x, 3, 1, 10, 100);
        basis1 := basisGeneratorFunc(x, intervals1);
        isolated_points1 := getIsolatedPoints(intervals1);
        archimedean_poly1 :=
            getArchimedeanPolynomial(x, isolated_points1, 2);
        f1 := archimedean_poly1 + 10;
        benchmarks := [op(benchmarks), [f1, basis1, archimedean_poly1]]
    end do;
    return benchmarks
end proc

natGensBenchmark := proc(num_iterations, basisGeneratorFunc, maxtime)
local i, test_name1, test_name2, test_name3, test_name4, intervals1, basis1,
isolated_points1, nat_gens;
    for i to num_iterations do
        intervals1 := intervalsGenerator(x, 3, 1, 10, 100);
        basis1 := basisGeneratorFunc(x, intervals1);
        print("Basis", basis1);
        isolated_points1 := getIsolatedPoints(intervals1);
        nat_gens := gen_nat_gens(basis1, x);
        test_name1 := cat("Batch: ", convert(i, string), " Test Weifeng");
        try
            map(f1 ->
                timelimit(maxtime, checkWeifeng(f1, basis1, x, test_name1))
                , nat_gens);
            printf(">> Succeeds Weifeng %s\n", test_name1)
        catch: printf(">> Timeout Weifeng %s\n", test_name1)
        end try
    end do
end proc

natGensBenchmark2 := proc(x, num_points)
local
i, _p, pos_isolated_points, isolated_points, basis_poly, basis, tempPoly;
    pos_isolated_points := [seq(i, i = 1 .. num_points)];
    isolated_points := sort(
        [op(map(p -> -p, pos_isolated_points)), op(pos_isolated_points)]);
    basis_poly := mul(_p, _p in map(p -> x - p, isolated_points));
    basis := [-basis_poly, basis_poly];
    printf("\n>> Start benchmark\n");
    try
        checkWeifeng(x + num_points, basis, x,
            "Left Natural Generator Test")
    catch: printf(">> Timeout Weifeng %s\n", "Left Natural Generator Test")
    end try;
    for i to 2*num_points - 1 do
        tempPoly := (x - isolated_points[i])*(x - isolated_points[i + 1]);
        try
            checkWeifeng(tempPoly, basis, x, cat(
                "In between Natural Generator Test ", convert(i, string)))
        catch:
            printf(">> Timeout Weifeng %s\n", cat(
                "In between Natural Generator Test ", convert(i, string)))
        end try
    end do;
    try
        checkWeifeng(-x + num_points, basis, x,
            "Right Natural Generator Test")
    catch:
        printf(">> Timeout Weifeng %s\n", "Right Natural Generator Test")
    end try
end proc

runBenchmark := proc(benchmarks, num_iterations, maxtime)
local i, test_name1;
    printf("\n>> Start benchmark\n");
    for i to num_iterations do
        test_name1 :=
            cat("Batch: ", convert(i, string), " Test 1 - Weifeng");
        try
            timelimit(maxtime, checkWeifeng(benchmarks[i][1],
                benchmarks[i][2], x, test_name1));
            printf(">> Succeeds Weifeng %s\n", test_name1)
        catch: printf(">> Timeout Weifeng %s\n", test_name1)
        end try;
        test_name1 := cat("Batch: ", convert(i, string),
            " Test 1 - RealCertify without Archimedean polynomial");
        try
            timelimit(maxtime, checkRealCertify(benchmarks[i][1],
                benchmarks[i][2], test_name1));
            printf(">> Succeeds RealCertify %s\n", test_name1)
        catch: printf(">> Timeout RealCertify %s\n", test_name1)
        end try;
        test_name1 := cat("Batch: ", convert(i, string),
            " Test 1 - RealCertify with Archimedean polynomial");
        try
            timelimit(maxtime, checkRealCertify(benchmarks[i][1],
                [op(benchmarks[i][2]), benchmarks[i][3]], test_name1));
            printf(">> Succeeds RealCertify %s\n", test_name1)
        catch: printf(">> Timeout RealCertify %s\n", test_name1)
        end try
    end do
end proc

runBenchmark1 := proc()
    natGensBenchmark2(x, 1);
    natGensBenchmark2(x, 2);
    natGensBenchmark2(x, 3);
    natGensBenchmark2(x, 4);
    natGensBenchmark2(x, 5);
    natGensBenchmark2(x, 6);
    natGensBenchmark2(x, 7)
end proc

runBenchmark2 := proc()
local num_iterations, max_time;
    num_iterations := 100;
    max_time := 300;
    runBenchmark(
        archimedeanBenchmark(num_iterations, linearBasisNoBoundedPoly),
        num_iterations, max_time)
end proc

simple_test := proc()
    checkWeifeng(-(x - 1)^2, [x - 1, -x + 1], x, "PASSED");
    checkWeifeng(x + 2, [x - 1, -x + 1], x, "PASSED");
    checkWeifeng(x + 100, [x - 1, -x + 1], x, "PASSED")
end proc

example_11_paper := proc()
    checkWeifeng(-26*x^7 + 13*x^6 + 87*x^5 + 49*x^4 - 464*x^3 + 1512*x^2
         - 2211*x + 1092,
        [x*(x - 1/2)*(x - 1)^2*(x - 2), -x*(x - 1)*(x - 2)], x, "PASSED")
end proc

problematic_case := proc()
    checkWeifeng(-x^2 + 4848041/10000, [(x - 241/25)*(x - 329/20)*
        (x - 478/25)*(x - 1979/100)*(x - 2079/100), (-x + 241/25)*
        (x - 329/20)*(x - 478/25)*(x - 1979/100)*(x - 2079/100)], x, "??");
    checkRealCertify(-x^2 + 4848041/10000, [(x - 241/25)*(x - 329/20)*
        (x - 478/25)*(x - 1979/100)*(x - 2079/100), (-x + 241/25)*
        (x - 329/20)*(x - 478/25)*(x - 1979/100)*(x - 2079/100)], x, "??")
end proc

realcertify_problematic_example := proc()
    checkRealCertify(-x^2 + 845306/625, [-x^2 + 839056/625, (x - 61/25)*
        (x - 483/50)*(x - 1013/100)*(x - 1539/100)*(x - 1027/50)*
        (x - 866/25)*(x - 891/25), -(x - 61/25)*(x - 483/50)*(x - 1013/100)
        *(x - 1539/100)*(x - 1027/50)*(x - 866/25)*(x - 891/25)], x, "??")
end proc


>> Start

>> Start benchmark

>> Test
Left Natural Generator Test
>> input polynomial
x+1
>> basis
[-(x+1)*(x-1), (x+1)*(x-1)]
>> Time taken
0.025000
">> Sums of squares multipliers", [x+1+1/2*(x+1)*(x-1), 1/2, 0]
>> Degree size
2

>> Test
In between Natural Generator Test 1
>> input polynomial
(x+1)*(x-1)
>> basis
[-(x+1)*(x-1), (x+1)*(x-1)]
>> Time taken
0.825000
">> Sums of squares multipliers", [(x+1)*(x-1)+(7486/29907*(x+999/1000)^2+24595
/71579)*(x^2-1)^2*(x+1)*(x-1)-(1/4*(x-1)^2*(x+2)^2+1/4*(x+1)^2*(x-2)^2)*(x+1)*(
x-1), (7486/29907*(x+999/1000)^2+24595/71579)*(x^2-1)^2, 1/4*(x-1)^2*(x+2)^2+1/
4*(x+1)^2*(x-2)^2]
>> Degree size
8

>> Test
Right Natural Generator Test
>> input polynomial
-x+1
>> basis
[-(x+1)*(x-1), (x+1)*(x-1)]
>> Time taken
0.006000
">> Sums of squares multipliers", [-x+1+1/2*(x+1)*(x-1), 1/2, 0]
>> Degree size
2

>> Start benchmark

>> Test
Left Natural Generator Test
>> input polynomial
x+2
>> basis
[-(x+2)*(x+1)*(x-1)*(x-2), (x+2)*(x+1)*(x-1)*(x-2)]
>> Time taken
0.013000
">> Sums of squares multipliers", [x+2+1/12*(x+2)*(x+1)*(x-1)*(x-2), 1/12, 0]
>> Degree size
4

>> Test
In between Natural Generator Test 1
>> input polynomial
(x+2)*(x+1)
>> basis
[-(x+2)*(x+1)*(x-1)*(x-2), (x+2)*(x+1)*(x-1)*(x-2)]
>> Time taken
1.131000
">> Sums of squares multipliers", [(x+2)*(x+1)+(7126/417947*(x+1999/1000)^2+
24038/9207*(-497528000/684342719*(x+2)*(x+1)*(x-1)*(x-2)-560278719/684342719)^
12)*(x^2+3*x+2)^2*(x+2)*(x+1)*(x-1)*(x-2)-(1849/6912*(x+1)^2*(x+110/43)^2+169/
864*(x+2)^2*(x+1/13)^2)*(x+2)*(x+1)*(x-1)*(x-2), (7126/417947*(x+1999/1000)^2+
24038/9207*(-497528000/684342719*(x+2)*(x+1)*(x-1)*(x-2)-560278719/684342719)^
12)*(x^2+3*x+2)^2, 1849/6912*(x+1)^2*(x+110/43)^2+169/864*(x+2)^2*(x+1/13)^2]
>> Degree size
56

>> Test
In between Natural Generator Test 2
>> input polynomial
(x+1)*(x-1)
>> basis
[-(x+2)*(x+1)*(x-1)*(x-2), (x+2)*(x+1)*(x-1)*(x-2)]
>> Time taken
0.015000
">> Sums of squares multipliers", [(x+1)*(x-1)+(x+2)*(x+1)*(x-1)*(x-2)*(1/27*(x
-1)^2*(x+5/2)^2+1/27*(x+1)^2*(x-5/2)^2), 1/27*(x-1)^2*(x+5/2)^2+1/27*(x+1)^2*(x
-5/2)^2, 0]
>> Degree size
8

>> Test
In between Natural Generator Test 3
>> input polynomial
(x-1)*(x-2)
>> basis
[-(x+2)*(x+1)*(x-1)*(x-2), (x+2)*(x+1)*(x-1)*(x-2)]
>> Time taken
3.890000
">> Sums of squares multipliers", [(x-1)*(x-2)+(3689/104044*(x+1999/1000)^2+
126250/68779*(-32664000/39841247*(x+2)*(x+1)*(x-1)*(x-2)-36783747/39841247)^18)
*(x^2-3*x+2)^2*(x+2)*(x+1)*(x-1)*(x-2)-(169/864*(x-2)^2*(x-1/13)^2+1849/6912*(x
-1)^2*(x-110/43)^2)*(x+2)*(x+1)*(x-1)*(x-2), (3689/104044*(x+1999/1000)^2+
126250/68779*(-32664000/39841247*(x+2)*(x+1)*(x-1)*(x-2)-36783747/39841247)^18)
*(x^2-3*x+2)^2, 169/864*(x-2)^2*(x-1/13)^2+1849/6912*(x-1)^2*(x-110/43)^2]
>> Degree size
80

>> Test
Right Natural Generator Test
>> input polynomial
-x+2
>> basis
[-(x+2)*(x+1)*(x-1)*(x-2), (x+2)*(x+1)*(x-1)*(x-2)]
>> Time taken
0.014000
">> Sums of squares multipliers", [-x+2+1/12*(x+2)*(x+1)*(x-1)*(x-2), 1/12, 0]
>> Degree size
4

>> Start benchmark

>> Test
Left Natural Generator Test
>> input polynomial
x+3
>> basis
[-(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3), (x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)]
>> Time taken
0.019000
">> Sums of squares multipliers", [x+3+1/240*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3
), 1/240, 0]
>> Degree size
6

>> Test
In between Natural Generator Test 1
>> input polynomial
(x+3)*(x+2)
>> basis
[-(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3), (x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)]
>> Time taken
1.134000
">> Sums of squares multipliers", [(x+3)*(x+2)+(1771/4900915*(x+2999/1000)^2+
35531/51084*(-16865500/330923079*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)-33764731/
36769231)^100)*(x^2+5*x+6)^2*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)-(61009/3456000
*(x+2)^2*(x+861/247)^2+5329/864000*(x+3)^2*(x+26/73)^2)*(x+3)*(x+2)*(x+1)*(x-1)
*(x-2)*(x-3), (1771/4900915*(x+2999/1000)^2+35531/51084*(-16865500/330923079*(x
+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)-33764731/36769231)^100)*(x^2+5*x+6)^2, 61009/
3456000*(x+2)^2*(x+861/247)^2+5329/864000*(x+3)^2*(x+26/73)^2]
>> Degree size
610

>> Test
In between Natural Generator Test 2
>> input polynomial
(x+2)*(x+1)
>> basis
[-(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3), (x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)]
>> Time taken
0.388000
">> Sums of squares multipliers", [(x+2)*(x+1)+(27889/864000*(x+1)^2*(x+454/167
)^2+841/27648*(x+2)^2*(x+5/29)^2+166129858738395007118382720/
717845191296259040774120089*(-717845191296259040774120089/
15911550900623772862065050562*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)-\
717845191296259040774120089/883975050034654047892502809)^2*(x^2+3*x+2)^2)*(x+3)
*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)-166129858738395007118382720/
717845191296259040774120089*(717845191296259040774120089/
15911550900623772862065050562*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)-\
717845191296259040774120089/883975050034654047892502809)^2*(x^2+3*x+2)^2*(x+3)*
(x+2)*(x+1)*(x-1)*(x-2)*(x-3), 27889/864000*(x+1)^2*(x+454/167)^2+841/27648*(x+
2)^2*(x+5/29)^2+166129858738395007118382720/717845191296259040774120089*(-\
717845191296259040774120089/15911550900623772862065050562*(x+3)*(x+2)*(x+1)*(x-\
1)*(x-2)*(x-3)-717845191296259040774120089/883975050034654047892502809)^2*(x^2+
3*x+2)^2, 166129858738395007118382720/717845191296259040774120089*(
717845191296259040774120089/15911550900623772862065050562*(x+3)*(x+2)*(x+1)*(x-\
1)*(x-2)*(x-3)-717845191296259040774120089/883975050034654047892502809)^2*(x^2+
3*x+2)^2]
>> Degree size
22

>> Test
In between Natural Generator Test 3
>> input polynomial
(x+1)*(x-1)
>> basis
[-(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3), (x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)]
>> Time taken
1.261000
">> Sums of squares multipliers", [(x+1)*(x-1)+(407/2377746*(x+2999/1000)^2+
12023/46723*(-3243500/88153383*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)-19480461/
29384461)^10)*(x^2-1)^2*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)-(169/55296*(x-1)^2*
(x+37/13)^2+169/55296*(x+1)^2*(x-37/13)^2)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3),
(407/2377746*(x+2999/1000)^2+12023/46723*(-3243500/88153383*(x+3)*(x+2)*(x+1)*(
x-1)*(x-2)*(x-3)-19480461/29384461)^10)*(x^2-1)^2, 169/55296*(x-1)^2*(x+37/13)^
2+169/55296*(x+1)^2*(x-37/13)^2]
>> Degree size
70

>> Test
In between Natural Generator Test 4
>> input polynomial
(x-1)*(x-2)
>> basis
[-(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3), (x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)]
>> Time taken
0.273000
">> Sums of squares multipliers", [(x-1)*(x-2)+(841/27648*(x-2)^2*(x-5/29)^2+
27889/864000*(x-1)^2*(x-454/167)^2+166129858738395007118382720/
717845191296259040774120089*(-717845191296259040774120089/
15911550900623772862065050562*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)-\
717845191296259040774120089/883975050034654047892502809)^2*(x^2-3*x+2)^2)*(x+3)
*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)-166129858738395007118382720/
717845191296259040774120089*(717845191296259040774120089/
15911550900623772862065050562*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)-\
717845191296259040774120089/883975050034654047892502809)^2*(x^2-3*x+2)^2*(x+3)*
(x+2)*(x+1)*(x-1)*(x-2)*(x-3), 841/27648*(x-2)^2*(x-5/29)^2+27889/864000*(x-1)^
2*(x-454/167)^2+166129858738395007118382720/717845191296259040774120089*(-\
717845191296259040774120089/15911550900623772862065050562*(x+3)*(x+2)*(x+1)*(x-\
1)*(x-2)*(x-3)-717845191296259040774120089/883975050034654047892502809)^2*(x^2-\
3*x+2)^2, 166129858738395007118382720/717845191296259040774120089*(
717845191296259040774120089/15911550900623772862065050562*(x+3)*(x+2)*(x+1)*(x-\
1)*(x-2)*(x-3)-717845191296259040774120089/883975050034654047892502809)^2*(x^2-\
3*x+2)^2]
>> Degree size
22

>> Test
In between Natural Generator Test 5
>> input polynomial
(x-2)*(x-3)
>> basis
[-(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3), (x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)]
>> Time taken
1.477000
">> Sums of squares multipliers", [(x-2)*(x-3)+(542/632183*(x+2999/1000)^2+
22586/66713*(-1308500/24506273*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)-2143323/
2227843)^202)*(x^2-5*x+6)^2*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)-(5329/864000*(x
-3)^2*(x-26/73)^2+61009/3456000*(x-2)^2*(x-861/247)^2)*(x+3)*(x+2)*(x+1)*(x-1)*
(x-2)*(x-3), (542/632183*(x+2999/1000)^2+22586/66713*(-1308500/24506273*(x+3)*(
x+2)*(x+1)*(x-1)*(x-2)*(x-3)-2143323/2227843)^202)*(x^2-5*x+6)^2, 5329/864000*(
x-3)^2*(x-26/73)^2+61009/3456000*(x-2)^2*(x-861/247)^2]
>> Degree size
1222

>> Test
Right Natural Generator Test
>> input polynomial
-x+3
>> basis
[-(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3), (x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)]
>> Time taken
0.018000
">> Sums of squares multipliers", [-x+3+1/240*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-\
3), 1/240, 0]
>> Degree size
6

>> Start benchmark

>> Test
Left Natural Generator Test
>> input polynomial
x+4
>> basis
[-(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4), (x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)]
>> Time taken
0.025000
">> Sums of squares multipliers", [x+4+1/10080*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x
-2)*(x-3)*(x-4), 1/10080, 0]
>> Degree size
8

>> Test
In between Natural Generator Test 1
>> input polynomial
(x+4)*(x+3)
>> basis
[-(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4), (x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)]
>> Time taken
2.419000
">> Sums of squares multipliers", [(x+4)*(x+3)+(50/10597737*(x+3999/1000)^2+
4431/87820*(-1720717/1209270083*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)
-1150675949/1209270083)^206)*(x^2+7*x+12)^2*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)
*(x-3)*(x-4)-(173889/351232000*(x+3)^2*(x+5564/1251)^2+1/1680*(x+4)^2)*(x+4)*(x
+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4), (50/10597737*(x+3999/1000)^2+4431/
87820*(-1720717/1209270083*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)-\
1150675949/1209270083)^206)*(x^2+7*x+12)^2, 173889/351232000*(x+3)^2*(x+5564/
1251)^2+1/1680*(x+4)^2]
>> Degree size
1660

>> Test
In between Natural Generator Test 2
>> input polynomial
(x+3)*(x+2)
>> basis
[-(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4), (x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)]
>> Time taken
0.532000
">> Sums of squares multipliers", [(x+3)*(x+2)+(1874161/1185408000*(x+2)^2*(x+
4947/1369)^2+961/1152000*(x+3)^2*(x+22/31)^2+685237609073963901078046728604800/
4431048942955764415669792010751103*(-19870174632088629666680681662561/
15348859656089184950243516218067709*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(
x-4)-4431048942955764415669792010751103/5116286552029728316747838739355903)^2*(
x^2+5*x+6)^2)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)-\
685237609073963901078046728604800/4431048942955764415669792010751103*(
19870174632088629666680681662561/15348859656089184950243516218067709*(x+4)*(x+3
)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)-4431048942955764415669792010751103/
5116286552029728316747838739355903)^2*(x^2+5*x+6)^2*(x+4)*(x+3)*(x+2)*(x+1)*(x-\
1)*(x-2)*(x-3)*(x-4), 1874161/1185408000*(x+2)^2*(x+4947/1369)^2+961/1152000*(x
+3)^2*(x+22/31)^2+685237609073963901078046728604800/
4431048942955764415669792010751103*(-19870174632088629666680681662561/
15348859656089184950243516218067709*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(
x-4)-4431048942955764415669792010751103/5116286552029728316747838739355903)^2*(
x^2+5*x+6)^2, 685237609073963901078046728604800/
4431048942955764415669792010751103*(19870174632088629666680681662561/
15348859656089184950243516218067709*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(
x-4)-4431048942955764415669792010751103/5116286552029728316747838739355903)^2*(
x^2+5*x+6)^2]
>> Degree size
28

>> Test
In between Natural Generator Test 3
>> input polynomial
(x+2)*(x+1)
>> basis
[-(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4), (x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)]
>> Time taken
2.226000
">> Sums of squares multipliers", [(x+2)*(x+1)+(169/4886972*(x+3999/1000)^2+
15272/27463*(-4297659/2908318805*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4
)-2873925723/2908318805)^1002)*(x^2+3*x+2)^2*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2
)*(x-3)*(x-4)-(2401/1152000*(x+1)^2*(x+138/49)^2+289/128000*(x+2)^2*(x+11/51)^2
)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4), (169/4886972*(x+3999/1000)^2
+15272/27463*(-4297659/2908318805*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-\
4)-2873925723/2908318805)^1002)*(x^2+3*x+2)^2, 2401/1152000*(x+1)^2*(x+138/49)^
2+289/128000*(x+2)^2*(x+11/51)^2]
>> Degree size
8028

>> Test
In between Natural Generator Test 4
>> input polynomial
(x+1)*(x-1)
>> basis
[-(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4), (x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)]
>> Time taken
0.424000
">> Sums of squares multipliers", [(x+1)*(x-1)+(1/1440*(x-1)^2+1/1440*(x+1)^2+
4886400780998503992000675535744818572800/
10946953937080623119380964524421667162909*(-\
16363159846159376860061232472977080961/
15833354718079127111381640060166485735709*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(
x-3)*(x-4)-10946953937080623119380964524421667162909/
15833354718079127111381640060166485735709)^2*(x^2-1)^2)*(x+4)*(x+3)*(x+2)*(x+1)
*(x-1)*(x-2)*(x-3)*(x-4)-4886400780998503992000675535744818572800/
10946953937080623119380964524421667162909*(
16363159846159376860061232472977080961/
15833354718079127111381640060166485735709*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(
x-3)*(x-4)-10946953937080623119380964524421667162909/
15833354718079127111381640060166485735709)^2*(x^2-1)^2*(x+4)*(x+3)*(x+2)*(x+1)*
(x-1)*(x-2)*(x-3)*(x-4), 1/1440*(x-1)^2+1/1440*(x+1)^2+
4886400780998503992000675535744818572800/
10946953937080623119380964524421667162909*(-\
16363159846159376860061232472977080961/
15833354718079127111381640060166485735709*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(
x-3)*(x-4)-10946953937080623119380964524421667162909/
15833354718079127111381640060166485735709)^2*(x^2-1)^2, 
4886400780998503992000675535744818572800/
10946953937080623119380964524421667162909*(
16363159846159376860061232472977080961/
15833354718079127111381640060166485735709*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(
x-3)*(x-4)-10946953937080623119380964524421667162909/
15833354718079127111381640060166485735709)^2*(x^2-1)^2]
>> Degree size
28

>> Test
In between Natural Generator Test 5
>> input polynomial
(x-1)*(x-2)
>> basis
[-(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4), (x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)]
>> Time taken
2.057000
">> Sums of squares multipliers", [(x-1)*(x-2)+(311/8525208*(x+3999/1000)^2+
13147/18601*(-24437252/16436454257*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x
-4)-16341651844/16436454257)^2102)*(x^2-3*x+2)^2*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*
(x-2)*(x-3)*(x-4)-(289/128000*(x-2)^2*(x-11/51)^2+2401/1152000*(x-1)^2*(x-138/
49)^2)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4), (311/8525208*(x+3999/
1000)^2+13147/18601*(-24437252/16436454257*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*
(x-3)*(x-4)-16341651844/16436454257)^2102)*(x^2-3*x+2)^2, 289/128000*(x-2)^2*(x
-11/51)^2+2401/1152000*(x-1)^2*(x-138/49)^2]
>> Degree size
16828

>> Test
In between Natural Generator Test 6
>> input polynomial
(x-2)*(x-3)
>> basis
[-(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4), (x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)]
>> Time taken
0.514000
">> Sums of squares multipliers", [(x-2)*(x-3)+(961/1152000*(x-3)^2*(x-22/31)^2
+1874161/1185408000*(x-2)^2*(x-4947/1369)^2+685237609073963901078046728604800/
4431048942955764415669792010751103*(-19870174632088629666680681662561/
15348859656089184950243516218067709*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(
x-4)-4431048942955764415669792010751103/5116286552029728316747838739355903)^2*(
x^2-5*x+6)^2)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)-\
685237609073963901078046728604800/4431048942955764415669792010751103*(
19870174632088629666680681662561/15348859656089184950243516218067709*(x+4)*(x+3
)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)-4431048942955764415669792010751103/
5116286552029728316747838739355903)^2*(x^2-5*x+6)^2*(x+4)*(x+3)*(x+2)*(x+1)*(x-\
1)*(x-2)*(x-3)*(x-4), 961/1152000*(x-3)^2*(x-22/31)^2+1874161/1185408000*(x-2)^
2*(x-4947/1369)^2+685237609073963901078046728604800/
4431048942955764415669792010751103*(-19870174632088629666680681662561/
15348859656089184950243516218067709*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(
x-4)-4431048942955764415669792010751103/5116286552029728316747838739355903)^2*(
x^2-5*x+6)^2, 685237609073963901078046728604800/
4431048942955764415669792010751103*(19870174632088629666680681662561/
15348859656089184950243516218067709*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(
x-4)-4431048942955764415669792010751103/5116286552029728316747838739355903)^2*(
x^2-5*x+6)^2]
>> Degree size
28

>> Test
In between Natural Generator Test 7
>> input polynomial
(x-3)*(x-4)
>> basis
[-(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4), (x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)]
>> Time taken
2.664000
">> Sums of squares multipliers", [(x-3)*(x-4)+(17/3077100*(x+3999/1000)^2+6250
/88761*(-9370054/6414103841*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)-\
6265932038/6414103841)^448)*(x^2-7*x+12)^2*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*
(x-3)*(x-4)-(1/1680*(x-4)^2+173889/351232000*(x-3)^2*(x-5564/1251)^2)*(x+4)*(x+
3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4), (17/3077100*(x+3999/1000)^2+6250/88761*
(-9370054/6414103841*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)-6265932038
/6414103841)^448)*(x^2-7*x+12)^2, 1/1680*(x-4)^2+173889/351232000*(x-3)^2*(x-\
5564/1251)^2]
>> Degree size
3596

>> Test
Right Natural Generator Test
>> input polynomial
-x+4
>> basis
[-(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4), (x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)]
>> Time taken
0.024000
">> Sums of squares multipliers", [-x+4+1/10080*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(
x-2)*(x-3)*(x-4), 1/10080, 0]
>> Degree size
8

>> Start benchmark

>> Test
Left Natural Generator Test
>> input polynomial
x+5
>> basis
[-(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5), (x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)]
>> Time taken
0.032000
">> Sums of squares multipliers", [x+5+1/725760*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(
x-1)*(x-2)*(x-3)*(x-4)*(x-5), 1/725760, 0]
>> Degree size
10

>> Test
In between Natural Generator Test 1
>> input polynomial
(x+5)*(x+4)
>> basis
[-(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5), (x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)]
>> Time taken
7.813000
">> Sums of squares multipliers", [(x+5)*(x+4)+(5/112385267*(x+4999/1000)^2+
1213/302226*(-142500/6507423187*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)
*(x-4)*(x-5)-6312250000/6507423187)^404)*(x^2+9*x+20)^2*(x+5)*(x+4)*(x+3)*(x+2)
*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)-(142014889/18435465216000*(x+4)^2*(x+64625
/11917)^2+1/90720*(x+5)^2)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4
)*(x-5), (5/112385267*(x+4999/1000)^2+1213/302226*(-142500/6507423187*(x+5)*(x+
4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)-6312250000/6507423187)^404)*
(x^2+9*x+20)^2, 142014889/18435465216000*(x+4)^2*(x+64625/11917)^2+1/90720*(x+5
)^2]
>> Degree size
4054

>> Test
In between Natural Generator Test 2
>> input polynomial
(x+4)*(x+3)
>> basis
[-(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5), (x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)]
>> Time taken
1.005000
">> Sums of squares multipliers", [(x+4)*(x+3)+(81342361/2304433152000*(x+3)^2*
(x+41116/9019)^2+877969/75866112000*(x+4)^2*(x+1131/937)^2+
862444120608030421269424647457444457457109/
7241115730827552591103583902248960000000000*(-\
1799929339007594479518663659520000000000/
89139158365791413136103094046770449032028199*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1
)*(x-2)*(x-3)*(x-4)*(x-5)-7241115730827552591103583902248960000000000/
8103559851435583012373008549706404457457109)^2*(x^2+7*x+12)^2)*(x+5)*(x+4)*(x+3
)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)-\
862444120608030421269424647457444457457109/
7241115730827552591103583902248960000000000*(
1799929339007594479518663659520000000000/
89139158365791413136103094046770449032028199*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1
)*(x-2)*(x-3)*(x-4)*(x-5)-7241115730827552591103583902248960000000000/
8103559851435583012373008549706404457457109)^2*(x^2+7*x+12)^2*(x+5)*(x+4)*(x+3)
*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5), 81342361/2304433152000*(x+3)^2*(x+
41116/9019)^2+877969/75866112000*(x+4)^2*(x+1131/937)^2+
862444120608030421269424647457444457457109/
7241115730827552591103583902248960000000000*(-\
1799929339007594479518663659520000000000/
89139158365791413136103094046770449032028199*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1
)*(x-2)*(x-3)*(x-4)*(x-5)-7241115730827552591103583902248960000000000/
8103559851435583012373008549706404457457109)^2*(x^2+7*x+12)^2, 
862444120608030421269424647457444457457109/
7241115730827552591103583902248960000000000*(
1799929339007594479518663659520000000000/
89139158365791413136103094046770449032028199*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1
)*(x-2)*(x-3)*(x-4)*(x-5)-7241115730827552591103583902248960000000000/
8103559851435583012373008549706404457457109)^2*(x^2+7*x+12)^2]
>> Degree size
34

>> Test
In between Natural Generator Test 3
>> input polynomial
(x+3)*(x+2)
>> basis
[-(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5), (x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)]
>> Time taken
5.888000
">> Sums of squares multipliers", [(x+3)*(x+2)+(62/96830849*(x+4999/1000)^2+
7707/92668*(-57000/2533061317*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(
x-4)*(x-5)-2524900000/2533061317)^4596)*(x^2+5*x+6)^2*(x+5)*(x+4)*(x+3)*(x+2)*(
x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)-(5870929/75866112000*(x+2)^2*(x+8949/2423)^2
+534361/10668672000*(x+3)^2*(x+622/731)^2)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*
(x-2)*(x-3)*(x-4)*(x-5), (62/96830849*(x+4999/1000)^2+7707/92668*(-57000/
2533061317*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)-\
2524900000/2533061317)^4596)*(x^2+5*x+6)^2, 5870929/75866112000*(x+2)^2*(x+8949
/2423)^2+534361/10668672000*(x+3)^2*(x+622/731)^2]
>> Degree size
45974

>> Test
In between Natural Generator Test 4
>> input polynomial
(x+2)*(x+1)
>> basis
[-(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5), (x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)]
>> Time taken
1.164000
">> Sums of squares multipliers", [(x+2)*(x+1)+(900601/10668672000*(x+1)^2*(x+
2738/949)^2+6241/62208000*(x+2)^2*(x+19/79)^2+
109793675622970845558492523366151098650661793136826645725/
3121645677178468011301822108069544462841192149697406435328*(-\
1904603829883140946492874989670252875436968974800125952/
87248862525638849135228495048763780160280056456524293188431*(x+5)*(x+4)*(x+3)*(
x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)-\
3121645677178468011301822108069544462841192149697406435328/
3231439352801438856860314631435695561491853942834233081053)^2*(x^2+3*x+2)^2)*(x
+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)-\
109793675622970845558492523366151098650661793136826645725/
3121645677178468011301822108069544462841192149697406435328*(
1904603829883140946492874989670252875436968974800125952/
87248862525638849135228495048763780160280056456524293188431*(x+5)*(x+4)*(x+3)*(
x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)-\
3121645677178468011301822108069544462841192149697406435328/
3231439352801438856860314631435695561491853942834233081053)^2*(x^2+3*x+2)^2*(x+
5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5), 900601/10668672000*(x
+1)^2*(x+2738/949)^2+6241/62208000*(x+2)^2*(x+19/79)^2+
109793675622970845558492523366151098650661793136826645725/
3121645677178468011301822108069544462841192149697406435328*(-\
1904603829883140946492874989670252875436968974800125952/
87248862525638849135228495048763780160280056456524293188431*(x+5)*(x+4)*(x+3)*(
x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)-\
3121645677178468011301822108069544462841192149697406435328/
3231439352801438856860314631435695561491853942834233081053)^2*(x^2+3*x+2)^2, 
109793675622970845558492523366151098650661793136826645725/
3121645677178468011301822108069544462841192149697406435328*(
1904603829883140946492874989670252875436968974800125952/
87248862525638849135228495048763780160280056456524293188431*(x+5)*(x+4)*(x+3)*(
x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)-\
3121645677178468011301822108069544462841192149697406435328/
3231439352801438856860314631435695561491853942834233081053)^2*(x^2+3*x+2)^2]
>> Degree size
34

>> Test
In between Natural Generator Test 5
>> input polynomial
(x+1)*(x-1)
>> basis
[-(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5), (x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)]
>> Time taken
0.748000
">> Sums of squares multipliers", [(x+1)*(x-1)+
35107258171359845084179525435407618773831534400/
915703816857849404640917564522276121948071371349*(-\
6145663200388251037858507144444806187570948801/
282390889283675147168353835717432070994405163007453*(x+5)*(x+4)*(x+3)*(x+2)*(x+
1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)-\
915703816857849404640917564522276121948071371349/
950811075029209249725097089957683740721902905749)^2*(x^2-1)^2*(x+5)*(x+4)*(x+3)
*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)-(1/34560*(x-1)^2+1/34560*(x+1)^2+
35107258171359845084179525435407618773831534400/
915703816857849404640917564522276121948071371349*(
6145663200388251037858507144444806187570948801/
282390889283675147168353835717432070994405163007453*(x+5)*(x+4)*(x+3)*(x+2)*(x+
1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)-\
915703816857849404640917564522276121948071371349/
950811075029209249725097089957683740721902905749)^2*(x^2-1)^2)*(x+5)*(x+4)*(x+3
)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5), 
35107258171359845084179525435407618773831534400/
915703816857849404640917564522276121948071371349*(-\
6145663200388251037858507144444806187570948801/
282390889283675147168353835717432070994405163007453*(x+5)*(x+4)*(x+3)*(x+2)*(x+
1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)-\
915703816857849404640917564522276121948071371349/
950811075029209249725097089957683740721902905749)^2*(x^2-1)^2, 1/34560*(x-1)^2+
1/34560*(x+1)^2+35107258171359845084179525435407618773831534400/
915703816857849404640917564522276121948071371349*(
6145663200388251037858507144444806187570948801/
282390889283675147168353835717432070994405163007453*(x+5)*(x+4)*(x+3)*(x+2)*(x+
1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)-\
915703816857849404640917564522276121948071371349/
950811075029209249725097089957683740721902905749)^2*(x^2-1)^2]
>> Degree size
34

>> Test
In between Natural Generator Test 6
>> input polynomial
(x-1)*(x-2)
>> basis
[-(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5), (x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)]
>> Time taken
1.011000
">> Sums of squares multipliers", [(x-1)*(x-2)+(6241/62208000*(x-2)^2*(x-19/79)
^2+900601/10668672000*(x-1)^2*(x-2738/949)^2+
109793675622970845558492523366151098650661793136826645725/
3121645677178468011301822108069544462841192149697406435328*(-\
1904603829883140946492874989670252875436968974800125952/
87248862525638849135228495048763780160280056456524293188431*(x+5)*(x+4)*(x+3)*(
x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)-\
3121645677178468011301822108069544462841192149697406435328/
3231439352801438856860314631435695561491853942834233081053)^2*(x^2-3*x+2)^2)*(x
+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)-\
109793675622970845558492523366151098650661793136826645725/
3121645677178468011301822108069544462841192149697406435328*(
1904603829883140946492874989670252875436968974800125952/
87248862525638849135228495048763780160280056456524293188431*(x+5)*(x+4)*(x+3)*(
x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)-\
3121645677178468011301822108069544462841192149697406435328/
3231439352801438856860314631435695561491853942834233081053)^2*(x^2-3*x+2)^2*(x+
5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5), 6241/62208000*(x-2)^2
*(x-19/79)^2+900601/10668672000*(x-1)^2*(x-2738/949)^2+
109793675622970845558492523366151098650661793136826645725/
3121645677178468011301822108069544462841192149697406435328*(-\
1904603829883140946492874989670252875436968974800125952/
87248862525638849135228495048763780160280056456524293188431*(x+5)*(x+4)*(x+3)*(
x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)-\
3121645677178468011301822108069544462841192149697406435328/
3231439352801438856860314631435695561491853942834233081053)^2*(x^2-3*x+2)^2, 
109793675622970845558492523366151098650661793136826645725/
3121645677178468011301822108069544462841192149697406435328*(
1904603829883140946492874989670252875436968974800125952/
87248862525638849135228495048763780160280056456524293188431*(x+5)*(x+4)*(x+3)*(
x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)-\
3121645677178468011301822108069544462841192149697406435328/
3231439352801438856860314631435695561491853942834233081053)^2*(x^2-3*x+2)^2]
>> Degree size
34

>> Test
In between Natural Generator Test 7
>> input polynomial
(x-2)*(x-3)
>> basis
[-(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5), (x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)]
>> Time taken
6.295000
">> Sums of squares multipliers", [(x-2)*(x-3)+(13/19282141*(x+4999/1000)^2+
11742/112235*(-136173/6041606845*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3
)*(x-4)*(x-5)-1206397220/1208321369)^9448)*(x^2-5*x+6)^2*(x+5)*(x+4)*(x+3)*(x+2
)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)-(534361/10668672000*(x-3)^2*(x-622/731)^2
+5870929/75866112000*(x-2)^2*(x-8949/2423)^2)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-\
1)*(x-2)*(x-3)*(x-4)*(x-5), (13/19282141*(x+4999/1000)^2+11742/112235*(-136173/
6041606845*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)-\
1206397220/1208321369)^9448)*(x^2-5*x+6)^2, 534361/10668672000*(x-3)^2*(x-622/
731)^2+5870929/75866112000*(x-2)^2*(x-8949/2423)^2]
>> Degree size
94494

>> Test
In between Natural Generator Test 8
>> input polynomial
(x-3)*(x-4)
>> basis
[-(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5), (x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)]
>> Time taken
0.810000
">> Sums of squares multipliers", [(x-3)*(x-4)+(877969/75866112000*(x-4)^2*(x-\
1131/937)^2+81342361/2304433152000*(x-3)^2*(x-41116/9019)^2+
862444120608030421269424647457444457457109/
7241115730827552591103583902248960000000000*(-\
1799929339007594479518663659520000000000/
89139158365791413136103094046770449032028199*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1
)*(x-2)*(x-3)*(x-4)*(x-5)-7241115730827552591103583902248960000000000/
8103559851435583012373008549706404457457109)^2*(x^2-7*x+12)^2)*(x+5)*(x+4)*(x+3
)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)-\
862444120608030421269424647457444457457109/
7241115730827552591103583902248960000000000*(
1799929339007594479518663659520000000000/
89139158365791413136103094046770449032028199*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1
)*(x-2)*(x-3)*(x-4)*(x-5)-7241115730827552591103583902248960000000000/
8103559851435583012373008549706404457457109)^2*(x^2-7*x+12)^2*(x+5)*(x+4)*(x+3)
*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5), 877969/75866112000*(x-4)^2*(x-1131/
937)^2+81342361/2304433152000*(x-3)^2*(x-41116/9019)^2+
862444120608030421269424647457444457457109/
7241115730827552591103583902248960000000000*(-\
1799929339007594479518663659520000000000/
89139158365791413136103094046770449032028199*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1
)*(x-2)*(x-3)*(x-4)*(x-5)-7241115730827552591103583902248960000000000/
8103559851435583012373008549706404457457109)^2*(x^2-7*x+12)^2, 
862444120608030421269424647457444457457109/
7241115730827552591103583902248960000000000*(
1799929339007594479518663659520000000000/
89139158365791413136103094046770449032028199*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1
)*(x-2)*(x-3)*(x-4)*(x-5)-7241115730827552591103583902248960000000000/
8103559851435583012373008549706404457457109)^2*(x^2-7*x+12)^2]
>> Degree size
34

>> Test
In between Natural Generator Test 9
>> input polynomial
(x-4)*(x-5)
>> basis
[-(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5), (x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)]
>> Time taken
6.762000
">> Sums of squares multipliers", [(x-4)*(x-5)+(12/169356731*(x+4999/1000)^2+
1751/583026*(-138909/6243887224*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)
*(x-4)*(x-5)-1538295325/1560971806)^820)*(x^2-9*x+20)^2*(x+5)*(x+4)*(x+3)*(x+2)
*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)-(1/90720*(x-5)^2+142014889/18435465216000*
(x-4)^2*(x-64625/11917)^2)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4
)*(x-5), (12/169356731*(x+4999/1000)^2+1751/583026*(-138909/6243887224*(x+5)*(x
+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)-1538295325/1560971806)^820)
*(x^2-9*x+20)^2, 1/90720*(x-5)^2+142014889/18435465216000*(x-4)^2*(x-64625/
11917)^2]
>> Degree size
8214

>> Test
Right Natural Generator Test
>> input polynomial
-x+5
>> basis
[-(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5), (x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)]
>> Time taken
0.030000
">> Sums of squares multipliers", [-x+5+1/725760*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*
(x-1)*(x-2)*(x-3)*(x-4)*(x-5), 1/725760, 0]
>> Degree size
10

>> Start benchmark

>> Test
Left Natural Generator Test
>> input polynomial
x+6
>> basis
[-(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6), (x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)]
>> Time taken
0.040000
">> Sums of squares multipliers", [x+6+1/79833600*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)
*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6), 1/79833600, 0]
>> Degree size
12

>> Test
In between Natural Generator Test 1
>> input polynomial
(x+6)*(x+5)
>> basis
[-(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6), (x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)]
>> Time taken
20.619000
">> Sums of squares multipliers", [(x+6)*(x+5)+(1/3375682612*(x+5999/1000)^2+
733/3621078*(-25/116868824*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3
)*(x-4)*(x-5)*(x-6)-114497545/116868824)^698)*(x^2+11*x+30)^2*(x+6)*(x+5)*(x+4)
*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)-(18725459281/
245376042024960000*(x+5)^2*(x+876486/136841)^2+1/7983360*(x+6)^2)*(x+6)*(x+5)*(
x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6), (1/3375682612*(x+
5999/1000)^2+733/3621078*(-25/116868824*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-\
1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)-114497545/116868824)^698)*(x^2+11*x+30)^2, 
18725459281/245376042024960000*(x+5)^2*(x+876486/136841)^2+1/7983360*(x+6)^2]
>> Degree size
8392

>> Test
In between Natural Generator Test 2
>> input polynomial
(x+5)*(x+4)
>> basis
[-(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6), (x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)]
>> Time taken
1.379000
">> Sums of squares multipliers", [(x+5)*(x+4)+(11212056769/24537604202496000*(
x+4)^2*(x+584875/105887)^2+1/1814400*(x+5)^2+
351035519714892672287885308249605047169669785508864000/
1465798871775104603164406695161605630440542984774525749*(-\
961110892254327135414194457682438193231134944961/
5450503174469991826356876010233632032830638310850169247*(x+6)*(x+5)*(x+4)*(x+3)
*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)-\
1465798871775104603164406695161605630440542984774525749/
1816834391489997275452292003411210677610212770283389749)^2*(x^2+9*x+20)^2)*(x+6
)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)-\
351035519714892672287885308249605047169669785508864000/
1465798871775104603164406695161605630440542984774525749*(
961110892254327135414194457682438193231134944961/
5450503174469991826356876010233632032830638310850169247*(x+6)*(x+5)*(x+4)*(x+3)
*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)-\
1465798871775104603164406695161605630440542984774525749/
1816834391489997275452292003411210677610212770283389749)^2*(x^2+9*x+20)^2*(x+6)
*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6), 11212056769
/24537604202496000*(x+4)^2*(x+584875/105887)^2+1/1814400*(x+5)^2+
351035519714892672287885308249605047169669785508864000/
1465798871775104603164406695161605630440542984774525749*(-\
961110892254327135414194457682438193231134944961/
5450503174469991826356876010233632032830638310850169247*(x+6)*(x+5)*(x+4)*(x+3)
*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)-\
1465798871775104603164406695161605630440542984774525749/
1816834391489997275452292003411210677610212770283389749)^2*(x^2+9*x+20)^2, 
351035519714892672287885308249605047169669785508864000/
1465798871775104603164406695161605630440542984774525749*(
961110892254327135414194457682438193231134944961/
5450503174469991826356876010233632032830638310850169247*(x+6)*(x+5)*(x+4)*(x+3)
*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)-\
1465798871775104603164406695161605630440542984774525749/
1816834391489997275452292003411210677610212770283389749)^2*(x^2+9*x+20)^2]
>> Degree size
40

>> Test
In between Natural Generator Test 3
>> input polynomial
(x+4)*(x+3)
>> basis
[-(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6), (x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)]
>> Time taken
19.421000
">> Sums of squares multipliers", [(x+4)*(x+3)+(3/428520838*(x+5999/1000)^2+
1823/274006*(-100/458549193*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-\
3)*(x-4)*(x-5)*(x-6)-457990180/458549193)^14278)*(x^2+7*x+12)^2*(x+6)*(x+5)*(x+
4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)-(64176121/
46088663040000*(x+3)^2*(x+37084/8011)^2+11363641/18435465216000*(x+4)^2*(x+5073
/3371)^2)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-\
6), (3/428520838*(x+5999/1000)^2+1823/274006*(-100/458549193*(x+6)*(x+5)*(x+4)*
(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)-457990180/458549193)^
14278)*(x^2+7*x+12)^2, 64176121/46088663040000*(x+3)^2*(x+37084/8011)^2+
11363641/18435465216000*(x+4)^2*(x+5073/3371)^2]
>> Degree size
171352

>> Test
In between Natural Generator Test 4
>> input polynomial
(x+3)*(x+2)
>> basis
[-(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6), (x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)]
>> Time taken
3.153000
">> Sums of squares multipliers", [(x+3)*(x+2)+(45010681/18435465216000*(x+2)^2
*(x+25167/6709)^2+2455489/1365590016000*(x+3)^2*(x+1454/1567)^2+
798746651183794748054819756675968777399034696336037471436800/
57675503391528150794637167380099636254999062130599182810704869*(-\
37817299216992458109313607997919910153962150987633790641/
175422750128135836628075961410326815097194290480805660846425007*(x+6)*(x+5)*(x+
4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)-\
57675503391528150794637167380099636254999062130599182810704869/
58474250042711945542691987136775605032398096826935220282141669)^2*(x^2+5*x+6)^2
)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)-\
798746651183794748054819756675968777399034696336037471436800/
57675503391528150794637167380099636254999062130599182810704869*(
37817299216992458109313607997919910153962150987633790641/
175422750128135836628075961410326815097194290480805660846425007*(x+6)*(x+5)*(x+
4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)-\
57675503391528150794637167380099636254999062130599182810704869/
58474250042711945542691987136775605032398096826935220282141669)^2*(x^2+5*x+6)^2
*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6), 
45010681/18435465216000*(x+2)^2*(x+25167/6709)^2+2455489/1365590016000*(x+3)^2*
(x+1454/1567)^2+798746651183794748054819756675968777399034696336037471436800/
57675503391528150794637167380099636254999062130599182810704869*(-\
37817299216992458109313607997919910153962150987633790641/
175422750128135836628075961410326815097194290480805660846425007*(x+6)*(x+5)*(x+
4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)-\
57675503391528150794637167380099636254999062130599182810704869/
58474250042711945542691987136775605032398096826935220282141669)^2*(x^2+5*x+6)^2
, 798746651183794748054819756675968777399034696336037471436800/
57675503391528150794637167380099636254999062130599182810704869*(
37817299216992458109313607997919910153962150987633790641/
175422750128135836628075961410326815097194290480805660846425007*(x+6)*(x+5)*(x+
4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)-\
57675503391528150794637167380099636254999062130599182810704869/
58474250042711945542691987136775605032398096826935220282141669)^2*(x^2+5*x+6)^2
]
>> Degree size
40

>> Test
In between Natural Generator Test 5
>> input polynomial
(x+2)*(x+1)
>> basis
[-(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6), (x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)]
>> Time taken
19.329000
">> Sums of squares multipliers", [(x+2)*(x+1)+(12/644997143*(x+5999/1000)^2+
4646/264521*(-10/45832721*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)
*(x-4)*(x-5)*(x-6)-45799018/45832721)^24352)*(x^2+3*x+2)^2*(x+6)*(x+5)*(x+4)*(x
+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)-(3214849/1365590016000*(x+1
)^2*(x+5266/1793)^2+12769/4267468800*(x+2)^2*(x+29/113)^2)*(x+6)*(x+5)*(x+4)*(x
+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6), (12/644997143*(x+5999/1000
)^2+4646/264521*(-10/45832721*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(
x-3)*(x-4)*(x-5)*(x-6)-45799018/45832721)^24352)*(x^2+3*x+2)^2, 3214849/
1365590016000*(x+1)^2*(x+5266/1793)^2+12769/4267468800*(x+2)^2*(x+29/113)^2]
>> Degree size
292240

>> Test
In between Natural Generator Test 6
>> input polynomial
(x+1)*(x-1)
>> basis
[-(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6), (x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)]
>> Time taken
0.940000
">> Sums of squares multipliers", [(x+1)*(x-1)+(1/1209600*(x-1)^2+1/1209600*(x+
1)^2+73541007629523776108297380900571483609320244032000/
1203023044593140728612672182580308555528915846566847*(-\
262937063207316270205970454697622389728409761/
1276564052222664504720969563480880039138236090598847*(x+6)*(x+5)*(x+4)*(x+3)*(x
+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)-\
1203023044593140728612672182580308555528915846566847/
1276564052222664504720969563480880039138236090598847)^2*(x^2-1)^2)*(x+6)*(x+5)*
(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)-\
73541007629523776108297380900571483609320244032000/
1203023044593140728612672182580308555528915846566847*(
262937063207316270205970454697622389728409761/
1276564052222664504720969563480880039138236090598847*(x+6)*(x+5)*(x+4)*(x+3)*(x
+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)-\
1203023044593140728612672182580308555528915846566847/
1276564052222664504720969563480880039138236090598847)^2*(x^2-1)^2*(x+6)*(x+5)*(
x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6), 1/1209600*(x-1)^2+1
/1209600*(x+1)^2+73541007629523776108297380900571483609320244032000/
1203023044593140728612672182580308555528915846566847*(-\
262937063207316270205970454697622389728409761/
1276564052222664504720969563480880039138236090598847*(x+6)*(x+5)*(x+4)*(x+3)*(x
+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)-\
1203023044593140728612672182580308555528915846566847/
1276564052222664504720969563480880039138236090598847)^2*(x^2-1)^2, 
73541007629523776108297380900571483609320244032000/
1203023044593140728612672182580308555528915846566847*(
262937063207316270205970454697622389728409761/
1276564052222664504720969563480880039138236090598847*(x+6)*(x+5)*(x+4)*(x+3)*(x
+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)-\
1203023044593140728612672182580308555528915846566847/
1276564052222664504720969563480880039138236090598847)^2*(x^2-1)^2]
>> Degree size
40

>> Test
In between Natural Generator Test 7
>> input polynomial
(x-1)*(x-2)
>> basis
[-(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6), (x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)]
>> Time taken
21.789000
">> Sums of squares multipliers", [(x-1)*(x-2)+(6/321262423*(x+5999/1000)^2+
1747/71203*(-100/458157879*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3
)*(x-4)*(x-5)*(x-6)-457990180/458157879)^49852)*(x^2-3*x+2)^2*(x+6)*(x+5)*(x+4)
*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)-(12769/4267468800*(x-2)^
2*(x-29/113)^2+3214849/1365590016000*(x-1)^2*(x-5266/1793)^2)*(x+6)*(x+5)*(x+4)
*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6), (6/321262423*(x+5999/
1000)^2+1747/71203*(-100/458157879*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x
-2)*(x-3)*(x-4)*(x-5)*(x-6)-457990180/458157879)^49852)*(x^2-3*x+2)^2, 12769/
4267468800*(x-2)^2*(x-29/113)^2+3214849/1365590016000*(x-1)^2*(x-5266/1793)^2]
>> Degree size
598240

>> Test
In between Natural Generator Test 8
>> input polynomial
(x-2)*(x-3)
>> basis
[-(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6), (x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)]
>> Time taken
3.077000
">> Sums of squares multipliers", [(x-2)*(x-3)+(2455489/1365590016000*(x-3)^2*(
x-1454/1567)^2+45010681/18435465216000*(x-2)^2*(x-25167/6709)^2+
798746651183794748054819756675968777399034696336037471436800/
57675503391528150794637167380099636254999062130599182810704869*(-\
37817299216992458109313607997919910153962150987633790641/
175422750128135836628075961410326815097194290480805660846425007*(x+6)*(x+5)*(x+
4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)-\
57675503391528150794637167380099636254999062130599182810704869/
58474250042711945542691987136775605032398096826935220282141669)^2*(x^2-5*x+6)^2
)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)-\
798746651183794748054819756675968777399034696336037471436800/
57675503391528150794637167380099636254999062130599182810704869*(
37817299216992458109313607997919910153962150987633790641/
175422750128135836628075961410326815097194290480805660846425007*(x+6)*(x+5)*(x+
4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)-\
57675503391528150794637167380099636254999062130599182810704869/
58474250042711945542691987136775605032398096826935220282141669)^2*(x^2-5*x+6)^2
*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6), 
2455489/1365590016000*(x-3)^2*(x-1454/1567)^2+45010681/18435465216000*(x-2)^2*(
x-25167/6709)^2+798746651183794748054819756675968777399034696336037471436800/
57675503391528150794637167380099636254999062130599182810704869*(-\
37817299216992458109313607997919910153962150987633790641/
175422750128135836628075961410326815097194290480805660846425007*(x+6)*(x+5)*(x+
4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)-\
57675503391528150794637167380099636254999062130599182810704869/
58474250042711945542691987136775605032398096826935220282141669)^2*(x^2-5*x+6)^2
, 798746651183794748054819756675968777399034696336037471436800/
57675503391528150794637167380099636254999062130599182810704869*(
37817299216992458109313607997919910153962150987633790641/
175422750128135836628075961410326815097194290480805660846425007*(x+6)*(x+5)*(x+
4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)-\
57675503391528150794637167380099636254999062130599182810704869/
58474250042711945542691987136775605032398096826935220282141669)^2*(x^2-5*x+6)^2
]
>> Degree size
40

>> Test
In between Natural Generator Test 9
>> input polynomial
(x-3)*(x-4)
>> basis
[-(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6), (x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)]
>> Time taken
22.691000
">> Sums of squares multipliers", [(x-3)*(x-4)+(6/821964091*(x+5999/1000)^2+
1835/217243*(-50/229133897*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3
)*(x-4)*(x-5)*(x-6)-228995090/229133897)^29136)*(x^2-7*x+12)^2*(x+6)*(x+5)*(x+4
)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)-(11363641/
18435465216000*(x-4)^2*(x-5073/3371)^2+64176121/46088663040000*(x-3)^2*(x-37084
/8011)^2)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-\
6), (6/821964091*(x+5999/1000)^2+1835/217243*(-50/229133897*(x+6)*(x+5)*(x+4)*(
x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)-228995090/229133897)^29136
)*(x^2-7*x+12)^2, 11363641/18435465216000*(x-4)^2*(x-5073/3371)^2+64176121/
46088663040000*(x-3)^2*(x-37084/8011)^2]
>> Degree size
349648

>> Test
In between Natural Generator Test 10
>> input polynomial
(x-4)*(x-5)
>> basis
[-(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6), (x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)]
>> Time taken
1.477000
">> Sums of squares multipliers", [(x-4)*(x-5)+(1/1814400*(x-5)^2+11212056769/
24537604202496000*(x-4)^2*(x-584875/105887)^2+
351035519714892672287885308249605047169669785508864000/
1465798871775104603164406695161605630440542984774525749*(-\
961110892254327135414194457682438193231134944961/
5450503174469991826356876010233632032830638310850169247*(x+6)*(x+5)*(x+4)*(x+3)
*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)-\
1465798871775104603164406695161605630440542984774525749/
1816834391489997275452292003411210677610212770283389749)^2*(x^2-9*x+20)^2)*(x+6
)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)-\
351035519714892672287885308249605047169669785508864000/
1465798871775104603164406695161605630440542984774525749*(
961110892254327135414194457682438193231134944961/
5450503174469991826356876010233632032830638310850169247*(x+6)*(x+5)*(x+4)*(x+3)
*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)-\
1465798871775104603164406695161605630440542984774525749/
1816834391489997275452292003411210677610212770283389749)^2*(x^2-9*x+20)^2*(x+6)
*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6), 1/1814400*(
x-5)^2+11212056769/24537604202496000*(x-4)^2*(x-584875/105887)^2+
351035519714892672287885308249605047169669785508864000/
1465798871775104603164406695161605630440542984774525749*(-\
961110892254327135414194457682438193231134944961/
5450503174469991826356876010233632032830638310850169247*(x+6)*(x+5)*(x+4)*(x+3)
*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)-\
1465798871775104603164406695161605630440542984774525749/
1816834391489997275452292003411210677610212770283389749)^2*(x^2-9*x+20)^2, 
351035519714892672287885308249605047169669785508864000/
1465798871775104603164406695161605630440542984774525749*(
961110892254327135414194457682438193231134944961/
5450503174469991826356876010233632032830638310850169247*(x+6)*(x+5)*(x+4)*(x+3)
*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)-\
1465798871775104603164406695161605630440542984774525749/
1816834391489997275452292003411210677610212770283389749)^2*(x^2-9*x+20)^2]
>> Degree size
40

>> Test
In between Natural Generator Test 11
>> input polynomial
(x-5)*(x-6)
>> basis
[-(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6), (x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)]
>> Time taken
23.698000
">> Sums of squares multipliers", [(x-5)*(x-6)+(1/1756649615*(x+5999/1000)^2+89
/1037866*(-25/115643947*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(
x-4)*(x-5)*(x-6)-114497545/115643947)^1350)*(x^2-11*x+30)^2*(x+6)*(x+5)*(x+4)*(
x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)-(1/7983360*(x-6)^2+
18725459281/245376042024960000*(x-5)^2*(x-876486/136841)^2)*(x+6)*(x+5)*(x+4)*(
x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6), (1/1756649615*(x+5999/
1000)^2+89/1037866*(-25/115643947*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-\
2)*(x-3)*(x-4)*(x-5)*(x-6)-114497545/115643947)^1350)*(x^2-11*x+30)^2, 1/
7983360*(x-6)^2+18725459281/245376042024960000*(x-5)^2*(x-876486/136841)^2]
>> Degree size
16216

>> Test
Right Natural Generator Test
>> input polynomial
-x+6
>> basis
[-(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6), (x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)]
>> Time taken
0.039000
">> Sums of squares multipliers", [-x+6+1/79833600*(x+6)*(x+5)*(x+4)*(x+3)*(x+2
)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6), 1/79833600, 0]
>> Degree size
12

>> Start benchmark

>> Test
Left Natural Generator Test
>> input polynomial
x+7
>> basis
[-(x+7)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7), (x+7)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7)]
>> Time taken
0.052000
">> Sums of squares multipliers", [x+7+1/12454041600*(x+7)*(x+6)*(x+5)*(x+4)*(x
+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7), 1/12454041600, 0]
>> Degree size
14

>> Test
In between Natural Generator Test 1
>> input polynomial
(x+7)*(x+6)
>> basis
[-(x+7)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7), (x+7)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7)]
>> Time taken
67.728000
">> Sums of squares multipliers", [(x+7)*(x+6)+(1/683790082760*(x+6999/1000)^2+
71/10035178*(-10/6904885701*(x+7)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-\
2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7)-972021680/986412243)^1108)*(x^2+13*x+42)^2*(x+
7)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7
)-(3389181586729/6469093971946045440000*(x+6)^2*(x+13607531/1840973)^2+1/
1037836800*(x+7)^2)*(x+7)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)
*(x-4)*(x-5)*(x-6)*(x-7), (1/683790082760*(x+6999/1000)^2+71/10035178*(-10/
6904885701*(x+7)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x
-5)*(x-6)*(x-7)-972021680/986412243)^1108)*(x^2+13*x+42)^2, 3389181586729/
6469093971946045440000*(x+6)^2*(x+13607531/1840973)^2+1/1037836800*(x+7)^2]
>> Degree size
15530

>> Test
In between Natural Generator Test 2
>> input polynomial
(x+6)*(x+5)
>> basis
[-(x+7)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7), (x+7)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7)]
>> Time taken
2.113000
">> Sums of squares multipliers", [(x+6)*(x+5)+(2091763441849/
539091164328837120000*(x+5)^2*(x+9398478/1446293)^2+1/191600640*(x+6)^2+
18285330189709646386338824840935533297960811007123799943021754368000/
109556848744048640787447348456049509897631990187836088595131419058481*(-\
161175717560742724758860337819529417977481398337128785812569/
127842178933758287173786173296985043195592801194959888538153173426481*(x+7)*(x+
6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7)-\
109556848744048640787447348456049509897631990187836088595131419058481/
127842178933758287173786173296985043195592801194959888538153173426481)^2*(x^2+
11*x+30)^2)*(x+7)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(
x-5)*(x-6)*(x-7)-\
18285330189709646386338824840935533297960811007123799943021754368000/
109556848744048640787447348456049509897631990187836088595131419058481*(
161175717560742724758860337819529417977481398337128785812569/
127842178933758287173786173296985043195592801194959888538153173426481*(x+7)*(x+
6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7)-\
109556848744048640787447348456049509897631990187836088595131419058481/
127842178933758287173786173296985043195592801194959888538153173426481)^2*(x^2+
11*x+30)^2*(x+7)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x
-5)*(x-6)*(x-7), 2091763441849/539091164328837120000*(x+5)^2*(x+9398478/1446293
)^2+1/191600640*(x+6)^2+
18285330189709646386338824840935533297960811007123799943021754368000/
109556848744048640787447348456049509897631990187836088595131419058481*(-\
161175717560742724758860337819529417977481398337128785812569/
127842178933758287173786173296985043195592801194959888538153173426481*(x+7)*(x+
6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7)-\
109556848744048640787447348456049509897631990187836088595131419058481/
127842178933758287173786173296985043195592801194959888538153173426481)^2*(x^2+
11*x+30)^2, 
18285330189709646386338824840935533297960811007123799943021754368000/
109556848744048640787447348456049509897631990187836088595131419058481*(
161175717560742724758860337819529417977481398337128785812569/
127842178933758287173786173296985043195592801194959888538153173426481*(x+7)*(x+
6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7)-\
109556848744048640787447348456049509897631990187836088595131419058481/
127842178933758287173786173296985043195592801194959888538153173426481)^2*(x^2+
11*x+30)^2]
>> Degree size
46

>> Test
In between Natural Generator Test 3
>> input polynomial
(x+5)*(x+4)
>> basis
[-(x+7)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7), (x+7)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7)]
>> Time taken
62.272000
">> Sums of squares multipliers", [(x+5)*(x+4)+(1/19637172895*(x+6999/1000)^2+
451/1369036*(-5/3403991589*(x+7)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2
)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7)-3402075880/3403991589)^35170)*(x^2+9*x+20)^2*(x
+7)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-\
7)-(8899469569/588902500859904000*(x+4)^2*(x+527125/94337)^2+869011441/
184032031518720000*(x+5)^2*(x+62476/29479)^2)*(x+7)*(x+6)*(x+5)*(x+4)*(x+3)*(x+
2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7), (1/19637172895*(x+6999/1000
)^2+451/1369036*(-5/3403991589*(x+7)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*
(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7)-3402075880/3403991589)^35170)*(x^2+9*x+20)^
2, 8899469569/588902500859904000*(x+4)^2*(x+527125/94337)^2+869011441/
184032031518720000*(x+5)^2*(x+62476/29479)^2]
>> Degree size
492398

>> Test
In between Natural Generator Test 4
>> input polynomial
(x+4)*(x+3)
>> basis
[-(x+7)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7), (x+7)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7)]
>> Time taken
9.823000
">> Sums of squares multipliers", [(x+4)*(x+3)+(6626122801/184032031518720000*(
x+3)^2*(x+381044/81401)^2+14055001/737418608640000*(x+4)^2*(x+6207/3749)^2+
16670145999540901481866511711027728833004978872294361683530868736000/
2392865598427160215215282064159135267907084878292101235270565495721041*(-\
3520289550806052216375259346168269749761255835712786600998009/
2409535744426701116697148575870162996740089857164395596954096364457041*(x+7)*(x
+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7)-\
2392865598427160215215282064159135267907084878292101235270565495721041/
2409535744426701116697148575870162996740089857164395596954096364457041)^2*(x^2+
7*x+12)^2)*(x+7)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x
-5)*(x-6)*(x-7)-\
16670145999540901481866511711027728833004978872294361683530868736000/
2392865598427160215215282064159135267907084878292101235270565495721041*(
3520289550806052216375259346168269749761255835712786600998009/
2409535744426701116697148575870162996740089857164395596954096364457041*(x+7)*(x
+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7)-\
2392865598427160215215282064159135267907084878292101235270565495721041/
2409535744426701116697148575870162996740089857164395596954096364457041)^2*(x^2+
7*x+12)^2*(x+7)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-\
5)*(x-6)*(x-7), 6626122801/184032031518720000*(x+3)^2*(x+381044/81401)^2+
14055001/737418608640000*(x+4)^2*(x+6207/3749)^2+
16670145999540901481866511711027728833004978872294361683530868736000/
2392865598427160215215282064159135267907084878292101235270565495721041*(-\
3520289550806052216375259346168269749761255835712786600998009/
2409535744426701116697148575870162996740089857164395596954096364457041*(x+7)*(x
+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7)-\
2392865598427160215215282064159135267907084878292101235270565495721041/
2409535744426701116697148575870162996740089857164395596954096364457041)^2*(x^2+
7*x+12)^2, 16670145999540901481866511711027728833004978872294361683530868736000
/2392865598427160215215282064159135267907084878292101235270565495721041*(
3520289550806052216375259346168269749761255835712786600998009/
2409535744426701116697148575870162996740089857164395596954096364457041*(x+7)*(x
+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7)-\
2392865598427160215215282064159135267907084878292101235270565495721041/
2409535744426701116697148575870162996740089857164395596954096364457041)^2*(x^2+
7*x+12)^2]
>> Degree size
46

>> Test
In between Natural Generator Test 5
>> input polynomial
(x+3)*(x+2)
>> basis
[-(x+7)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7), (x+7)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7)]
>> Time taken
55.351000
">> Sums of squares multipliers", [(x+3)*(x+2)+(1/3998238301*(x+6999/1000)^2+
941/549775*(-2/1361056239*(x+7)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)
*(x-3)*(x-4)*(x-5)*(x-6)*(x-7)-1360830352/1361056239)^126600)*(x^2+5*x+6)^2*(x+
7)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7
)-(40081561/737418608640000*(x+2)^2*(x+24033/6331)^2+38809/884902330368*(x+3)^2
*(x+962/985)^2)*(x+7)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-\
4)*(x-5)*(x-6)*(x-7), (1/3998238301*(x+6999/1000)^2+941/549775*(-2/1361056239*(
x+7)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x
-7)-1360830352/1361056239)^126600)*(x^2+5*x+6)^2, 40081561/737418608640000*(x+2
)^2*(x+24033/6331)^2+38809/884902330368*(x+3)^2*(x+962/985)^2]
>> Degree size
1772418

>> Test
In between Natural Generator Test 6
>> input polynomial
(x+2)*(x+1)
>> basis
[-(x+7)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7), (x+7)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7)]
>> Time taken
42.654000
">> Sums of squares multipliers", [(x+2)*(x+1)+(1062961/22122558259200*(x+1)^2*
(x+3070/1031)^2+289/4495769600*(x+2)^2*(x+41/153)^2+
8527597564271384292003629965615590265884176082521173220408494080000/
2068355580308997672985021199792597461791561189590101261196616666546803*(-\
82157846483511759838489124309890348926575038929494957165767369/
56075845802578264546479670403471752405551024873160805729259679336923681*(x+7)*(
x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7)-\
2068355580308997672985021199792597461791561189590101261196616666546803/
2076883177873269057277024829758213052057445365672622434417025160626803)^2*(x^2+
3*x+2)^2)*(x+7)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-\
5)*(x-6)*(x-7)-\
8527597564271384292003629965615590265884176082521173220408494080000/
2068355580308997672985021199792597461791561189590101261196616666546803*(
82157846483511759838489124309890348926575038929494957165767369/
56075845802578264546479670403471752405551024873160805729259679336923681*(x+7)*(
x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7)-\
2068355580308997672985021199792597461791561189590101261196616666546803/
2076883177873269057277024829758213052057445365672622434417025160626803)^2*(x^2+
3*x+2)^2*(x+7)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5
)*(x-6)*(x-7), 1062961/22122558259200*(x+1)^2*(x+3070/1031)^2+289/4495769600*(x
+2)^2*(x+41/153)^2+
8527597564271384292003629965615590265884176082521173220408494080000/
2068355580308997672985021199792597461791561189590101261196616666546803*(-\
82157846483511759838489124309890348926575038929494957165767369/
56075845802578264546479670403471752405551024873160805729259679336923681*(x+7)*(
x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7)-\
2068355580308997672985021199792597461791561189590101261196616666546803/
2076883177873269057277024829758213052057445365672622434417025160626803)^2*(x^2+
3*x+2)^2, 8527597564271384292003629965615590265884176082521173220408494080000/
2068355580308997672985021199792597461791561189590101261196616666546803*(
82157846483511759838489124309890348926575038929494957165767369/
56075845802578264546479670403471752405551024873160805729259679336923681*(x+7)*(
x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7)-\
2068355580308997672985021199792597461791561189590101261196616666546803/
2076883177873269057277024829758213052057445365672622434417025160626803)^2*(x^2+
3*x+2)^2]
>> Degree size
46

>> Test
In between Natural Generator Test 7
>> input polynomial
(x+1)*(x-1)
>> basis
[-(x+7)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7), (x+7)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7)]
>> Time taken
54.149000
">> Sums of squares multipliers", [(x+1)*(x-1)+
4037354813292296763970496029226925670587043069883704356554672183533125/
508840634198711853751252487584943433310384588623802392113895972372742144*(-\
20211829681057608121426395057400445653939086959171765348190912512/
13847705703324112063911020557582599692486234055729524604702167403019432263*(x+7
)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7)
-508840634198711853751252487584943433310384588623802392113895972372742144/
512877989012004150515222983614170358980971631693686096470450644556275269)^2*(x^
2-1)^2*(x+7)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*
(x-6)*(x-7)-(1/58060800*(x-1)^2+1/58060800*(x+1)^2+
4037354813292296763970496029226925670587043069883704356554672183533125/
508840634198711853751252487584943433310384588623802392113895972372742144*(
20211829681057608121426395057400445653939086959171765348190912512/
13847705703324112063911020557582599692486234055729524604702167403019432263*(x+7
)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7)
-508840634198711853751252487584943433310384588623802392113895972372742144/
512877989012004150515222983614170358980971631693686096470450644556275269)^2*(x^
2-1)^2)*(x+7)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)
*(x-6)*(x-7), 
4037354813292296763970496029226925670587043069883704356554672183533125/
508840634198711853751252487584943433310384588623802392113895972372742144*(-\
20211829681057608121426395057400445653939086959171765348190912512/
13847705703324112063911020557582599692486234055729524604702167403019432263*(x+7
)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7)
-508840634198711853751252487584943433310384588623802392113895972372742144/
512877989012004150515222983614170358980971631693686096470450644556275269)^2*(x^
2-1)^2, 1/58060800*(x-1)^2+1/58060800*(x+1)^2+
4037354813292296763970496029226925670587043069883704356554672183533125/
508840634198711853751252487584943433310384588623802392113895972372742144*(
20211829681057608121426395057400445653939086959171765348190912512/
13847705703324112063911020557582599692486234055729524604702167403019432263*(x+7
)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7)
-508840634198711853751252487584943433310384588623802392113895972372742144/
512877989012004150515222983614170358980971631693686096470450644556275269)^2*(x^
2-1)^2]
>> Degree size
46

>> Test
In between Natural Generator Test 8
>> input polynomial
(x-1)*(x-2)
>> basis
[-(x+7)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7), (x+7)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7)]
>> Time taken
34.531000
">> Sums of squares multipliers", [(x-1)*(x-2)+(289/4495769600*(x-2)^2*(x-41/
153)^2+1062961/22122558259200*(x-1)^2*(x-3070/1031)^2+
8527597564271384292003629965615590265884176082521173220408494080000/
2068355580308997672985021199792597461791561189590101261196616666546803*(-\
82157846483511759838489124309890348926575038929494957165767369/
56075845802578264546479670403471752405551024873160805729259679336923681*(x+7)*(
x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7)-\
2068355580308997672985021199792597461791561189590101261196616666546803/
2076883177873269057277024829758213052057445365672622434417025160626803)^2*(x^2-\
3*x+2)^2)*(x+7)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-\
5)*(x-6)*(x-7)-\
8527597564271384292003629965615590265884176082521173220408494080000/
2068355580308997672985021199792597461791561189590101261196616666546803*(
82157846483511759838489124309890348926575038929494957165767369/
56075845802578264546479670403471752405551024873160805729259679336923681*(x+7)*(
x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7)-\
2068355580308997672985021199792597461791561189590101261196616666546803/
2076883177873269057277024829758213052057445365672622434417025160626803)^2*(x^2-\
3*x+2)^2*(x+7)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5
)*(x-6)*(x-7), 289/4495769600*(x-2)^2*(x-41/153)^2+1062961/22122558259200*(x-1)
^2*(x-3070/1031)^2+
8527597564271384292003629965615590265884176082521173220408494080000/
2068355580308997672985021199792597461791561189590101261196616666546803*(-\
82157846483511759838489124309890348926575038929494957165767369/
56075845802578264546479670403471752405551024873160805729259679336923681*(x+7)*(
x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7)-\
2068355580308997672985021199792597461791561189590101261196616666546803/
2076883177873269057277024829758213052057445365672622434417025160626803)^2*(x^2-\
3*x+2)^2, 8527597564271384292003629965615590265884176082521173220408494080000/
2068355580308997672985021199792597461791561189590101261196616666546803*(
82157846483511759838489124309890348926575038929494957165767369/
56075845802578264546479670403471752405551024873160805729259679336923681*(x+7)*(
x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7)-\
2068355580308997672985021199792597461791561189590101261196616666546803/
2076883177873269057277024829758213052057445365672622434417025160626803)^2*(x^2-\
3*x+2)^2]
>> Degree size
46

>> Test
In between Natural Generator Test 9
>> input polynomial
(x-2)*(x-3)
>> basis
[-(x+7)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7), (x+7)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7)]
>> Time taken
99.333000
">> Sums of squares multipliers", [(x-2)*(x-3)+(1/3958657886*(x+6999/1000)^2+
2054/891687*(-5/3402358931*(x+7)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2
)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7)-3402075880/3402358931)^256452)*(x^2-5*x+6)^2*(x
+7)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-\
7)-(38809/884902330368*(x-3)^2*(x-962/985)^2+40081561/737418608640000*(x-2)^2*(
x-24033/6331)^2)*(x+7)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x
-4)*(x-5)*(x-6)*(x-7), (1/3958657886*(x+6999/1000)^2+2054/891687*(-5/3402358931
*(x+7)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*
(x-7)-3402075880/3402358931)^256452)*(x^2-5*x+6)^2, 38809/884902330368*(x-3)^2*
(x-962/985)^2+40081561/737418608640000*(x-2)^2*(x-24033/6331)^2]
>> Degree size
3590346

>> Test
In between Natural Generator Test 10
>> input polynomial
(x-3)*(x-4)
>> basis
[-(x+7)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7), (x+7)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7)]
>> Time taken
11.185000
">> Sums of squares multipliers", [(x-3)*(x-4)+(14055001/737418608640000*(x-4)^
2*(x-6207/3749)^2+6626122801/184032031518720000*(x-3)^2*(x-381044/81401)^2+
16670145999540901481866511711027728833004978872294361683530868736000/
2392865598427160215215282064159135267907084878292101235270565495721041*(-\
3520289550806052216375259346168269749761255835712786600998009/
2409535744426701116697148575870162996740089857164395596954096364457041*(x+7)*(x
+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7)-\
2392865598427160215215282064159135267907084878292101235270565495721041/
2409535744426701116697148575870162996740089857164395596954096364457041)^2*(x^2-\
7*x+12)^2)*(x+7)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x
-5)*(x-6)*(x-7)-\
16670145999540901481866511711027728833004978872294361683530868736000/
2392865598427160215215282064159135267907084878292101235270565495721041*(
3520289550806052216375259346168269749761255835712786600998009/
2409535744426701116697148575870162996740089857164395596954096364457041*(x+7)*(x
+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7)-\
2392865598427160215215282064159135267907084878292101235270565495721041/
2409535744426701116697148575870162996740089857164395596954096364457041)^2*(x^2-\
7*x+12)^2*(x+7)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-\
5)*(x-6)*(x-7), 14055001/737418608640000*(x-4)^2*(x-6207/3749)^2+6626122801/
184032031518720000*(x-3)^2*(x-381044/81401)^2+
16670145999540901481866511711027728833004978872294361683530868736000/
2392865598427160215215282064159135267907084878292101235270565495721041*(-\
3520289550806052216375259346168269749761255835712786600998009/
2409535744426701116697148575870162996740089857164395596954096364457041*(x+7)*(x
+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7)-\
2392865598427160215215282064159135267907084878292101235270565495721041/
2409535744426701116697148575870162996740089857164395596954096364457041)^2*(x^2-\
7*x+12)^2, 16670145999540901481866511711027728833004978872294361683530868736000
/2392865598427160215215282064159135267907084878292101235270565495721041*(
3520289550806052216375259346168269749761255835712786600998009/
2409535744426701116697148575870162996740089857164395596954096364457041*(x+7)*(x
+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7)-\
2392865598427160215215282064159135267907084878292101235270565495721041/
2409535744426701116697148575870162996740089857164395596954096364457041)^2*(x^2-\
7*x+12)^2]
>> Degree size
46

>> Test
In between Natural Generator Test 11
>> input polynomial
(x-4)*(x-5)
>> basis
[-(x+7)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7), (x+7)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7)]
>> Time taken
121.553000
">> Sums of squares multipliers", [(x-4)*(x-5)+(1/19122962979*(x+6999/1000)^2+
489/1132583*(-10/6806063011*(x+7)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-\
2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7)-6804151760/6806063011)^71496)*(x^2-9*x+20)^2*(
x+7)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x
-7)-(869011441/184032031518720000*(x-5)^2*(x-62476/29479)^2+8899469569/
588902500859904000*(x-4)^2*(x-527125/94337)^2)*(x+7)*(x+6)*(x+5)*(x+4)*(x+3)*(x
+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7), (1/19122962979*(x+6999/
1000)^2+489/1132583*(-10/6806063011*(x+7)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(
x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7)-6804151760/6806063011)^71496)*(x^2-9*x
+20)^2, 869011441/184032031518720000*(x-5)^2*(x-62476/29479)^2+8899469569/
588902500859904000*(x-4)^2*(x-527125/94337)^2]
>> Degree size
1000962

>> Test
In between Natural Generator Test 12
>> input polynomial
(x-5)*(x-6)
>> basis
[-(x+7)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7), (x+7)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7)]
>> Time taken
3.707000
">> Sums of squares multipliers", [(x-5)*(x-6)+(1/191600640*(x-6)^2+
2091763441849/539091164328837120000*(x-5)^2*(x-9398478/1446293)^2+
18285330189709646386338824840935533297960811007123799943021754368000/
109556848744048640787447348456049509897631990187836088595131419058481*(-\
161175717560742724758860337819529417977481398337128785812569/
127842178933758287173786173296985043195592801194959888538153173426481*(x+7)*(x+
6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7)-\
109556848744048640787447348456049509897631990187836088595131419058481/
127842178933758287173786173296985043195592801194959888538153173426481)^2*(x^2-\
11*x+30)^2)*(x+7)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(
x-5)*(x-6)*(x-7)-\
18285330189709646386338824840935533297960811007123799943021754368000/
109556848744048640787447348456049509897631990187836088595131419058481*(
161175717560742724758860337819529417977481398337128785812569/
127842178933758287173786173296985043195592801194959888538153173426481*(x+7)*(x+
6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7)-\
109556848744048640787447348456049509897631990187836088595131419058481/
127842178933758287173786173296985043195592801194959888538153173426481)^2*(x^2-\
11*x+30)^2*(x+7)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x
-5)*(x-6)*(x-7), 1/191600640*(x-6)^2+2091763441849/539091164328837120000*(x-5)^
2*(x-9398478/1446293)^2+
18285330189709646386338824840935533297960811007123799943021754368000/
109556848744048640787447348456049509897631990187836088595131419058481*(-\
161175717560742724758860337819529417977481398337128785812569/
127842178933758287173786173296985043195592801194959888538153173426481*(x+7)*(x+
6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7)-\
109556848744048640787447348456049509897631990187836088595131419058481/
127842178933758287173786173296985043195592801194959888538153173426481)^2*(x^2-\
11*x+30)^2, 
18285330189709646386338824840935533297960811007123799943021754368000/
109556848744048640787447348456049509897631990187836088595131419058481*(
161175717560742724758860337819529417977481398337128785812569/
127842178933758287173786173296985043195592801194959888538153173426481*(x+7)*(x+
6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7)-\
109556848744048640787447348456049509897631990187836088595131419058481/
127842178933758287173786173296985043195592801194959888538153173426481)^2*(x^2-\
11*x+30)^2]
>> Degree size
46

>> Test
In between Natural Generator Test 13
>> input polynomial
(x-6)*(x-7)
>> basis
[-(x+7)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7), (x+7)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7)]
>> Time taken
167.481000
">> Sums of squares multipliers", [(x-6)*(x-7)+(1/309661231464*(x+6999/1000)^2+
55/32520311*(-5/3426634513*(x+7)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2
)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7)-3402075880/3426634513)^2064)*(x^2-13*x+42)^2*(x
+7)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-\
7)-(1/1037836800*(x-7)^2+3389181586729/6469093971946045440000*(x-6)^2*(x-\
13607531/1840973)^2)*(x+7)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3
)*(x-4)*(x-5)*(x-6)*(x-7), (1/309661231464*(x+6999/1000)^2+55/32520311*(-5/
3426634513*(x+7)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x
-5)*(x-6)*(x-7)-3402075880/3426634513)^2064)*(x^2-13*x+42)^2, 1/1037836800*(x-7
)^2+3389181586729/6469093971946045440000*(x-6)^2*(x-13607531/1840973)^2]
>> Degree size
28914

>> Test
Right Natural Generator Test
>> input polynomial
-x+7
>> basis
[-(x+7)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7), (x+7)*(x+6)*(x+5)*(x+4)*(x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7)]
>> Time taken
0.052000
">> Sums of squares multipliers", [-x+7+1/12454041600*(x+7)*(x+6)*(x+5)*(x+4)*(
x+3)*(x+2)*(x+1)*(x-1)*(x-2)*(x-3)*(x-4)*(x-5)*(x-6)*(x-7), 1/12454041600, 0]
>> Degree size
14
